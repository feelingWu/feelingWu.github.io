<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL数据库优化之组合拳(一)]]></title>
    <url>%2F2021%2F01%2F17%2Fmysql-advanced-optimization%2F</url>
    <content type="text"><![CDATA[非原创图文,图文来源于黑马官网,此处仅作为备份学习 MySQL数据库优化总概 序号 组合拳（一） 组合拳（二） 组合拳（三） 组合拳（四） 1 索引 体系结构 应用优化 MySQL 常用工具 2 视图 存储引擎 查询缓存优化 MySQL 日志 3 存储过程和函数 优化SQL步骤 内存管理及优化 MySQL 主从复制 4 触发器 索引使用 MySQL锁问题 5 SQL优化 常用SQL技巧 1. 索引1.1 索引概述MySQL官方对索引的定义为：索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。如下面示意图所示 : 左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速获取到相应数据。一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据库中用来提高性能的最常用的工具。 1.2 索引优势劣势优势1） 类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本。2） 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。 劣势1） 实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空间的。2） 虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。 1.3 索引结构索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型的。MySQL目前提供了以下4种索引： BTREE 索引 ： 最常见的索引类型，大部分索引都支持 B 树索引。 HASH 索引：只有Memory引擎支持 ， 使用场景简单 。 R-tree 索引（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍。 Full-text （全文索引） ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从Mysql5.6版本开始支持全文索引。 MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持 索引 InnoDB引擎 MyISAM引擎 Memory引擎 BTREE索引 支持 支持 支持 HASH 索引 不支持 不支持 支持 R-tree 索引 不支持 支持 不支持 Full-text 5.6版本之后支持 支持 不支持 我们平常所说的索引，如果没有特别指明，都是指B+树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引、复合索引、前缀索引、唯一索引默认都是使用 B+tree 索引，统称为 索引。 1.3.1 BTREE 结构BTree又叫多路平衡搜索树，一颗m叉的BTree特性如下： 树中每个节点最多包含m个孩子。 除根节点与叶子节点外，每个节点至少有[ceil(m/2)]个孩子。 若根节点不是叶子节点，则至少有两个孩子。 所有的叶子节点都在同一层。 每个非叶子节点由n个key与n+1个指针组成，其中[ceil(m/2)-1] &lt;= n &lt;= m-1 以5叉BTree为例，key的数量：公式推导[ceil(m/2)-1] &lt;= n &lt;= m-1。所以 2 &lt;= n &lt;=4 。当n&gt;4时，中间节点分裂到父节点，两边节点分裂。插入 C N G A H E K Q M F W L T Z D P R X Y S 数据为例。 演变过程如下： 1). 插入前4个字母 C N G A 2). 插入H，n&gt;4，中间元素G字母向上分裂到新的节点 3). 插入E，K，Q不需要分裂 4). 插入M，中间元素M字母向上分裂到父节点G 5). 插入F，W，L，T不需要分裂 6). 插入Z，中间元素T向上分裂到父节点中 7). 插入D，中间元素D向上分裂到父节点中。然后插入P，R，X，Y不需要分裂 8). 最后插入S，NPQR节点n&gt;5，中间节点Q向上分裂，但分裂后父节点DGMT的n&gt;5，中间节点M向上分裂 到此，该BTREE树就已经构建完成了， BTREE树 和 二叉树 相比， 查询数据的效率更高， 因为对于相同的数据量来说，BTREE的层级结构比二叉树小，因此搜索速度快。 1.3.3 B+TREE 结构B+Tree为BTree的变种，B+Tree与BTree的区别为： 1). n叉B+Tree最多含有n个key，而BTree最多含有n-1个key。2). B+Tree的叶子节点保存所有的key信息，依key大小顺序排列。3). 所有的非叶子节点都可以看作是key的索引部分。 由于B+Tree只有叶子节点保存key信息，查询任何key都要从root走到叶子。所以B+Tree的查询效率更加稳定。 1.3.3 MySQL中的B+TreeMySql索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。 MySQL中的 B+Tree 索引结构示意图: 1.4 索引分类1） 单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引2） 唯一索引 ：索引列的值必须唯一，但允许有空值3） 复合索引 ：即一个索引包含多个列 1.5 索引语法索引在创建表的时候，可以同时创建， 也可以随时增加新的索引。 准备环境: create database demo_01 default charset=utf8mb4; use demo_01; CREATE TABLE `city` ( `city_id` int(11) NOT NULL AUTO_INCREMENT, `city_name` varchar(50) NOT NULL, `country_id` int(11) NOT NULL, PRIMARY KEY (`city_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `country` ( `country_id` int(11) NOT NULL AUTO_INCREMENT, `country_name` varchar(100) NOT NULL, PRIMARY KEY (`country_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; insert into `city` (`city_id`, `city_name`, `country_id`) values(1,'西安',1); insert into `city` (`city_id`, `city_name`, `country_id`) values(2,'NewYork',2); insert into `city` (`city_id`, `city_name`, `country_id`) values(3,'北京',1); insert into `city` (`city_id`, `city_name`, `country_id`) values(4,'上海',1); insert into `country` (`country_id`, `country_name`) values(1,'China'); insert into `country` (`country_id`, `country_name`) values(2,'America'); insert into `country` (`country_id`, `country_name`) values(3,'Japan'); insert into `country` (`country_id`, `country_name`) values(4,'UK'); 1.5.1 创建索引语法 ： CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name [USING index_type] ON tbl_name(index_col_name,...) index_col_name : column_name[(length)][ASC | DESC] 示例 ： 为city表中的city_name字段创建索引 ； ​ ​ 1.5.2 查看索引语法： show index from table_name; 示例：查看city表中的索引信息； 1.5.3 删除索引语法 ： DROP INDEX index_name ON tbl_name; 示例 ： 想要删除city表上的索引idx_city_name，可以操作如下： 1.5.4 ALTER命令1). alter table tb_name add primary key(column_list); 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL 2). alter table tb_name add unique index_name(column_list); 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次） 3). alter table tb_name add index index_name(column_list); 添加普通索引， 索引值可以出现多次。 4). alter table tb_name add fulltext index_name(column_list); 该语句指定了索引为FULLTEXT， 用于全文索引 1.6 索引设计原则​ 索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。 对查询频次较高，且数据量比较大的表建立索引。 索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。 使用唯一索引，区分度越高，使用索引的效率越高。 索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。 使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率。 利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。 创建复合索引: CREATE INDEX idx_name_email_status ON tb_seller(NAME,email,STATUS); 就相当于 对name 创建索引 ; 对name , email 创建了索引 ; 对name , email, status 创建了索引 ; 2. 视图2.1 视图概述​ 视图（View）是一种虚拟存在的表。视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。通俗的讲，视图就是一条SELECT语句执行后返回的结果集。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。 视图相对于普通的表的优势主要包括以下几项。 简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。 安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。 数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。 2.2 创建或者修改视图创建视图的语法为： CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement [WITH [CASCADED | LOCAL] CHECK OPTION] 修改视图的语法为： ALTER [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement [WITH [CASCADED | LOCAL] CHECK OPTION] 选项 : WITH [CASCADED | LOCAL] CHECK OPTION 决定了是否允许更新数据使记录不再满足视图的条件。 LOCAL ： 只要满足本视图的条件就可以更新。 CASCADED ： 必须满足所有针对该视图的所有视图的条件才可以更新。 默认值. 示例 , 创建city_country_view视图 , 执行如下SQL : create or replace view city_country_view as select t.*,c.country_name from country c , city t where c.country_id = t.country_id; 查询视图 : 2.3 查看视图​ 从 MySQL 5.1 版本开始，使用 SHOW TABLES 命令的时候不仅显示表的名字，同时也会显示视图的名字，而不存在单独显示视图的 SHOW VIEWS 命令。 同样，在使用 SHOW TABLE STATUS 命令的时候，不但可以显示表的信息，同时也可以显示视图的信息。 如果需要查询某个视图的定义，可以使用 SHOW CREATE VIEW 命令进行查看 ： 2.4 删除视图语法 : DROP VIEW [IF EXISTS] view_name [, view_name] ...[RESTRICT | CASCADE] 示例 , 删除视图city_country_view : DROP VIEW city_country_view ; 3. 存储过程和函数3.1 存储过程和函数概述​ 存储过程和函数是 事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 ​ 存储过程和函数的区别在于函数必须有返回值，而存储过程没有。 ​ 函数 ： 是一个有返回值的过程 ； ​ 过程 ： 是一个没有返回值的函数 ； 3.2 创建存储过程CREATE PROCEDURE procedure_name ([proc_parameter[,...]]) begin -- SQL语句 end ; 示例 ： delimiter $ create procedure pro_test1() begin select 'Hello Mysql' ; end$ delimiter ; 知识小贴士 DELIMITER ​ 该关键字用来声明SQL语句的分隔符 , 告诉 MySQL 解释器，该段命令是否已经结束了，mysql是否可以执行了。默认情况下，delimiter是分号;。在命令行客户端中，如果有一行命令以分号结束，那么回车后，mysql将会执行该命令。 3.3 调用存储过程call procedure_name() ; 3.4 查看存储过程-- 查询db_name数据库中的所有的存储过程 select name from mysql.proc where db='db_name'; -- 查询存储过程的状态信息 show procedure status; -- 查询某个存储过程的定义 show create procedure test.pro_test1 \G; 3.5 删除存储过程DROP PROCEDURE [IF EXISTS] sp_name ； 3.6 语法存储过程是可以编程的，意味着可以使用变量，表达式，控制结构 ， 来完成比较复杂的功能。 3.6.1 变量 DECLARE 通过 DECLARE 可以定义一个局部变量，该变量的作用范围只能在 BEGIN…END 块中。 DECLARE var_name[,...] type [DEFAULT value] 示例 : delimiter $ create procedure pro_test2() begin declare num int default 5; select num+ 10; end$ delimiter ; SET 直接赋值使用 SET，可以赋常量或者赋表达式，具体语法如下： SET var_name = expr [, var_name = expr] ... 示例 : DELIMITER $ CREATE PROCEDURE pro_test3() BEGIN DECLARE NAME VARCHAR(20); SET NAME = 'MYSQL'; SELECT NAME ; END$ DELIMITER ; 也可以通过select … into 方式进行赋值操作 : DELIMITER $ CREATE PROCEDURE pro_test5() BEGIN declare countnum int; select count(*) into countnum from city; select countnum; END$ DELIMITER ; 3.6.2 if条件判断语法结构 : if search_condition then statement_list [elseif search_condition then statement_list] ... [else statement_list] end if; 需求： 根据定义的身高变量，判定当前身高的所属的身材类型 180 及以上 ----------&gt; 身材高挑 170 - 180 ---------&gt; 标准身材 170 以下 ----------&gt; 一般身材 示例 : delimiter $ create procedure pro_test6() begin declare height int default 175; declare description varchar(50); if height >= 180 then set description = '身材高挑'; elseif height >= 170 and height &lt; 180 then set description = '标准身材'; else set description = '一般身材'; end if; select description ; end$ delimiter ; 调用结果为 : 3.6.3 传递参数语法格式 : create procedure procedure_name([in/out/inout] 参数名 参数类型) ... IN : 该参数可以作为输入，也就是需要调用方传入值 , 默认 OUT: 该参数作为输出，也就是该参数可以作为返回值 INOUT: 既可以作为输入参数，也可以作为输出参数 IN - 输入 需求 : 根据定义的身高变量，判定当前身高的所属的身材类型 示例 : delimiter $ create procedure pro_test5(in height int) begin declare description varchar(50) default ''; if height >= 180 then set description='身材高挑'; elseif height >= 170 and height &lt; 180 then set description='标准身材'; else set description='一般身材'; end if; select concat('身高 ', height , '对应的身材类型为:',description); end$ delimiter ; OUT-输出 需求 : 根据传入的身高变量，获取当前身高的所属的身材类型 示例: create procedure pro_test5(in height int , out description varchar(100)) begin if height >= 180 then set description='身材高挑'; elseif height >= 170 and height < 180 then set description='标准身材'; else set description='一般身材'; end if; end$ 调用: call pro_test5(168, @description)$ select @description$ 小知识 @description : 这种变量要在变量名称前面加上“@”符号，叫做用户会话变量，代表整个会话过程他都是有作用的，这个类似于全局变量一样。 @@global.sort_buffer_size : 这种在变量前加上 “@@” 符号, 叫做 系统变量 3.6.4 case结构语法结构 : 方式一 : CASE case_value WHEN when_value THEN statement_list [WHEN when_value THEN statement_list] ... [ELSE statement_list] END CASE; 方式二 : CASE WHEN search_condition THEN statement_list [WHEN search_condition THEN statement_list] ... [ELSE statement_list] END CASE; 需求: 给定一个月份, 然后计算出所在的季度 示例 : delimiter $ create procedure pro_test9(month int) begin declare result varchar(20); case when month >= 1 and month &lt;=3 then set result = '第一季度'; when month >= 4 and month &lt;=6 then set result = '第二季度'; when month >= 7 and month &lt;=9 then set result = '第三季度'; when month >= 10 and month &lt;=12 then set result = '第四季度'; end case; select concat('您输入的月份为 :', month , ' , 该月份为 : ' , result) as content ; end$ delimiter ; 3.6.5 while循环语法结构: while search_condition do statement_list end while; 需求: 计算从1加到n的值 示例 : delimiter $ create procedure pro_test8(n int) begin declare total int default 0; declare num int default 1; while num&lt;=n do set total = total + num; set num = num + 1; end while; select total; end$ delimiter ; 3.6.6 repeat结构有条件的循环控制语句, 当满足条件的时候退出循环 。while 是满足条件才执行，repeat 是满足条件就退出循环。 语法结构 : REPEAT statement_list UNTIL search_condition END REPEAT; 需求: 计算从1加到n的值 示例 : delimiter $ create procedure pro_test10(n int) begin declare total int default 0; repeat set total = total + n; set n = n - 1; until n=0 end repeat; select total ; end$ delimiter ; 3.6.7 loop语句LOOP 实现简单的循环，退出循环的条件需要使用其他的语句定义，通常可以使用 LEAVE 语句实现，具体语法如下： [begin_label:] LOOP statement_list END LOOP [end_label] 如果不在 statement_list 中增加退出循环的语句，那么 LOOP 语句可以用来实现简单的死循环。 3.6.8 leave语句用来从标注的流程构造中退出，通常和 BEGIN … END 或者循环一起使用。下面是一个使用 LOOP 和 LEAVE 的简单例子 , 退出循环： delimiter $ CREATE PROCEDURE pro_test11(n int) BEGIN declare total int default 0; ins: LOOP IF n { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PAGE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习指南]]></title>
    <url>%2F2021%2F01%2F12%2Fstudy-guide%2F</url>
    <content type="text"><![CDATA[学习本身比学习内容更重要 任务式学习：1.家庭2.工作3.成长 一、寻找学习资源1.1 搜索网站、公众号 1.2 专业平台工具1.3 跟人学​三级导师制：入门、进圈、拜佛 入门：第一级导师-任意干这行的人（询问牛人（关注他们，散射他们的关注）、书）​进圈：机会​拜佛：接触：好问题 好问题： 1.请问在像您这样的专家心目中，您这个领域公认的大神是谁？ 2.我特别遗憾，我一直没有机会系统地去学，您这个领域的知识。我四十多岁了，想从现在开始学起，那在入门阶段，您推荐我读哪本书？ 3.老师，我想在大学毕业之后从事投资工作。您是做投资的，您觉得从事这一行业基本能力的要求是什么？我应该从哪开始作准备？ 4.老师，从事这个行业，您觉得最关键的环节有哪些？您都遇到过哪几个重要挑战？您是怎么过来的？ 5.在您这个领域，您觉得一般人和高手之间最大的区别是什么？ 6.如果您要带一个徒弟，您会重点教他关注哪几个魔鬼细节？为什么是这几个细节特别重要？ 7.老师，最近好长时间没见了，最近半年您觉得有什么问题、什么新闻或者哪本书，是对您触动特别大的吗？ 这个问题，是我自己很喜欢问的一个问题。首先，这个问题很轻，对方容易回答。但是在他的回答当中，我们又能收集到很多想法，收获很大。在闲谈的时候，最适合问这样的问题。 8.最近你们行业发生了一件XXX大事，您能帮我分析分析，这背后到底是怎么回事吗？ 9.老师，我现在此时此刻已经在做一件什么事。这个事，我有个难点一直没想明白，能不能请您给我指点一下？ 10.假如，此刻是你生命的最后十分钟。你有个机会，可以给这个世界留下一段话，说说你自己这个专业。请问你会说什么？ 二、定目标2.1 有场景：2.2 有距离：目标和现状有差距，跳一跳才能够得着，2.3 有抓手：距离得合适,具体可入手的地方2.3.1 开始结束时间​2.3.2 具体的执行动作​2.3.3 执行动作的数量​2.3.4 动作的完成度 2.4 有阶梯：拒绝平均用力从易到难排序，先选最易的处理（小步子原理,先摘好摘的果子） 三、提高效率3.1 五阶学习法3.1.1 测试法（设计学习任务）3.1.2 指读法3.1.3 多环境输入法（看听）3.1.4 记忆宫殿（抗遗忘）3.1.5 刷书（不读细,读广,视野） 序言，开头，倒数第二章 居高临下关注（挑战，任务清单） 四、输出倒逼输入4.1 记笔记（两轮笔记法）​ 1轮（手写）：实际输入的（关键词记录） | 当时的想法感受（讯飞语记）​ 2轮 重新用自己的逻辑写出来 4.2 讲出来 10岁-具象能懂，抽象不懂 4.3 迁移：触类旁通​ 4.3.1 能用的场景​ 4.3.2 不能用的场景 4.4 夯实，拉出操作清单 ：清单体（迭代清单1.0-&gt;2.0-&gt;3.0-&gt; …）五、正反馈（自驱力）-想方设法5.1 记笔记，小本记5.2 公开平台，定期发表自己的成果5.3 环境场（结界）5.4 惊奇日记（每日一句话） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>手册</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式]]></title>
    <url>%2F2021%2F01%2F05%2Fdesign-pattern%2F</url>
    <content type="text"><![CDATA[概述： 本质：面向对象设计原则的实际运用，是对类的封装、继承和多态性以及类的关联关系和组合关系的充分理解。 分类: 1. 创建型模式：共5种，用于描述“怎样创建对象”，主要特点是“将对象的创建与使用分离”(解耦)。客户程序仅仅需要去使用对象，而不再关心创建对象过程中的逻辑。 2. 结构型模式：共7种，用于描述如何将类或对象按某种布局组成更大的结构。 3. 行为型模式：共11种，用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。 一、6大设计原则1. 单一职责原则 (SRP)英文：Single Responsibility Principle 定义：有且仅有一个原因引起类的变更 优点： ​ 1.类的复杂性降低 ​ 2.可读性提高 ​ 3.可维护性提高 ​ 4.变更引起的风险降低 难点：职责界限的划分 适用范围：接口(一定)、类(尽量)、方法(尽可能) 2. 里式替换原则 (LSP)英文：Liskov Substitution Principle 定义： ​ 定义1：如果对每一个类型为S的对象o1,都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时,程序P的行为没有发生变化，那么类型S是类型T的子类型。 ​ 定义2：所有引用基类的地方必须能透明地使用其子类的对象。 ​ 通俗解释：父类出现的地方,子类能完美替换父类,且不会产生任何错误和异常;反之,子类出现的地方,父类未必能适应。 定义拆解： ​ 4层含义： ​ 1.子类必须完全实现父类的方法 ​ 2.子类可以有自己的个性 ​ 3.[契约设计]覆盖或实现父类的方法时输入参数，要么一样（覆写），要么可以被放大（重载） ​ 4.覆写或实现父类的方法时输出结果（返回类型）可以被缩小 优点：增强程序的健壮性 应用：版本升级(待实践) 最佳实践：在项目中,采用LSP时，尽量避免子类的“个性”，一旦子类有“个性”，这个子类和父类之间的关系就很难调和了，把子类当做父类使用，子类的“个性”被抹杀–委屈了点；把子类单独作为一个业务来使用，则会让代码间的耦合关系变的扑朔迷离–缺乏替换的标准。 3. 依赖导致原则 (DIP)英文：Dependence Inversion Principle 定义：High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions. 定义拆解： ​ 1.高层模块不应该依赖底层模块，两者都应该依赖其抽象 ​ 2.抽象不应该依赖细节，细节应该依赖抽象 优点：减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。 依赖三种写法： ​ 1.构造函数传递依赖对象 ​ 2.Setter方法传递依赖对象 ​ 3.接口声明依赖对象 本质： ​ 遵循规则： ​ 1.基本要求：通过抽象(接口或抽象类),使各类或模块的实现彼此独立,不相相互影响,实现模块间的松耦合。 ​ 2.变量的表面类型尽量是接口或者是抽象类：一个变量可以有两种类型：表面类型和实际类型，表面类型是在定义的时候赋予的类型，实际类型是对象的类型。 ​ 3.任何类都不应该从具体类派生 ​ 4.尽量不要覆写基类的方法 ​ 5.结合里氏替换原则使用 ​ 核心：“面向接口编程” 4. 接口隔离原则 (ISP)英文: Interface Segregation Principle 定义： ​ 定义1：客户端不应该依赖它不需要的接口 ​ 定义2：类间的依赖关系应该建立在最小的接口上 ​ 通俗解释：建立单一接口，不要臃肿肥大的接口。接口尽量细化，接口中的方法尽量少。 区分：单一职责原则(SRP) 和 接口隔离原则(ISP)的区别，SRP强调单一职责，要求类和职责单一，注重职责，这是逻辑业务上划分，而ISP要求接口的方法尽量少。 规范拆解： ​ 1.接口尽量小：“小”有限度，必须 满足单一职责 (SRP) ​ 2.接口要高内聚：高内聚就是提高接口、类、模块的处理能力，减少对外的交互。接口中尽量少公布public方法，接口的对外的承诺越少对系统的开发越有利，变更的风险就越少，同时也有利于降低成本。 ​ 3.定制服务：单独为一个个体体用优良的服务。只提供访问者需要的方法。 ​ 4.接口设计是由限度的:接口设计粒度越小越灵活，灵活带来了接口复杂化，开发难度增加，可维护性降低。把握好“度”。 5. 迪米特法则（LKP/LoD）英文：Law of Demeter 也称 Least Knowledge Principle 关键词：高内聚、低耦合 定义：一个对象应该对其他对象有最少的了解。 ​ 通俗解释：一个类应该对自己需要耦合或者调用的类知道得越少(即解耦、弱耦) 定义拆解： ​ 4层含义： ​ 1.只与直接的朋友通信 ，朋友类：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类 ​ 2.朋友间是有距离的：尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛，多使用private、package-private、protect等访问权限 ​ 3.是自己的就是自己的：如果一个方法放在本类中，即不增加类间关系，也对本类不产生负面影响，那就放置在本类中。 ​ 4.谨慎使用Serializable 最佳实践：一个类跳转两次以上才能访问到另一个类，就需要想办法进行重构 6. 开闭原则（OCP）英文：Open Closed Principle 定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭 二、23种设计模式（5）1. 创建型模式1.1. 简单工厂模式（SFP）英文：Simple Factory Pattern 定义：由一个工厂对象决定创建出哪一种类型实例。客户端只需传入工厂类的参数，无需关心创建过程。 优点：具体产品从客户端代码中抽离出来，解耦。 缺点：工厂类职责过重，增加新的类型时，得修改工厂类的代码，违背OCP。 最佳实践：严格意义来说，SFP不属于设计模式的一种 举例：简单工厂模式-糖果生产 创建糖果抽象类 public abstract class Candy { public abstract void eat(); } 创建抽象糖果实现类-巧克力等 public class Chocolate extends Candy{ @Override public void eat() { System.out.println("eat chocolate ing..."); } } 创建糖果工厂类 public class CandyFactory { public Candy product(String candyName){ if("chocolate".equalsIgnoreCase(candyName)){ return new Chocolate(); }else{ return null; } } } 测试 public class SfpTest { public static void main(String[] args) { CandyFactory candyFactory = new CandyFactory(); Candy chocolate = candyFactory.product("chocolate"); chocolate.eat(); } } 输出 eat chocolate ing... 1.2. 工厂方法模式（FMP）英文：Factory Method Pattern 定义：定义创建对象的接口，让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类进行。 优点： 具体产品从客户端代码中抽离出来，实现了解耦。 加入新的类型时，只需添加新的工厂方法（无需修改旧的工厂方法代码），符合OCP。 缺点：类的个数容易过多，增加复杂度。 最佳实践： 举例： 创建糖果抽象类 public abstract class Candy { public abstract void eat(); } 创建抽象工厂类 public abstract class CandyFactory { public abstract Candy product(); } 创建抽象糖果实现类-玉米软糖等 public class CornFudge extends Candy{ @Override public void eat() { System.out.println("eat corn fudge ing..."); } } 创建抽象工厂实现类-玉米软糖工厂等 public class CornFudgeFactory extends CandyFactory { @Override public Candy product() { return new CornFudge(); } } 测试 public class FmpTest { public static void main(String[] args) { CornFudgeFactory cornFudgeFactory = new CornFudgeFactory(); Candy cornFudge = cornFudgeFactory.product(); cornFudge.eat(); } } 6.输出 eat corn fudge ing... 1.3. 抽象工厂模式（AFP）英文：Abstract Factory Pattern 定义：提供了一系列相关或者相互依赖的对象的接口 优点： 具体产品从客户端代码中抽离出来，实现解耦。 将一个系列的产品族统一到一起创建 缺点：拓展新的功能困难，需要修改抽象工厂的接口 最佳实践： 举例： 创建抽象糖果类 public abstract class Candy { public abstract void eat(); public abstract void buy(); } 创建抽象价格类 public abstract class Price { public abstract void pay(); } 创建抽象工厂接口 public interface CandyFactory { Candy getCandy(); Price getPrice(); } 实现抽象工厂接口-棒棒糖工厂 public class LollipopFactory implements CandyFactory{ @Override public Candy getCandy() { return new Lollipop(); } @Override public Price getPrice() { return new LollipopPrice(); } } 创建产品族 public class Lollipop extends Candy { @Override public void eat() { System.out.println("eat lollipop ing..."); } @Override public void buy() { System.out.println("buy lollipop"); } } public class LollipopPrice extends Price{ @Override public void pay() { System.out.println("lollipop sell $2"); } } 测试 public class afpTest { public static void main(String[] args) { LollipopFactory lollipopFactory = new LollipopFactory(); lollipopFactory.getPrice().pay(); lollipopFactory.getCandy().buy(); lollipopFactory.getCandy().eat(); } } 输出 lollipop sell $2 buy lollipop eat lollipop ing... 1.4. 建造者模式（BP）英文：Builder Pattern 定义：也称为生成器模式，将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。简单来说就是，相同的过程可以创建不同的产品。 优点： 封装性好，创建和使用分离 拓展性好，建造类之间独立，一定程度上解耦。 缺点： 产生多余的Builder对象； 产品内部发生变化，建造者需要更改，成本较大。 最佳实践： 一个对象有非常复杂的内部结构（很多属性） 想将复杂对象的创建和使用分离。 举例： 创建商铺类Store(包含多属性) public class Store { private String name; private String location; private String type; @Override public String toString() { return "Store{" + "name='" + name + '\'' + ", location='" + location + '\'' + ", type='" + type + '\'' + '}'; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getLocation() { return location; } public void setLocation(String location) { this.location = location; } public String getType() { return type; } public void setType(String type) { this.type = type; } } 创建商铺抽象生成器 StoreBuilder（包含和Store相同的属性及对应的抽象构造方法） public abstract class StoreBuilder { private String name; private String location; private String type; public abstract void name(String name); public abstract void location(String location); public abstract void type(String type); public abstract Store build(); } 创建商铺抽象生成器的实现，糖果铺构造器CandyStoreBuilder public class CandyStoreBuilder extends StoreBuilder { private Store store = new Store(); @Override public void name(String name) { this.store.setName(name); } @Override public void location(String location) { this.store.setLocation(location); } @Override public void type(String type) { this.store.setType(type); } @Override public Store build() { return store; } } 创建经销商类Dealer,用于通过StoreBuilder构建具体的商铺 public class Dealer { private StoreBuilder storeBuilder; public void setStoreBuilder(StoreBuilder storeBuilder) { this.storeBuilder = storeBuilder; } public Store build(String name, String location, String type) { this.storeBuilder.name(name); this.storeBuilder.location(location); this.storeBuilder.type(type); return storeBuilder.build(); } } 测试 public class BpTest { public static void main(String[] args) { Dealer dealer = new Dealer(); dealer.setStoreBuilder(new CandyStoreBuilder()); Store store = dealer.build("甜蜜蜜糖果店", "上海市陆家嘴77号", "糖果经销"); System.out.println(store); } } 输出 Store{name='甜蜜蜜糖果店', location='上海市陆家嘴77号', type='糖果经销'} 1.5. 单例模式 (SP)英文：Singleton Pattern 定义：一个类只有一个实例 优点： 内存中只有一个实例，减少了内存开销； 避免对资源的多重占用； 缺点：没有接口，拓展困难。 最佳实践： 模式 描述 方式 优点 缺点 是否推荐 饿汉模式 不管需不需要用到实例都要去创建实例 - 线程安全 不管用到与否,类加载到内存后，就实例化一个单例 有缺点,简单实用,推荐使用 懒汉模式 需要用到创建实例了程序再去创建实例 方式一：锁,双重判空方式 1.线程安全 2.用的时候,再实例化 降低程序效率(判空+锁) 不推荐 方式二：静态内部类方式 1.线程安全(JVM保证单例) 2.加载外部类不会加载内部类,实现了懒加载 - 完美写法,推荐 枚举模式 - - 1. 解决线程同步2. 防止反序列化原因：由于枚举没有构造方法，不会被反射反射原理：类的class文件加载到内存,反射（反序列化的方式）new一个实例（前提要有构造方法） - 完美中的完美,推荐 举例： 饿汉模式、懒汉模式、单例模式 1.1. 饿汉模式 方式一：间接声明-静态代码块new public class SingletonHunger01 { //方式一 ：间接声明-静态代码块new private static final SingletonHunger01 INSTANCE; static{ INSTANCE = new SingletonHunger01(); } //构造方法设为私有,使得其他类不能new private SingletonHunger01(){}; public static SingletonHunger01 getInstance(){ return INSTANCE; } } ​ 方式二：直接声明-直接new public class SingletonHunger02 { //方式二：直接声明-直接new private static final SingletonHunger02 INSTANCE = new SingletonHunger02(); //构造方法设为私有,使得其他类不能new private SingletonHunger02(){}; public static SingletonHunger02 getInstance(){ return INSTANCE; } } ​ 1.2. 懒汉模式 ​ 方式一：锁,双重判空方式 public class SingletonLazy01 { public static SingletonLazy01 INSTANCE = null; //构造方法设为私有,使得其他类不能new private SingletonLazy01(){}; public static SingletonLazy01 getInstance(){ if(INSTANCE == null){ //降低每次进来都需要判断锁 synchronized (SingletonLazy01.class){ if(INSTANCE == null){ INSTANCE = new SingletonLazy01(); } } } return INSTANCE; } } ​ 方式二：静态内部类方式 public class SingletonLazy02 { private SingletonLazy02(){}; //静态内部类 private static class StaticInner{ private final static SingletonLazy02 INSTANCE = new SingletonLazy02(); } public static SingletonLazy02 getInstance(){ return StaticInner.INSTANCE; } } ​ 1.3. 枚举单例 public enum SingletonEnum { //单例枚举 INSTANCE; } 测试 public class SpTest { public static void main(String[] args) { System.out.println("HASHCODE-hash码,同一个类中的hash码不会相同,不同类的hashcode不能保证相同"); System.out.println("饿汉模式-间接声明方式-"+SingletonHunger01.getInstance().hashCode()); System.out.println("饿汉模式-直接声明方式-"+SingletonHunger02.getInstance().hashCode()); System.out.println("懒汉模式-锁,双重判空方式-"+SingletonLazy01.getInstance().hashCode()); System.out.println("懒汉模式-静态内部类方式-"+SingletonLazy02.getInstance().hashCode()); System.out.println("单例模式-"+SingletonEnum.INSTANCE.hashCode()); } } 输出 HASHCODE-hash码,同一个类中的hash码不会相同,不同类的hashcode不能保证相同 饿汉模式-间接声明方式-1856056345 饿汉模式-直接声明方式-221036634 懒汉模式-锁,双重判空方式-1418370913 懒汉模式-静态内部类方式-707610042 单例模式-551734240 1.6. 原型模式（PP）英文：Prototype Pattern 定义：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象 优点： 原型模式是在内存中二进制流的拷贝，要比new一个对象的性能要好，特别是需要产生大量对象时。 简化创建对象过程。 缺点： 对象必须重写Object克隆方法； 直接在内存中拷贝，构造函数是不会执行 复杂对象的克隆方法写起来较麻烦（浅克隆、深克隆） 克隆会破坏实现了Cloneable接口的单例对象 最佳实践： 如果类的初始化需要耗费较多的资源，那么可以通过原型拷贝避免这些消耗。 通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以拷贝多个对象供调用者使用，即保护性拷贝。 拓展： 克隆分类 实现 浅克隆 只复制基本类型的数据，引用类型的数据只复制了引用的地址，引用的对象并没有复制，在新的对象中修改引用类型的数据会影响原对象中的引用。 深克隆 方式一：嵌套重写clone方法：实现Cloneable接口（引用数据类型也要实现Cloneable接口），重写clone方法，clone的嵌套，复制后的对象与原对象之间完全不会影响。方式二：序列化对象：实现序列化Serializable接口（不实现Cloneable接口），（引用数据类型也要实现Serializable），对象序列化后写入流中，此时不存在引用数据类型的概念，从流中读取，生成新的对象，新对象和原对象之间也是完全互不影响的。 举例： 1.1. 浅克隆（简单属性）：创建对象，实现Cloneable，重写clone方法 public class CandyShallow implements Cloneable { private String name; private String color; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } //浅克隆 @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } @Override public String toString() { return "CandyShallow{" + "name='" + name + '\'' + ", color='" + color + '\'' + '}'; } } 1.2. 测试 public class PpTest { public static void main(String[] args) throws CloneNotSupportedException { CandyShallow candyShallow = new CandyShallow(); ArrayList&lt;CandyShallow> list = new ArrayList&lt;>(); for (int i = 0; i &lt; 3; i++) { CandyShallow clone = (CandyShallow)candyShallow.clone(); clone.setName("ALPENLIEBE"+i); clone.setColor("color"+i); list.add(clone); } System.out.println(list); } } 1.3. 输出 [Candy{name='ALPENLIEBE0', color='color0'}, Candy{name='ALPENLIEBE1', color='color1'}, Candy{name='ALPENLIEBE2', color='color2'}] 2.1. 方式一：实现Cloneable,嵌套重写clone方法 public class CandyDeep implements Cloneable { private String name; private String color; private Stuffing stuffing; //--------------------------------------重点↓ /** * 方式一：重写clone方法，实现深拷贝 * 注：该方式的缺陷是需要单独处理所有要克隆的类中的引用数据类型(Stuffing) */ @Override protected Object clone(){ CandyDeep candyDeep = null; try { candyDeep = (CandyDeep) super.clone(); candyDeep.stuffing = (Stuffing)this.stuffing.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } return candyDeep; } //--------------------------------------重点↑ @Override public String toString() { return "CandyDeep{" + "name='" + name + '\'' + ", color='" + color + '\'' + ", stuffing=" + stuffing + '}'; } public CandyDeep(String name, String color, Stuffing stuffing) { this.name = name; this.color = color; this.stuffing = stuffing; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } public Stuffing getStuffing() { return stuffing; } public void setStuffing(Stuffing stuffing) { this.stuffing = stuffing; } } public class Stuffing implements Cloneable{ private String body; private String form; private String color; //--------------------------------------重点↓ //无引用数据类型,浅克隆即可 @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } //--------------------------------------重点↑ @Override public String toString() { return "Stuffing{" + "body='" + body + '\'' + ", form='" + form + '\'' + ", color='" + color + '\'' + '}'; } public Stuffing(String body, String form, String color) { this.body = body; this.form = form; this.color = color; } public String getBody() { return body; } public void setBody(String body) { this.body = body; } public String getForm() { return form; } public void setForm(String form) { this.form = form; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } } 2.2. 方式二（推荐）：序列化对象 public class CandyDeep2 implements Serializable { private static final long serialVersionUID = 1L; private String name; private String color; private Stuffing2 stuffing2; //--------------------------------------重点↓ public CandyDeep2 deepClone() { ByteArrayOutputStream bos = null; ObjectOutputStream oos = null; ByteArrayInputStream bis = null; ObjectInputStream ois = null; try { //创建序列化流 bos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(bos); //将当前对象以对象流的方式输出 oos.writeObject(this); //创建反序列化流 bis = new ByteArrayInputStream(bos.toByteArray()); ois = new ObjectInputStream(bis); //将流对象反序列化,从而实现类的深拷贝 return (CandyDeep2) ois.readObject(); } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); return null; } finally { try { //资源释放 bos.close(); bis.close(); oos.close(); ois.close(); } catch (IOException e) { e.printStackTrace(); } } } //--------------------------------------重点↑ @Override public String toString() { return "CandyDeep2{" + "name='" + name + '\'' + ", color='" + color + '\'' + ", stuffing2=" + stuffing2 + '}'; } public CandyDeep2(String name, String color, Stuffing2 stuffing2) { this.name = name; this.color = color; this.stuffing2 = stuffing2; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } public Stuffing2 getStuffing2() { return stuffing2; } public void setStuffing2(Stuffing2 stuffing2) { this.stuffing2 = stuffing2; } } public class Stuffing2 implements Serializable { private static final long serialVersionUID = 1L; private String body; private String form; private String color; @Override public String toString() { return "Stuffing2{" + "body='" + body + '\'' + ", form='" + form + '\'' + ", color='" + color + '\'' + '}'; } public Stuffing2(String body, String form, String color) { this.body = body; this.form = form; this.color = color; } public String getBody() { return body; } public void setBody(String body) { this.body = body; } public String getForm() { return form; } public void setForm(String form) { this.form = form; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } } 2.3. 测试 public static void main(String[] args) { System.out.println("深克隆,方式一:"); CandyDeep candyDeep = new CandyDeep("黑色","酒心巧克力",new Stuffing("酒饮料","液体","无色")); System.out.println(candyDeep); //candyDeep 和 cloneCandy 非同一个对象 CandyDeep cloneCandy = (CandyDeep) candyDeep.clone(); System.out.println(cloneCandy); System.out.println("+++++++++++++++++++华丽的分界线++++++++++++++++++++++"); System.out.println("深克隆,方式二:"); CandyDeep2 candyDeep2 = new CandyDeep2("白色","果仁巧克力",new Stuffing2("果仁","固体","棕色")); System.out.println(candyDeep2); //candyDeep2 和 cloneCandy2 非同一个对象 CandyDeep2 cloneCandy2 = candyDeep2.deepClone(); System.out.println(cloneCandy2); } 2.4. 输出 深克隆,方式一: CandyDeep{name='黑色', color='酒心巧克力', stuffing=Stuffing{body='酒饮料', form='液体', color='无色'}} CandyDeep{name='黑色', color='酒心巧克力', stuffing=Stuffing{body='酒饮料', form='液体', color='无色'}} +++++++++++++++++++华丽的分界线++++++++++++++++++++++ 深克隆,方式二: CandyDeep2{name='白色', color='果仁巧克力', stuffing2=Stuffing2{body='果仁', form='固体', color='棕色'}} CandyDeep2{name='白色', color='果仁巧克力', stuffing2=Stuffing2{body='果仁', form='固体', color='棕色'}} 2.结构型模式（7）2.1. 外观模式（FP）英文：Facade Pattern 定义：外观模式又叫门面模式，提供了统一的接口，用来访问子系统中的一群接口。 优点： 简化了调用过程，无需了解深入子系统 减低耦合度； 更好的层次划分； 符合LKP。 缺点： 增加子系统，拓展子系统行为容易引入风险； 不符合OCP。 最佳实践： 子系统越来越复杂，增加外观模式提供简单接口调用； 构建多层系统结构，利用外观对象作为每层的入口，简化层间调用。 举例： 客户购买现做蛋糕，客户直接和前台打交道，前台和后台(制作蛋糕,装饰,打包)传达信息，后台对于客户被透明化 创建蛋糕信息实体 public class CakeInfo { private String cakeName; private Double amount; private Integer num; @Override public String toString() { return "CakeInfo{" + "cakeName='" + cakeName + '\'' + ", amount=" + amount + ", num=" + num + '}'; } public Double getAmount() { return amount; } public void setAmount(Double amount) { this.amount = amount; } public Integer getNum() { return num; } public void setNum(Integer num) { this.num = num; } public String getCakeName() { return cakeName; } public void setCakeName(String cakeName) { this.cakeName = cakeName; } } 创建后台-制作服务 public class MakeService { public boolean makeCake(String cakeName){ System.out.println("糕点师制作"+cakeName); return true; } } 创建后台-装饰服务 public class DecorateService { public boolean decorateCake(String cakeName){ System.out.println("装饰师装饰"+cakeName); return true; } } 创建后台-打包服务 public class PackageService { public boolean packageCake(String cakeName){ System.out.println("打包师打包"+cakeName+",并转交前台"); return true; } } 创建前台服务聚合后台服务 public class FrontDeskService { private MakeService maker = new MakeService(); private DecorateService decorator = new DecorateService(); private PackageService packer = new PackageService(); public void sellCake(CakeInfo cakeInfo){ System.out.println("前台从客户接受蛋糕信息:"+cakeInfo); String cakeName = cakeInfo.getCakeName(); if(maker.makeCake(cakeName)){ if(decorator.decorateCake(cakeName)){ if(packer.packageCake(cakeName)){ System.out.println("前台收到蛋糕->转交客户->收银->销售成功"); } } } } } 测试 public class FpTest { public static void main(String[] args) { CakeInfo cakeInfo = new CakeInfo(); cakeInfo.setAmount(100.00); cakeInfo.setNum(1); cakeInfo.setCakeName("巧克力蛋糕"); FrontDeskService frontDeskService = new FrontDeskService(); frontDeskService.sellCake(cakeInfo); } } 输出 前台从客户接受蛋糕信息:CakeInfo{cakeName='巧克力蛋糕', amount=100.0, num=1} 糕点师制作巧克力蛋糕 装饰师装饰巧克力蛋糕 打包师打包巧克力蛋糕,并转交前台 前台收到蛋糕->转交客户->收银->销售成功 2.2. 装饰者模式（DP）英文：Decorator Pattern 定义：在不改变原有对象的基础之上，将功能附加到对象上，提供了比继承更有弹性的替代方案 优点： 继承的有力补充，不改变原有对象的情况下给对象拓展功能 通过使用不同的装饰类、不同的组合方式，实现不同的效果 符合OCP 缺点：增加程序复杂性 最佳实践： 拓展一个类的功能 动态给对象添加功能，并且动态撤销 举例： 客户买蛋糕，要求对蛋糕加不同材料(果切，奶油，巧克力，装饰画等)，价格也随之变动 1.创建蛋糕套餐抽象类 public abstract class CakePackage { public abstract String remark(); public abstract int price(); } 2.创建装饰器类继承蛋糕套餐抽象类 public class CakeDecorator extends CakePackage{ private CakePackage cakePackage; public CakeDecorator(CakePackage cakePackage) { this.cakePackage = cakePackage; } @Override public String remark() { return cakePackage.remark(); } @Override public int price() { return cakePackage.price(); } } 3.创建标准蛋糕套餐类 public class StandardCakePackage extends CakePackage{ @Override public String remark() { return "蛋糕胚\n"; } @Override public int price() { return 5; } } 4.创建加奶油、水果、糖果等增值套餐类 public class CreamCakePackage extends CakeDecorator { public CreamCakePackage(CakePackage cakePackage) { super(cakePackage); } @Override public String remark() { return super.remark()+"加奶油\n"; } @Override public int price() { return super.price()+5; } } public class FruitCakePackage extends CakeDecorator { public FruitCakePackage(CakePackage cakePackage) { super(cakePackage); } @Override public String remark() { return super.remark() + "加水果\n"; } @Override public int price() { return super.price()+10; } } public class CandyCakePackage extends CakeDecorator { public CandyCakePackage(CakePackage cakePackage) { super(cakePackage); } @Override public String remark() { return super.remark()+"加糖果\n"; } @Override public int price() { return super.price()+15; } } 5.测试 public class DpTest { public static void main(String[] args) { CakePackage cake = new StandardCakePackage(); cake = new CreamCakePackage(cake); cake = new FruitCakePackage(cake); cake = new CandyCakePackage(cake); System.out.println(cake.remark()+"价格："+cake.price()+"元"); } } 6.输出 蛋糕胚 加奶油 加水果 加糖果 价格：35元 2.3. 适配器模式（AP）英文：Adapter Pattern 定义：将一个类的接口转换为期望的另一个接口，使原本不兼容的类可以一起工作 优点： 提高类的透明性和复用，现有的类复用但不需改变 目标类和适配器类解耦，提高程序拓展性 符合OCP 缺点： 适配器编写过程需要全面考虑，可能会增加系统的复杂性 降低代码可读性 最佳实践：已存在的类，它的方法和需求不匹配时（方法结果相同或者相似） 举例： 原有的蛋糕产品线，新增一个物料产品线(水果、奶油等)，在不修改原产品线的同时,两个产品线共同工作 创建蛋糕产品线类 public class Cake { public void makeCakes(){ System.out.println("生产蛋糕"); } } 创建物料产品线接口 public interface Materiel { void make(); } 蛋糕产品类加入到物料产品线，创建一个适配器 //一般适配器 public class CreamCakeAdaptor extends Cake implements Materiel{ @Override public void make() { System.out.println("生产奶油预备"); super.makeCakes(); System.out.println("混合成奶油蛋糕"); } } //对象适配器 public class FruitCakeAdaptor implements Materiel{ Cake cake = new Cake(); @Override public void make() { System.out.println("生产果切预备"); cake.makeCakes(); System.out.println("混合成水果蛋糕"); } } 测试 public class ApTest { public static void main(String[] args) { CreamCakeAdaptor creamCakeAdaptor = new CreamCakeAdaptor(); creamCakeAdaptor.make(); System.out.println("++++++++++++++华丽的分割线+++++++++++++++"); FruitCakeAdaptor fruitCakeAdaptor = new FruitCakeAdaptor(); fruitCakeAdaptor.make(); } } 输出 生产奶油预备 生产蛋糕 混合成奶油蛋糕 ++++++++++++++华丽的分割线+++++++++++++++ 生产果切预备 生产蛋糕 混合成水果蛋糕 2.4. 享元模式（FP）英文：Flyweight Pattern 定义：提供了减少对象数量从而改善应用所需的对象结构的方式，运用共享技术有效地支持大量细粒度的对象。 优点：减少对象的创建，降低内存占用； 缺点： 关注内部状态或外部状态，关注线程安全问题；（内部状态：享元对象的属性状态，不会因为外部的改变而改变； 外部状态：方法参数） 程序的逻辑复杂化。 最佳实践： 减少对象的创建，降低内存占用； 统拥有大量相似对象，需要缓冲池的场景。 举例：制作大量相同类型的蛋糕（代码关键是通过HashMap存储对象） 创建蛋糕接口 public interface Cake { void make() throws InterruptedException; } 具体类(如：水果类型蛋糕)实现蛋糕接口 public class FruitCake implements Cake { private String name; private LocalDateTime productTime; public FruitCake(String name){ this.name = name; } public void setProductTime(LocalDateTime productTime) { this.productTime = productTime; } @Override public void make() { try { Thread.sleep(100); System.out.println(name+"生产时间："+this.productTime); } catch (InterruptedException e) { e.printStackTrace(); } } } 创建水果蛋糕的工厂 public class FruitCakeFactory { //关键点 private static final HashMap&lt;String,FruitCake> CAKE_HASH_MAP = new HashMap&lt;>(); public static FruitCake product(String name){ FruitCake fruitCake = CAKE_HASH_MAP.get(name); if(fruitCake == null){ System.out.println("没有"+name+"制作方法,学习制作方法"); fruitCake = new FruitCake(name); CAKE_HASH_MAP.put(name,fruitCake); } return fruitCake; } } 测试 public class FpTest { private static final String[] CAKE_TYPE = {"蓝莓蛋糕","火龙果蛋糕","草莓蛋糕","香蕉蛋糕"}; public static void main(String[] args) { IntStream.range(0,10).forEach((i)->{ String name = CAKE_TYPE[(int)(Math.random() * CAKE_TYPE.length)]; FruitCake cake = FruitCakeFactory.product(name); cake.setProductTime(LocalDateTime.now()); cake.make(); }); } } 输出 10次循环中，只生产了4个对象，很好的描述了系统有大量相似对象，需要缓冲池的场景。 JDK中的字符串常量池，数据库连接池等都是用的享元模式。 没有蓝莓蛋糕制作方法,学习制作方法 蓝莓蛋糕生产时间：2020-12-13T10:49:17.647076600 蓝莓蛋糕生产时间：2020-12-13T10:49:17.779721700 没有草莓蛋糕制作方法,学习制作方法 草莓蛋糕生产时间：2020-12-13T10:49:17.881450300 草莓蛋糕生产时间：2020-12-13T10:49:17.982180600 没有香蕉蛋糕制作方法,学习制作方法 香蕉蛋糕生产时间：2020-12-13T10:49:18.085903500 蓝莓蛋糕生产时间：2020-12-13T10:49:18.204594900 蓝莓蛋糕生产时间：2020-12-13T10:49:18.305322300 香蕉蛋糕生产时间：2020-12-13T10:49:18.430981100 草莓蛋糕生产时间：2020-12-13T10:49:18.541684900 蓝莓蛋糕生产时间：2020-12-13T10:49:18.645407200 2.5. 组合模式（CP）英文：Composite Pattern 定义：又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。 优点： 层次清晰 客户端不必关系层次差异，方便控制 符合OCP 缺点：树形处理较为复杂 最佳实践： 客户端可以忽略组合对象与单个对象的差异 处理树形结构数据 举例：菜单按钮组成的树形 创建菜单按钮组合抽象类 public abstract class MenuButton { public void add(MenuButton menuButton) { throw new UnsupportedOperationException("不支持创建操作"); } public String getName() { throw new UnsupportedOperationException("不支持名称获取"); } public String getType() { throw new UnsupportedOperationException("不支持类型获取"); } public String getIcon() { throw new UnsupportedOperationException("不支持图标"); } public void print() { throw new UnsupportedOperationException("不支持打印操作"); } } 创建按钮类 public class Button extends MenuButton{ private String name; public Button(String name) { this.name = name; } @Override public String getName() { return name; } @Override public String getType(){ return "按钮"; } @Override public void print() { System.out.println(getName() + "[" + getType() + "]"); } } 创建菜单类 public class Menu extends MenuButton { private List&lt;MenuButton> items = new ArrayList&lt;>(); private String name; private String icon; private Integer level; public Menu(String name, String icon, Integer level) { this.name = name; this.icon = icon; this.level = level; } @Override public void add(MenuButton menuButton){ items.add(menuButton); } @Override public String getName() { return this.name; } @Override public String getType() { return "菜单"; } @Override public String getIcon() { return this.icon; } @Override public void print() { System.out.println(getIcon() + getName() + "[" + getType() + "]"); for (MenuButton item : items) { if (this.level != null) { for (int i = 0; i &lt; this.level; i++) { System.out.print(" "); } } item.print(); } } } 测试 public class CpTest { public static void main(String[] args) { Menu userMenu = new Menu("用户管理", "🧑", 2); Button createUser = new Button("新增用户"); Button updateUser = new Button("修改用户"); Button deleteUser = new Button("删除用户"); userMenu.add(createUser); userMenu.add(updateUser); userMenu.add(deleteUser); Menu logMenu = new Menu("操作日志", "📃", 2); Button export = new Button("导出Excel"); logMenu.add(export); Menu systemMenu = new Menu("系统管理", "🔨", 1); systemMenu.add(userMenu); systemMenu.add(logMenu); systemMenu.print(); } } 输出 🔨系统管理[菜单] 🧑用户管理[菜单] 新增用户[按钮] 修改用户[按钮] 删除用户[按钮] 📃操作日志[菜单] 导出Excel[按钮] 2.6. 桥接模式（BP）英文：Bridge Pattern 定义：将抽象部分和具体实现部分分离，使它们都可以独立变化。通过组合的方式建立两个类之间的关系，而不是通过继承。 优点： 分离抽象部分和具体实现部分 提高了系统可拓展性 符合OCP和合成复用原则 缺点：增加了系统的理解和设计难度 最佳实践： 抽象和实体实现之间增加更多的灵活性 一个类存在多个独立变化的维度，并且需要独立拓展 不希望使用继承 举例： 1.创建蛋糕的接口类 public interface Cake { Cake makeCake(); void getCake(); } 2.创建蛋糕接口的实现类 水果蛋糕 public class FruitCake implements Cake { @Override public Cake makeCake() { System.out.println("制作水果蛋糕"); return new FruitCake(); } @Override public void getCake() { System.out.println("获得水果蛋糕"); } } 奶油蛋糕 public class CreamCake implements Cake { @Override public Cake makeCake() { System.out.println("制作奶油蛋糕"); return new CreamCake(); } @Override public void getCake() { System.out.println("获得奶油蛋糕"); } } 3.创建店铺抽象类,通过属性的方式和蛋糕接口相关联，目的是可以在不同的店铺实现类中灵活地制作各种蛋糕 店铺抽象类 public abstract class Store { protected Cake cake; public Store(Cake cake){ this.cake = cake; } abstract Cake makeCake(); } 店铺实现类 public class ZhangSanStore extends Store{ public ZhangSanStore(Cake cake) { super(cake); } @Override Cake makeCake() { System.out.println("张三的蛋糕店"); return cake.makeCake(); } } public class LiSiStore extends Store { public LiSiStore(Cake cake) { super(cake); } @Override Cake makeCake() { System.out.println("李四的蛋糕店"); return cake.makeCake(); } } 4.测试 public class BpTest { public static void main(String[] args) { ZhangSanStore zhangSanStore = new ZhangSanStore(new FruitCake()); Cake cake = zhangSanStore.makeCake(); cake.getCake(); System.out.println("++++++++++++++++华丽的分割线+++++++++++++++++"); LiSiStore liSiStore = new LiSiStore(new CreamCake()); Cake cake1 = liSiStore.makeCake(); cake1.getCake(); } } 5.输出 张三的蛋糕店 制作水果蛋糕 获得水果蛋糕 ++++++++++++++++华丽的分割线+++++++++++++++++ 李四的蛋糕店 制作奶油蛋糕 获得奶油蛋糕 2.7. 代理模式（PP）英文：Proxy Pattern 定义：为其他对象提供一种代理，以控制对这个对象的访问，代理对象在客户端和目标对象之间起到了中介的作用 优点： 将代理对象和真实被调用的目标对象分离 降低耦合，拓展性好 保护目标对象，增强目标对象 缺点： 造成类的数目增加，增加复杂度 客户端和目标对象增加代理对象，会造成处理速度变慢 最佳实践： 保护目标对象 增强目标对象 代理分类 功能 缺点 静态代理 通过在代码中显式地定义了一个代理类，在代理类中通过同名的方法对目标对象的方法进行包装，客户端通过调用代理类的方法来调用目标对象的方法。 每需要代理一个类，就需要手写对应的代理类 动态代理 JDK的动态代理只能代理接口，通过接口的方法名在动态生成的代理类中调用业务实现类的同名方法。 CGLib代理 通过继承来实现，生成的代理类就是目标对象类的子类，通过重写业务方法来实现代理 Spring对代理模式的拓展 1. 当Bean有实现接口时，使用JDK动态代理； 2. 当Bean没有实现接口时，使用CGLib代理。 举例： 1.静态代理 （1）创建糖果类接口 public interface ICandyService { void makeCandy(); } （2）创建糖果类实现类 public class CandyServiceServiceImpl implements ICandyService { @Override public void makeCandy() { System.out.println("制作糖果"); } } （3）创建代理对象 public class ProxyService { private ICandyService iCandyService; public void makeCandy(){ beforeMethod(); iCandyService = new CandyServiceServiceImpl(); iCandyService.makeCandy(); afterMethod(); } private void afterMethod() { System.out.println("包装"); } private void beforeMethod() { System.out.println("准备材料"); } } （4）测试 public class PpTest { public static void main(String[] args) { System.out.println("[代理模式-静态代理]"); ProxyService proxyService = new ProxyService(); proxyService.makeCandy(); } } （5）输出 [代理模式-静态代理] 准备材料 制作糖果 包装 2.动态代理 （1）创建饼干类接口 public interface IBiscuitService { void makeBiscuit(String ingredients); } （2）创建饼干类实现类 public class BiscuitServiceImpl implements IBiscuitService { @Override public void makeBiscuit(String ingredients) { System.out.println("制作"+ingredients+"饼干"); } } （3）创建动态代理 public class DynamicProxy implements InvocationHandler { // 代理的目标对象 private Object object; public DynamicProxy(Object object) { this.object = object; } public Object proxy(){ Class&lt;?> clazz = object.getClass(); return Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this); } /** * @param proxy 动态生成的代理对象 * @param method 代理方法 * @param args 代理方法的方法参数 * @return 结果 * @throws Throwable 异常 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { beforeMethod(object); // 反射执行代理对象的目标方法 Object result = method.invoke(object, args); afterMethod(object); return result; } private void beforeMethod(Object object) { if (object instanceof IBiscuitService) { System.out.println("准备饼干配料"); } else if (object instanceof ICandyService) { System.out.println("准备糖果配料"); } else { throw new RuntimeException("暂不支持代理" + object.getClass() + "类型"); } } private void afterMethod(Object object) { if (object instanceof IBiscuitService) { System.out.println("包装饼干"); } else if (object instanceof ICandyService) { System.out.println("包装糖果"); } else { throw new RuntimeException("暂不支持代理" + object.getClass() + "类型"); } } } （4）测试 public class Pp2Test { public static void main(String[] args) { System.out.println("[代理模式-动态代理]"); ICandyService candyService = (ICandyService) new DynamicProxy(new CandyServiceServiceImpl()).proxy(); candyService.makeCandy(); System.out.println("++++++++++++++++华丽的分割线+++++++++++++++++"); IBiscuitService biscuitService = (IBiscuitService) new DynamicProxy(new BiscuitServiceImpl()).proxy(); biscuitService.makeBiscuit("草莓"); System.out.println("++++++++++++++++华丽的分割线+++++++++++++++++"); biscuitService.makeBiscuit("奶油"); } } （5）输出 [代理模式-动态代理] 准备糖果配料 制作糖果 包装糖果 ++++++++++++++++华丽的分割线+++++++++++++++++ 准备饼干配料 制作草莓饼干 包装饼干 ++++++++++++++++华丽的分割线+++++++++++++++++ 准备饼干配料 制作奶油饼干 包装饼干 3.CGLib代理 ​ 通过继承来实现，生成的代理类就是目标对象类的子类，通过重写业务方法来实现代理。 4.Spring对代理模式的扩展 ​ 可以通过以下配置强制使用CGLib代理; spring: aop: proxy-target-class: true 3.行为型模式（11）3.1. 模板方法模式（TP）英文：Template Pattern 定义：模板方法模式定义了一个流程的骨架，由多个方法组成。并允许子类为一个或多个步骤提供实现。简而言之就是公共的不变的部分由父类统一实现，变化的部分由子类来个性化实现。 优点： 提高复用性 提高拓展性 OCP 缺点： 类的数目增加 增加了系统实现的复杂度 父类添加新的抽象方法，所有子类都要改一遍 最佳实践： 举例：外卖1.创建固定流程抽象类 public abstract class Takeaway { final void order() { System.out.println("(流程固定)下单"); } final void packageSend() { System.out.println("(流程固定)打包派送"); } protected abstract void make(); protected boolean needTableware() { return true; } final void flow() { this.order(); this.make(); if (needTableware()) { System.out.println("赠送一次性餐具"); } this.packageSend(); } } 2.创建子类实现类 public class CakeTakeaway extends Takeaway{ @Override protected void make() { System.out.println("制作蛋糕"); } @Override protected boolean needTableware(){ return super.needTableware(); } } public class BiscuitTakeaway extends Takeaway{ @Override protected void make() { System.out.println("制作饼干"); } @Override protected boolean needTableware() { return false; } } 3.测试 public class TpTest { public static void main(String[] args) { CakeTakeaway cakeTakeaway = new CakeTakeaway(); cakeTakeaway.flow(); System.out.println("++++++++++++++华丽的分割线+++++++++++++++"); BiscuitTakeaway biscuitTakeaway = new BiscuitTakeaway(); biscuitTakeaway.flow(); } } 4.实现 (流程固定)下单 制作蛋糕 赠送一次性餐具 (流程固定)打包派送 ++++++++++++++华丽的分割线+++++++++++++++ (流程固定)下单 制作饼干 (流程固定)打包派送 3.2. 迭代器模式（IP）英文：Iterator Pattern 定义：迭代器模式，又称游标模式。这种模式提供一种方法访问一个容器对象中各个元素，而又不需要暴露该对象的内部细节。 优点： 1.它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。替换迭代器就可以切换遍历方法。 2.迭代器简化了聚合类。聚合对象可以不用自己再提供遍历方法。 3.在迭代器模式中由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足“开闭原则”的要求。 缺点： 1.由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器来，类的个数成对增加，这在一定程度上增加了系统的复杂性。 2.抽象迭代器设计难度相对较大，需要充分考虑到系统将来的扩展，，例如JDK内置迭代器Iterator就无法实现逆向遍历，如果需要实现逆向遍历，只能通过其子类ListIterator等来实现，而ListIterator迭代器无法用于操作Set类型的聚合对象。 最佳实践： 1.访问一个聚合对象的内容而无须暴露它的内部表示。将聚合对象的访问与内部数据的存储分离，使得访问聚合对象时无须了解其内部实现细节。 2.需要为一个聚合对象提供多种遍历方式。 3.为遍历不同聚合结构提供统一的接口，该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性的操作该接口。 举例： 1.创建抽象容器 public interface Aggregate { void add(Object obj); void remove(Object obj); Iterator iterator(); } 2.创建容器实现类 public class ConcreteAggregate implements Aggregate{ private List list = new ArrayList(); @Override public void add(Object obj) { list.add(obj); } @Override public void remove(Object obj) { list.remove(obj); } @Override public Iterator iterator() { return new ConcreteIterator(list); } } 3.创建抽象迭代器 public interface Iterator { Object next(); boolean hasNext(); } 4.创建具体迭代器实现类 public class ConcreteIterator implements Iterator { private List list = new ArrayList(); private int cursor = 0; public ConcreteIterator(List list) { this.list = list; } @Override public Object next() { Object obj = null; if (this.hasNext()) { obj = this.list.get(cursor++); } return obj; } @Override public boolean hasNext() { if (cursor == list.size()) { return false; } return true; } } 5.测试 public class IpTest { public static void main(String[] args) { Aggregate ag = new ConcreteAggregate(); ag.add("a"); ag.add("b"); ag.add("c"); Iterator it = ag.iterator(); while(it.hasNext()){ String str = (String)it.next(); System.out.println(str); } } } 6.输出 a b c 3.3. 策略模式（SP）英文：Strategy Pattern 定义：策略模式定义了算法家族，分别封装起来，让它们之间可以互相替换。此模式让算法的变化不会影响到使用算法的用户。策略模式常用于消除大量的if else代码。 优点： 缺点： 最佳实践： 系统有很多类，它们的区别仅仅在于行为不同 一个系统需要动态地在几种算法中选择一种 举例：促销活动 1.创建活动接口 public interface Activity { void discount(); } 2.创建多接口实现类 public class StrategyOne implements Activity{ @Override public void discount() { System.out.println("满减返现"); } } public class StrategyTwo implements Activity { @Override public void discount() { System.out.println("满减打折"); } } 3.测试 public class SpTest { public static void main(String[] args) { String plan = "A"; if("A".equalsIgnoreCase(plan)){ StrategyOne strategyOne = new StrategyOne(); strategyOne.discount(); }else if("B".equalsIgnoreCase(plan)){ StrategyTwo strategyTwo = new StrategyTwo(); strategyTwo.discount(); }else{ throw new RuntimeException("暂不支持活动策略"); } } } 4.输出 满减返现 3.4. 解释器模式（IP）– TODO英文：Interpreter Pattern 定义： 优点： 缺点： 最佳实践： 举例：最难模式，不常用，后补充 3.5. 观察者模式（OP）英文：Observer Pattern 定义：观察者模式定义了对象之间的一对多依赖，让多个观察者同时监听某个主题对象，当主体对象发生变化时，它的所有观察者都会收到响应的通知。 优点： 观察者和被观察者之间建立一个抽象的耦合； 观察者模式支持广播通信。 缺点： 观察者之间有过多的细节依赖，提高时间消耗及程序复杂度 应避免循环调用 最佳实践： 举例：公众号推送文章 1.创建被观察者(公众号) public class OfficialAccount extends Observable { private String accountName; public OfficialAccount(String accountName) { this.accountName = accountName; } public String getAccountName() { return accountName; } public void push(Article article) { System.out.println("【"+this.accountName+"】" +"发起推送>>>"+article.getAuthor()+"的《"+article.getName()+"》"); // 设置标识位 changed = true，表示被观察者发生了改变 setChanged(); // 通知观察者，可以给观察者传递数据 notifyObservers(article); } } 2.创建观察者（订阅者） public class Followers implements Observer { private String name; public Followers(String name) { this.name = name; } @Override public void update(Observable o, Object arg) { OfficialAccount officialAccount = (OfficialAccount) o; Article article = (Article) arg; System.out.println(name+":::收到【"+officialAccount.getAccountName()+"】的推送:"+article.getAuthor()+"的《"+article.getName()+"》"); } } 3.创建推送对象（文章） public class Article { private String name; private String author; public Article(String name, String author) { this.name = name; this.author = author; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } } 4.测试 public class OpTest { public static void main(String[] args) { OfficialAccount officialAccount = new OfficialAccount("JAVA大本营"); //添加订阅者 Followers follower1 = new Followers("路人甲"); officialAccount.addObserver(follower1); Followers follower2 = new Followers("路人乙"); officialAccount.addObserver(follower2); //推送 Article article = new Article("大话设计模式","菜鸟"); officialAccount.push(article); } } 5.输出 【JAVA大本营】发起推送>>>菜鸟的《大话设计模式》 路人乙:::收到【JAVA大本营】的推送:菜鸟的《大话设计模式》 路人甲:::收到【JAVA大本营】的推送:菜鸟的《大话设计模式》 3.6. 备忘录模式（MP）英文：Memento Pattern 定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。 优点： 1.它提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原。 2.备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。备忘录保存了原发器的状态，采用列表、堆栈等集合来存储备忘录对象可以实现多次撤销操作。 缺点：资源消耗过大，如果需要保存的原发器类的成员变量太多，就不可避免需要占用大量的存储空间，每保存一次对象的状态都需要消耗一定的系统资源。 最佳实践： 保存一个对象在某一个时刻的全部状态或部分状态，这样以后需要时它能够恢复到先前的状态，实现撤销操作。 防止外界对象破坏一个对象历史状态的封装性，避免将对象历史状态的实现细节暴露给外界对象。 名称 作用 原发器类（Originator） 创建一个备忘录对象，使用备忘录存储它的内部状态 负责人类（CareTaker） 负责保存好备忘录对象，不能检查或操作备忘录的内容 备忘录类（Memento） 将原发器的内部状态存储起来，原发器根据需要决定备忘录存储原发器的哪些内部状态 举例：冒险岛闯关 1.创建游戏类 public class AdventureIslandGame { /**关卡*/ private Integer point; /**建档*/ public GameMemento createMemento(Integer point){ return new GameMemento(point); } /**开始游戏*/ public void play(){ point = 1; } /**恢复备份*/ public void restore(GameMemento gameMemento){ this.point = gameMemento.getPoint(); } public Integer getPoint() { return point; } public void setPoint(Integer point) { this.point = point; } } 2.创建备份 public class GameMemento { /**关卡*/ private Integer point; /** * 备份关卡 */ public GameMemento(int point){ this.point = point; } public Integer getPoint() { return point; } public void setPoint(Integer point) { this.point = point; } } 3.创建备份管理类 public class Caretaker { private GameMemento gameMemento; /**恢复备份*/ public GameMemento retrieveMemento(){ return this.gameMemento; } /**保存备份*/ public void saveMemento(GameMemento gameMemento){ this.gameMemento = gameMemento; } } 4.测试 public class MpTest { public static void main(String[] args) { System.out.println("[冒险岛闯关游戏]"); AdventureIslandGame game = new AdventureIslandGame(); System.out.println("游戏开始"); game.play(); System.out.println("进入第"+game.getPoint()+"关"); System.out.println("击杀第"+game.getPoint()+"关boss,进入下一关"); System.out.println("创建新档..."); GameMemento gameMemento = game.createMemento(game.getPoint()); Caretaker caretaker = new Caretaker(); caretaker.saveMemento(gameMemento); System.out.println("~~~~~~第"+game.getPoint()+"关,存档完成~~~~~~"); game.setPoint(game.getPoint()+1); System.out.println("进入第"+game.getPoint()+"关"); System.out.println("击杀第"+game.getPoint()+"关boss,进入下一关"); gameMemento.setPoint(game.getPoint()); caretaker.saveMemento(gameMemento); System.out.println("~~~~~~第"+game.getPoint()+"关,存档完成~~~~~~"); game.setPoint(game.getPoint()+1); System.out.println("进入第"+game.getPoint()+"关"); System.out.println("被第"+game.getPoint()+"关boss杀死,游戏结束"); System.out.println("回退关卡..."); game.restore(caretaker.retrieveMemento()); System.out.println("~~~~~~回退完成,当前关卡第"+game.getPoint()+"关~~~~~~"); game.setPoint(game.getPoint()+1); System.out.println("获取当前关卡：进入第"+game.getPoint()+"关"); } } 5.输出 [冒险岛闯关游戏] 游戏开始 进入第1关 击杀第1关boss,进入下一关 创建新档... 进入第2关 击杀第2关boss,进入下一关 ​~~~~~~第2关,存档完成~~~~~~ 进入第3关 被第3关boss杀死,游戏结束 回退关卡... ​~~~~~~回退完成,当前关卡第2关~~~~~~ 获取当前关卡：进入第3关 3.7. 命令模式（CP）英文：Command Pattern 定义： 将一个请求封装为一个对象，从而使我们可用不同的请求对用户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。 名称 作用 抽象命令者（Command） 定义命令的接口，声明执行的方法。 具体命令类（ConcreteCommand） 命令接口实现对象，是“虚”的实现；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。 接收者（Receiver） 真正执行命令的对象。任何类都可能成为一个接收者，只要它能够根据命令要求实现的相应功能。 调用者（Invoker） 要求命令要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这是用户端真正出发命令并要求命令执行相应操作的地方，也就是说，相当于使用命令对象的入口。 具体命令对象（client） 创建具体的命令对象，并且设置命令对象的接收者。也可以理解为装配者。 优点： 降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。 新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求。 缺点：使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用。 最佳实践： 1.系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。 2.系统需要在不同的时间指定请求、将请求排队和执行请求。 举例：Siri语音助手 1.创建命令接口 public interface Command { //执行命令 void execute(); } 2.创建具体实现命令实现类 public class OpenCommand implements Command { private Application app; public OpenCommand(Application app){ this.app = app; } @Override public void execute() { app.on(); } } public class CloseCommand implements Command { private Application app; public CloseCommand(Application app){ this.app = app; } @Override public void execute() { app.off(); } } 3.创建应用抽象类 public abstract class Application { public abstract void on(); public abstract void off(); } 4.创建应用实现类 public class WeChat extends Application { @Override public void on() { System.out.println("微信打开了"); } @Override public void off() { System.out.println("微信关闭了"); } } public class Alipay extends Application { @Override public void on() { System.out.println("支付宝打开了"); } @Override public void off() { System.out.println("支付宝关闭了"); } } 5.实现命令发起者 public class Siri { private Command command; /** * 设置要执行的命令 * @param command 命令 */ public void setCommand(Command command){ this.command = command; } /** * 执行命令 */ public void executeCommand(){ command.execute(); } } 6.测试 public class CpTest { public static void main(String[] args) { Siri siri = new Siri(); System.out.println("嘿 siri， 打开微信"); Application weChat = new WeChat(); Command command = new OpenCommand(weChat); //siri传递命令 siri.setCommand(command); siri.executeCommand(); System.out.println("嘿 siri，打开支付宝"); Application alipay = new Alipay(); command = new OpenCommand(alipay); //siri传递命令 siri.setCommand(command); siri.executeCommand(); } } 7.输出 嘿 siri， 打开微信 微信打开了 嘿 siri，打开支付宝 支付宝打开了 3.8. 中介者模式（MP）英文：Mediator Pattern 定义：中介者模式是指用一个中介对象来封装一系列的对象交互。中介者使个对象不需要显示的相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 优点： 1.简化了对象之间的交互，它用中介者和同事的一对多交互代替了原来同事之间的多对多交互，一对多关系更容易理解、维护扩展，将原本难以理解的网状结构转换成相对简单的星型结构。 2.可将各同事对象解耦。中介者有利于各同事之间的松耦合，我们可以独立的改变和复用每一个同事和中介者，增加新的中介者和新的同事类都比较方便，更好的符合“开闭原则”。 3.可以减少子类生成，中介者将原本分布于多个对象间的行为集中在一起，改变这些行为只需生成新的中介者子类即可，这使得各个同事类可被重用，无须对同事类进行扩展。 缺点：在具体中介者类中包含了大量同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。 最佳实践： 1.系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。 2.一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。 3.想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的具体中介者类。 举例：同事类相互影响 1.创建同事类抽象类 public abstract class Colleague { protected int number; public int getNumber() { return number; } public void setNumber(int number){ this.number = number; } public abstract void setNumber(int number, Mediator mediator); } 2.创建同事类实现类 public class ColleagueA extends Colleague{ @Override public void setNumber(int number, Mediator mediator) { this.number = number; mediator.A2B(); } } public class ColleagueB extends Colleague{ @Override public void setNumber(int number, Mediator mediator) { this.number = number; mediator.B2A(); } } 3.创建中介者抽象类 public abstract class Mediator { protected Colleague ca; protected Colleague cb; public Mediator(Colleague a, Colleague b) { this.ca = a; this.cb = b; } public abstract void A2B(); public abstract void B2A(); } 4.创建中介者实现类 public class MediatorImpl extends Mediator { public MediatorImpl(Colleague a, Colleague b) { super(a, b); } @Override public void A2B() { int number = ca.getNumber(); cb.setNumber(number*100); } @Override public void B2A() { int number = cb.getNumber(); ca.setNumber(number/100); } } 5.测试 public class MpTest { public static void main(String[] args) { ColleagueA colleagueA = new ColleagueA(); ColleagueB colleagueB = new ColleagueB(); Mediator mediator = new MediatorImpl(colleagueA,colleagueB); System.out.println("++++++++++++通过设置A影响B++++++++++++"); colleagueA.setNumber(1000,mediator); System.out.println("A的值为："+colleagueA.getNumber()); System.out.println("B的值为A的10倍："+colleagueB.getNumber()); System.out.println("++++++++++++通过设置B影响A++++++++++++"); colleagueB.setNumber(2000,mediator); System.out.println("B的值为："+colleagueB.getNumber()); System.out.println("A的值为B的0.1倍："+colleagueA.getNumber()); } } 6.输出 ++++++++++++通过设置A影响B++++++++++++ A的值为：1000 B的值为A的10倍：100000 ++++++++++++通过设置B影响A++++++++++++ B的值为：2000 A的值为B的0.1倍：20 3.9. 职责链模式（CRP）英文：Chain of Responsibility Pattern 定义：责任链模式是为了避免请求的发送者和接收者之间的耦合关系，使多个接收对象都有机会处理请求。将这些对象练成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 职责链分类 定义 纯的职责链模式 纯的职责链模式要求一个具体的处理者对象只能在两个行为中选择一个：一个是承担责任；二是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又把责任向下传的情况。在一个纯的职责链中，一个请求必须被某一个处理者对象所接受。 不纯的职责链模式 不纯的职责链模式中允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收。 优点： 1.请求不需要指出被哪个对象处理了，这样的效果是请求者和接收者之间的解耦，而且链中的对象也不需要清楚其他链的结构，也降低了耦合。 2.请求处理对象仅需要维护一个指向其后继者的的引用，而不需要维护所有的处理对象，简化了对象之间的相互连接。 3.在给对象分派职责时，职责链可以给我们更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责。 4.新增一个请求处理对象，不需要改动现有代码，只需要重新设置连接即可，符合“开闭原则”。 缺点： 1.如果一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理。 2.对于比较长的职责链，请求的处理可能涉及到多个处理对象，不仅增加了代码的复杂性并且系统性能也将受到一定影响，而且在进行代码调试时不太方便。 3.若建链不当，可能会造成循环调用，将导致系统陷入死循环。 最佳实践： 1.有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的。 2.在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3.可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。其实在我们日常开发中也会有适用到责任链模式的场景，try/catch、servlet(各个servelt互相调用)、以及filter等 举例：请假审批 1.创建请假对象 public class Leave { //姓名 private String name; //部门 private String department; //天数 private Double day; //原因 private String cause; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDepartment() { return department; } public void setDepartment(String department) { this.department = department; } public Double getDay() { return day; } public void setDay(Double day) { this.day = day; } public String getCause() { return cause; } public void setCause(String cause) { this.cause = cause; } @Override public String toString() { return "Leave{" + "name='" + name + '\'' + ", department='" + department + '\'' + ", day=" + day + ", cause='" + cause + '\'' + '}'; } } 2.创建审批者抽象类 public abstract class Approver { //审核人名 public String name; //下一个审核人 public Approver nextApprove; public Approver(String name) { this.name = name; } //设置下一个审核人 public void setNextApprove(Approver nextApprove) { this.nextApprove = nextApprove; } //审核 public abstract void approval(Leave leave); } 3.创建审批者实现类 public class Manager extends Approver { public Manager(String name) { super(name); } @Override public void approval(Leave leave) { if(leave.getDay() &lt; 5){ System.out.println(name+"权限范围内,批准了"); System.out.println("结束审批"); }else{ if(Objects.nonNull(nextApprove)){ System.out.println(name+"权限范围外,移交上一级领导"); this.nextApprove.approval(leave); }else{ System.out.println("领导不在,审批质押"); } } } } public class Boss extends Approver { public Boss(String name) { super(name); } @Override public void approval(Leave leave) { if (leave.getDay() > 5 &amp;&amp; leave.getDay() &lt; 10) { System.out.println(name+"：未超预期,批准"); System.out.println("结束审批"); } else { System.out.println(name+"时间太长了,影响公司挣钱,驳回"); System.out.println("结束审批"); } } } 4.测试 public class CrpTest { public static void main(String[] args) { Leave leave = new Leave(); leave.setName("小王"); leave.setDepartment("研发部"); leave.setDay(8.0D); leave.setCause("结婚"); Manager manager = new Manager("李经理"); Boss boss = new Boss("钱总"); manager.setNextApprove(boss); System.out.println("请假发起者："+leave.toString()); manager.approval(leave); } } 5.输出 请假发起者：Leave{name='小王', department='研发部', day=8.0, cause='结婚'} 李经理权限范围外,移交上一级领导 钱总：未超预期,批准 结束审批 3.10. 访问者模式（VP）英文：Visitor Pattern 定义：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。 优点： 1.符合单一职责原则 2.优秀的扩展性 3.灵活性 缺点： 1.具体元素对访问者公布细节，违反了迪米特原则 2.具体元素变更比较困难 3.违反了依赖倒置原则，依赖了具体类，没有依赖抽象。 最佳实践： 1.对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2.需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。 注意事项：访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。 举例： 场景： CEO和CTO开始评定员工一年的工作绩效，员工分为工程师和经理，CTO关注工程师的代码量、经理的新产品数量；CEO关注的是工程师的KPI和经理的KPI以及新产品数量。由于CEO和CTO对于不同员工的关注点是不一样的，这就需要对不同员工类型进行不同的处理。访问者模式此时可以派上用场了。 1.创建抽象员工类 public abstract class Staff { //员工姓名 public String name; //员工KPI public Integer kpi; public Staff(String name) { this.name = name; this.kpi = new Random().nextInt(10); } //接受visitor访问 public abstract void accept(Visitor visitor); } 2.创建员工实现类 public class Engineer extends Staff { public Engineer(String name) { super(name); } @Override public void accept(Visitor visitor) { visitor.visit(this); } public int getCodeLines(){ return new Random().nextInt(100000); } } public class Manager extends Staff { public Manager(String name) { super(name); } @Override public void accept(Visitor visitor) { visitor.visit(this); } public int getProductNum(){ return new Random().nextInt(10); } } 3.创建观接口 public interface Visitor { // 访问工程师类型 void visit(Engineer engineer); // 访问经理类型 void visit(Manager manager); } 4.创建观察者接口实现类 public class CEO implements Visitor { private String name; public CEO(String name) { this.name = name; } @Override public void visit(Engineer engineer) { System.out.println(name+"查看:"+engineer.name+"的KPI："+engineer.kpi); } @Override public void visit(Manager manager) { System.out.println(name+"查看:"+manager.name+"的KPI："+manager.kpi); } } public class CTO implements Visitor { private String name; public CTO(String name) { this.name = name; } @Override public void visit(Engineer engineer) { System.out.println(name+"查看:"+engineer.name+"的代码数："+engineer.getCodeLines()); } @Override public void visit(Manager manager) { System.out.println(name+"查看:"+manager.name+"的产品数："+manager.getProductNum()); } } 5.创建报表类 public class ExcelReport { private List&lt;Staff> staffs = new ArrayList&lt;>(); public ExcelReport(){ staffs.add(new Manager("李经理")); staffs.add(new Manager("张经理")); staffs.add(new Engineer("小王")); staffs.add(new Engineer("小李")); } public void showReport(Visitor visitor){ for (Staff staff : staffs) { staff.accept(visitor); } } } 6.测试 public class VpTest { public static void main(String[] args) { ExcelReport excelReport = new ExcelReport(); excelReport.showReport(new CEO("吴董")); excelReport.showReport(new CTO("程总")); } } 7.输出 吴董查看:李经理的KPI：3 吴董查看:张经理的KPI：7 吴董查看:小王的KPI：5 吴董查看:小李的KPI：8 程总查看:李经理的产品数：1 程总查看:张经理的产品数：3 程总查看:小王的代码数：55701 程总查看:小李的代码数：31420 3.11. 状态模式（SP）英文：State Pattern 定义：允许一个对象在其状态改变时，改变它的行为，对象看起来似乎修改了它的类。 优点： 1.封装了状态的转换规则，在状态模式中可以将状态转换的工作封装在环境类或具体的状态类中，可以对状态转换码进行集中管理，而不是分散在一个个的业务中。 2.将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为。 3.允许状态转换逻辑与状态对象合为一体，而不是提供一个巨大的条件语句块，状态模式可以让我们避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起。 缺点： 1.状态模式的使用必然会增加系统中类和对象的个数，导致系统运行开销增大。 2.状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，增加系统设计的难度。 最佳实践： 1.对象的行为依赖于它的状态（如某些属性值），状态的改变将导致行为的变化。 2.在代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，并且导致客户类与类库之间的耦合增强。 举例：请假审核 1.创建请假对象 public class LeaveApply { //申请单初始状态是待提交状态 private ApplyState applyState = new Audit(); //设置状态 public void setState(ApplyState state){ applyState = state; } //状态变化后,更新对象自身的行为 public void getResult(){ applyState.changeHandle(); } } 2.创建审核状态接口 public interface ApplyState { //状态变化处理操作 void changeHandle(); } 3.创建各审核状态具体实现类 public class Audit implements ApplyState { @Override public void changeHandle() { System.out.println("[审核中]"); } } public class AuditPass implements ApplyState { @Override public void changeHandle() { System.out.println("[审核通过]"); } } public class AuditReject implements ApplyState{ @Override public void changeHandle() { System.out.println("[审核未通过]"); } } 4.测试 public class SpTest { public static void main(String[] args) { LeaveApply leaveApply = new LeaveApply(); leaveApply.getResult(); leaveApply.setState(new AuditPass()); leaveApply.getResult(); leaveApply.setState(new AuditReject()); leaveApply.getResult(); } } 5.输出 [审核中] [审核通过] [审核未通过] document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统优化小记：CPU长时间满负荷运行]]></title>
    <url>%2F2020%2F11%2F28%2Fsystem-optimize%2F</url>
    <content type="text"><![CDATA[CPU长时间满负荷运行,一次入门级降CPU系统优化实战 现象用户量增大,线上一个Java单应用服务长时间占用服务器CPU达到400%，使得接口响应速度非常慢，线程拥堵，出现各种响应超时问题，即便有时候没有用户操作，也会长时间占用大量CPU和内存。 解决思路找出哪些程序处理满，进行排查优化（业务流程调整、锁关闭、SQL优化、一些耗性能的程序不使用内存方案） 解决方案linux命令排查 + Arthas监控 + Druid sql 监控 解决方案：一、Linux命令排查，方法如下：1.显示进程列表，定位进程号在top命令下，按shift+H查看cpu占用最高进程(PID:21659) 2.显示线程列表，定位线程号，找到哪些线程占用高耗时长命令：ps -mp pid -o THREAD,tid,time | sort -rn | more ex：ps -mp 21659 -o THREAD,tid,time （shift+H） ps：截图中pid写成24275原因是由于中途重启过一次程序，原PID：21659 变更成 PID：24275，实则都是同一个Java程序 其中TID：24737、24742、24745，耗时较长占用CPU率较高 3.将线程号转为系统可识别的16进制命令：printf "%x\n" tid 4.打印线程的堆栈信息，分析原因命令： jstack PID | grep [16进制TID] -A 30 ex：查看线程24737的堆栈信息， jstack 24275 | grep 60a1 -A 30 5.如果嫌以上操作麻烦，也可直接使用 jstack PID，打印出所有堆栈，进行查看。二、辅助神器Arthas程序监控本次不在说明，后出专题讲解，附上官方文档： Arthas传送门 三、辅助Druid SQL监控本次也不在说明，后出专题讲解，附一张图 最终问题定位在堆内存占满，新创建对象时无法分配足够的内存，引起频繁GC 1.程序频繁请求RPC接口得到的响应慢，耗时过大； 解决方案：由于获取的数据实时性要求不高，改为缓存处理，避免实时请求。 2.客户端频繁请求某个接口，且接口中的sql效率非常低,导致了sql连接长时间被占用。 解决方案：由于该接口历史遗留，且和对应的调用客户端同事确认该接口现今已用处不大，因此注释掉了该接口。 3.频繁收到回调，随开启了多线程处理但由于有线程锁，使得其他线程被block，实则依然是个单线程处理，消费速度赶不上生产速度，线程积压。 解决方案：确保安全的情况下，关闭了线程锁。 4.代码逻辑不合理; 解决方案：重新调整代码逻辑 5.对数据库操作过于频繁; 解决方案：调整逻辑，优化sql（调整sql，加索引，避免全表扫描），尽量少操作数据库，多使用缓存对数据进行操作 总结经过此次排查，虽最终问题得以缓解，但深知系统内依然存在很多其他性能问题，暴露出对JVM知识的欠缺，以及Java代码、SQL功底需要持续加强。保证程序系统的稳定，健壮，高效。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>后端</tag>
        <tag>系统优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker,轻量级的虚拟化技术]]></title>
    <url>%2F2020%2F10%2F23%2Fdocker%2F</url>
    <content type="text"><![CDATA[Docker 一个利用了lxc的技术的一个虚拟化引擎。 Docker简介什么是虚拟化​ 在计算机中，虚拟化（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。这些资源的新虚拟部份是不受现有资源的架设方式，地域或物理组态所限制。一般所指的虚拟化资源包括计算能力和资料存储。 ​ 在实际的生产环境中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件 对资源充分利用 ​ 虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机等等。 什么是Docker​ Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。 ​ ​ Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。 ​ Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。 ​ 在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。 为什么选择Docker? （1）上手快。 ​ 用户只需要几分钟，就可以把自己的程序“Docker化”。Docker依赖于“写时复制”（copy-on-write）模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改”的境界。 随后，就可以创建容器来运行应用程序了。大多数Docker容器只需要不到1秒中即可启动。由于去除了管理程序的开销，Docker容器拥有很高的性能，同时同一台宿主机中也可以运行更多的容器，使用户尽可能的充分利用系统资源。 （2）职责的逻辑分类 ​ 使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。Docker设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题（测试环境都是正常的，上线后出了问题就归结为肯定是运维的问题）” （3）快速高效的开发生命周期 ​ Docker的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。（通俗一点说，Docker就像一个盒子，里面可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件件的取。） （4）鼓励使用面向服务的架构 ​ Docker还鼓励面向服务的体系结构和微服务架构。Docker推荐单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单，同时也提高了程序的内省性。（当然，可以在一个容器中运行多个应用程序） 1.3 容器与虚拟机比较​ 下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。 与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。 Docker 组件Docker服务器与客户端​ Docker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。 Docker镜像与容器​ 镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。例如： 添加一个文件； 执行一个命令； 打开一个窗口。 也可以将镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新。 ​ Docker可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容器即可。容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。 容器基于镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务。 所以Docker容器就是： ​ 一个镜像格式； ​ 一些列标准操作； ​ 一个执行环境。 ​ Docker借鉴了标准集装箱的概念。标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。 和集装箱一样，Docker在执行上述操作时，并不关心容器中到底装了什么，它不管是web服务器，还是数据库，或者是应用程序服务器什么的。所有的容器都按照相同的方式将内容“装载”进去。 Docker也不关心你要把容器运到何方：我们可以在自己的笔记本中构建容器，上传到Registry，然后下载到一个物理的或者虚拟的服务器来测试，在把容器部署到具体的主机中。像标准集装箱一样，Docker容器方便替换，可以叠加，易于分发，并且尽量通用。 Registry（注册中心）​ Docker用Registry来保存用户构建的镜像。Registry分为公共和私有两种。Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像（说明：在Docker Hub下载镜像巨慢，可以自己构建私有的Registry）。 ​ https://hub.docker.com/ Docker安装与启动安装Docker​ Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。 ​ 由于我们学习的环境都使用的是CentOS，因此这里我们将Docker安装到CentOS上。注意：这里建议安装在CentOS7.x以上的版本，在CentOS6.x的版本中，安装前需要安装其他很多的环境而且Docker很多补丁不支持更新。 ​ 请直接挂载课程配套的Centos7.x镜像 （1）yum 包更新到最新 sudo yum update （2）安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 sudo yum install -y yum-utils device-mapper-persistent-data lvm2 （3）设置yum源为阿里云 sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo （4）安装docker sudo yum install docker-ce （5）安装后查看docker版本 docker -v 设置ustc的镜像ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。 https://lug.ustc.edu.cn/wiki/mirrors/help/docker 编辑该文件： vi /etc/docker/daemon.json 在该文件中输入如下内容： { "registry-mirrors": ["https://docker.mirrors.ustc.edu.cn"] } Docker的启动与停止systemctl命令是系统服务管理器指令 启动docker： systemctl start docker 停止docker： systemctl stop docker 重启docker： systemctl restart docker 查看docker状态： systemctl status docker 开机启动： systemctl enable docker 查看docker概要信息 docker info 查看docker帮助文档 docker --help 常用命令镜像相关命令查看镜像docker images REPOSITORY：镜像名称 TAG：镜像标签 IMAGE ID：镜像ID CREATED：镜像的创建日期（不是获取该镜像的日期） SIZE：镜像大小 这些镜像都是存储在Docker宿主机的/var/lib/docker目录下 搜索镜像如果你需要从网络中查找需要的镜像，可以通过以下命令搜索 docker search 镜像名称 NAME：仓库名称 DESCRIPTION：镜像描述 STARS：用户评价，反应一个镜像的受欢迎程度 OFFICIAL：是否官方 AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的 拉取镜像拉取镜像就是从中央仓库中下载镜像到本地 docker pull 镜像名称 例如，我要下载centos7镜像 docker pull centos:7 删除镜像按镜像ID删除镜像 docker rmi 镜像ID 删除所有镜像 docker rmi `docker images -q` 容器相关命令查看容器查看正在运行的容器 docker ps 查看所有容器 docker ps –a 查看最后一次运行的容器 docker ps –l 查看停止的容器 docker ps -f status=exited 创建与启动容器创建容器常用的参数说明： 创建容器命令：docker run -i：表示运行容器 -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。 –name :为创建的容器命名。 -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。 -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。 -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射 （1）交互式方式创建容器 docker run -it --name=容器名称 镜像名称:标签 /bin/bash 这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态 退出当前容器 exit （2）守护式方式创建容器： docker run -di --name=容器名称 镜像名称:标签 登录守护式容器方式： docker exec -it 容器名称 (或者容器ID) /bin/bash 停止与启动容器停止容器： docker stop 容器名称（或者容器ID） 启动容器： docker start 容器名称（或者容器ID） 文件拷贝如果我们需要将文件拷贝到容器内可以使用cp命令 docker cp 需要拷贝的文件或目录 容器名称:容器目录 也可以将文件从容器内拷贝出来 docker cp 容器名称:容器目录 需要拷贝的文件或目录 目录挂载我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。创建容器 添加-v参数 后边为 宿主机目录:容器目录，例如： docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos3 centos:7 如果你共享的是多级的目录，可能会出现权限不足的提示。 这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数 –privileged=true 来解决挂载的目录没有权限的问题 查看容器IP地址我们可以通过以下命令查看容器运行的各种数据 docker inspect 容器名称（容器ID） 也可以直接执行下面的命令直接输出IP地址 docker inspect --format='{{.NetworkSettings.IPAddress}}' 容器名称（容器ID） 删除容器删除指定的容器： docker rm 容器名称（容器ID） 应用部署MySQL部署（1）拉取mysql镜像 docker pull centos/mysql-57-centos7 （2）创建容器 docker run -di --name=tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql -p 代表端口映射，格式为 宿主机映射端口:容器运行端口 -e 代表添加环境变量 MYSQL_ROOT_PASSWORD 是root用户的登陆密码 （3）远程登录mysql 连接宿主机的IP ,指定端口为33306 tomcat部署（1）拉取镜像 docker pull tomcat:7-jre7 （2）创建容器 创建容器 -p表示地址映射 docker run -di --name=mytomcat -p 9000:8080 -v /usr/local/webapps:/usr/local/tomcat/webapps tomcat:7-jre7 Nginx部署（1）拉取镜像 docker pull nginx （2）创建Nginx容器 docker run -di --name=mynginx -p 80:80 nginx Redis部署（1）拉取镜像 docker pull redis （2）创建容器 docker run -di --name=myredis -p 6379:6379 redis 迁移与备份容器保存为镜像我们可以通过以下命令将容器保存为镜像 docker commit mynginx mynginx_i 镜像备份我们可以通过以下命令将镜像保存为tar 文件 docker save -o mynginx.tar mynginx_i 镜像恢复与迁移首先我们先删除掉mynginx_img镜像 然后执行此命令进行恢复 docker load -i mynginx.tar -i 输入的文件 执行后再次查看镜像，可以看到镜像已经恢复 Dockerfile Dockerfile文件详解 什么是DockerfileDockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。 对于开发人员：可以为开发团队提供一个完全一致的开发环境； 对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了； 对于运维人员：在部署时，可以实现应用的无缝移植。 常用命令 命令 作用 FROM image_name:tag 定义了使用哪个基础镜像启动构建流程 MAINTAINER user_name 声明镜像的创建者 ENV key value 设置环境变量 (可以写多条) RUN command 是Dockerfile的核心部分(可以写多条) ADD source_dir/file dest_dir/file 将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压 COPY source_dir/file dest_dir/file 和ADD相似，但是如果有压缩文件并不能解压 WORKDIR path_dir 设置工作目录 使用脚本创建镜像步骤： （1）创建目录 mkdir –p /usr/local/dockerjdk8 （2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/dockerjdk8目录 （3）创建文件Dockerfile vi Dockerfile #依赖镜像名称和ID FROM centos:7 #指定镜像创建者信息 MAINTAINER ITCAST #切换工作目录 WORKDIR /usr RUN mkdir /usr/local/java #ADD 是相对路径jar,把java添加到容器中 ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/ #配置java环境变量 ENV JAVA_HOME /usr/local/java/jdk1.8.0_171 ENV JRE_HOME $JAVA_HOME/jre ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH ENV PATH $JAVA_HOME/bin:$PATH （4）执行命令构建镜像 docker build -t='jdk1.8' . 注意后边的空格和点，不要省略 （5）查看镜像是否建立完成 docker images Docker私有仓库私有仓库搭建与配置（1）拉取私有仓库镜像（此步省略） docker pull registry （2）启动私有仓库容器 docker run -di --name=registry -p 5000:5000 registry （3）打开浏览器 输入地址http://192.168.184.141:5000/v2/_catalog看到`{"repositories":[]}` 表示私有仓库搭建成功并且内容为空 （4）修改daemon.json vi /etc/docker/daemon.json 添加以下内容，保存退出。 {"insecure-registries":["192.168.184.141:5000"]} 此步用于让 docker信任私有仓库地址 （5）重启docker 服务 systemctl restart docker 镜像上传至私有仓库（1）标记此镜像为私有仓库的镜像 docker tag jdk1.8 192.168.184.141:5000/jdk1.8 （2）再次启动私服容器 docker start registry （3）上传标记的镜像 docker push 192.168.184.141:5000/jdk1.8 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>运维</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Installs]]></title>
    <url>%2F2020%2F10%2F23%2Fdocker-installs%2F</url>
    <content type="text"><![CDATA[docker 安装软件工具 准备工作docker准备工作传送门 命令快捷 查看镜像# docker images | grep ? 启动容器# docker run -id --name=matrix_mysql -p 13306:3306 -e MYSQL_ROOT_PASSWORD=abc123 mysql 进入容器# docker exec -it 容器名/容器Id /bin/bash 安装Nexus3查询镜像# docker search nexus 拉取镜像# docker pull sonatype/nexus3 配置本地保存数据的路径 路径可自定义,我放在/docker/nexus/nexus-data下。 注意：在生成目录的时候，因为nexus的读写默认是200,docker run的时候会报找不到路径的错误 可能遇到的问题:找不到路径错误 修改目录权限# chmod 777 docker # chmod 777 nexus # chmod 777 nexus-data 运行镜像# docker run -d -p 8081:8081 -p 8082:8082 -p 8083:8083 --name matrix_nexus3 -v /usr/etc/docker/nexus/nexus-data:/nexus-data sonatype/nexus3 8082 客户端页面的对外端口; 8082 准备建立docker hosted 私有库使用。hosted可以上传下载我建立的images; 8083 准备建立docker proxy 代理库使用。 proxy可以镜像远程公共仓库，比如：docke官方仓库、aliyun等等; daemon.json 在/etc/docker/daemon.json这个文件夹中配置; daemon.json文件中的配置说明： { "registry-mirrors": ["https://1v50e4uy.mirror.aliyuncs.com"], ----文件加速地址，下载国外的镜像，通过它进行加速 "insecure-registries":["192.168.111.112:8083"] ---配置本地的镜像库地址,每次拖取镜像,如果8083上没有，先从远程库下载，下载到8083，再下载到本地库，下次再下载的时候，就从8083上下载了。 } 登录 Nexus31.登录链接：http://192.168.111.112:8081/ 2.默认用户名:admin 默认密码不再是admin123,所以需要去容器内查看 3.查看默认密码：进入容器内查看 # docker exec -it matrix_nexus3 /bin/bash # cd nexus-data/ # vi admin.password ---复制出密码,去网页登录 4.登录完成后,默认提示修改新密码,新密码改完后,admin.password将会消失,所以要保管好密码 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>运维</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo操作手册]]></title>
    <url>%2F2020%2F10%2F23%2Fhexo-manual%2F</url>
    <content type="text"><![CDATA[A fast, simple &amp; powerful blog framework 官方网站：https://hexo.io/zh-cn/docs/configuration 常用命令清除缓存文件 (db.json) 和已生成的静态文件 (public) $ hexo clean 生成静态文件 $ hexo generate -d, --deploy 文件生成后立即部署网站 -w, --watch 监视文件变动 部署 hexo d 启动服务器。默认情况下,访问网址为: http://localhost:4000/ $ hexo server -p, --port 重设端口 -s, --static 只使用静态文件 -l, --log 启动日记记录，使用覆盖记录格式 发表草稿 $ hexo publish [layout] &lt;filename&gt; 显示草稿 $ hexo --draft 自定义 CWD（Current working directory） $ hexo --cwd /path/to/cwd 创建文档 hexo new [layout] &lt;title&gt; ex: hexo new inner demo01 hexo new outer demo01 hexo new feeling demo01 draft--&gt;public hexo publish [layout] &lt;title&gt; ex: hexo new draft demo01 hexo publish inner &lt;title&gt; 页眉说明title: Hexo操作手册 //标题 author: 571 //作者 series: INNER //所属系列 categories: INNER //所属类别 comments: true //是否开启评论： true 开启 img: /cover/abc.jpg //封面图 top: false //是否置顶 true 是 cover: false //是否轮播 true 是 tags: //标签 - inner - 手册 date: 2020-05-14 21:58:38 //创建时间 updated: 2020-05-14 21:58:38 //修改时间 创建文章文件创建文件命名格式：小写、中杠隔开单词 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>手册</category>
      </categories>
      <tags>
        <tag>手册</tag>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux Installs]]></title>
    <url>%2F2020%2F10%2F23%2Flinux-installs%2F</url>
    <content type="text"><![CDATA[Linux 软件工具安装 安装Java通过yum方式安装Java查看JDK是否已安装# yum list installed | grep java 若已经安装了JDK，如何卸载Java环境？ 卸载JDK相关文件：# yum -y remove java-1.7.0-openjdk* 卸载tzdata-java：# yum -y remove tzdata-java.noarch 注：“*”表示卸载掉java 1.7.0的所有openjdk相关文件查看yum库中的Java安装包# yum -y list java* 安装Java安装包 以yum库中java-1.8.0为例： # yum -y install java-1.8.0-openjdk* 注：“*”表示将java-1.8.0的所有相关Java程序都安装上 查看刚刚安装版本# java -version 环境变量配置1.修改配置文件 # vim /etc/profile # export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk # export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar # export PATH=$PATH:$JAVA_HOME/bin 2.生效修改 # source /etc/profile 通过压缩包安装Java####准备工作： jdk-8u11-linux-x64.tar.gz下载地址：https://pan.baidu.com/s/1smNHABN (ps：也可在官网下载最新jdk:http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) shell在windows下载完成jdk后，通过shell发送到Linux上 登录Linux，切换到root用户# su root ---获取root用户权限，当前工作目录不变(需要root密码) 或者 # sudo -i ---不需要root密码直接切换成root（需要当前用户密码） 在usr目录下建立Java安装目录# cd /usr/local/src/ # mkdir java 解压jdk到当前目录,得到文件夹 jdk1.8.0_11# tar -zxvf jdk-8u11-linux-x64.tar.gz 解压完建立一个链接以节省目录长度# ln -s /usr/local/src/java/jdk1.8.0_11/ /usr/local/src/jdk 编辑配置文件，配置环境变量# vim /etc/profile 在文末添加如下内容： # JAVA_HOME=/usr/local/src/jdk # CLASSPATH=$JAVA_HOME/lib/ # PATH=$PATH:$JAVA_HOME/bin # export PATH JAVA_HOME CLASSPATH 重启机器或执行命令# sudo shutdown -r now 查看刚刚安装版本# java -version 安装Maven在线下载安装安装wget命令# yum -y install wget 下载maven安装包# cd /usr/local/src/ # wget http://mirrors.cnnic.cn/apache/maven/maven-3/3.5.4/binaries/apache-maven-3.5.4-bin.tar.gz 解压maven安装包# tar -zxvf apache-maven-3.5.4-bin.tar.gz 配置maven# vi /etc/profile 在配置文件配置 # export MAVEN_HOME=/usr/local/src/apache-maven-3.5.4 # export PATH=$MAVEN_HOME/bin:$PATH 配置文件生效 # source /etc/profile 查看maven# mvn -version 安装包安装 Maven下载地址 安装Nexus3准备工作 安装Java 安装Maven 在线下载安装在线下载安装传送门 安装包安装 Nexus下载地址1Nexus下载地址2 docker安装源码下载不动,无耐想到此法,推荐 Docker安装传送门 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>后端</tag>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
