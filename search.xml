<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Docker Installs]]></title>
    <url>%2F2019%2F10%2F29%2Fdocker-installs%2F</url>
    <content type="text"><![CDATA[docker 安装软件工具 准备工作docker准备工作传送门 命令快捷 查看镜像# docker images | grep ? 启动容器# docker run -id --name=matrix_mysql -p 13306:3306 -e MYSQL_ROOT_PASSWORD=abc123 mysql 进入容器# docker exec -it 容器名/容器Id /bin/bash 安装Nexus3查询镜像# docker search nexus 拉取镜像# docker pull sonatype/nexus3 配置本地保存数据的路径 路径可自定义,我放在/docker/nexus/nexus-data下。 注意：在生成目录的时候，因为nexus的读写默认是200,docker run的时候会报找不到路径的错误 可能遇到的问题:找不到路径错误 修改目录权限# chmod 777 docker # chmod 777 nexus # chmod 777 nexus-data 运行镜像# docker run -d -p 8081:8081 -p 8082:8082 -p 8083:8083 --name matrix_nexus3 -v /usr/etc/docker/nexus/nexus-data:/nexus-data sonatype/nexus3 8082 客户端页面的对外端口; 8082 准备建立docker hosted 私有库使用。hosted可以上传下载我建立的images; 8083 准备建立docker proxy 代理库使用。 proxy可以镜像远程公共仓库，比如：docke官方仓库、aliyun等等; daemon.json 在/etc/docker/daemon.json这个文件夹中配置; daemon.json文件中的配置说明： { "registry-mirrors": ["https://1v50e4uy.mirror.aliyuncs.com"], ----文件加速地址，下载国外的镜像，通过它进行加速 "insecure-registries":["192.168.111.112:8083"] ---配置本地的镜像库地址,每次拖取镜像,如果8083上没有，先从远程库下载，下载到8083，再下载到本地库，下次再下载的时候，就从8083上下载了。 } 登录 Nexus31.登录链接：http://192.168.111.112:8081/ 2.默认用户名:admin 默认密码不再是admin123,所以需要去容器内查看 3.查看默认密码：进入容器内查看 # docker exec -it matrix_nexus3 /bin/bash # cd nexus-data/ # vi admin.password ---复制出密码,去网页登录 4.登录完成后,默认提示修改新密码,新密码改完后,admin.password将会消失,所以要保管好密码 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Ops</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>Ops</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux Installs]]></title>
    <url>%2F2019%2F10%2F29%2Flinux-installs%2F</url>
    <content type="text"><![CDATA[Linux 软件工具安装 安装Java通过yum方式安装Java查看JDK是否已安装# yum list installed | grep java 若已经安装了JDK，如何卸载Java环境？ 卸载JDK相关文件：# yum -y remove java-1.7.0-openjdk* 卸载tzdata-java：# yum -y remove tzdata-java.noarch 注：“*”表示卸载掉java 1.7.0的所有openjdk相关文件查看yum库中的Java安装包# yum -y list java* 安装Java安装包 以yum库中java-1.8.0为例： # yum -y install java-1.8.0-openjdk* 注：“*”表示将java-1.8.0的所有相关Java程序都安装上 查看刚刚安装版本# java -version 环境变量配置1.修改配置文件 # vim /etc/profile # export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk # export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar # export PATH=$PATH:$JAVA_HOME/bin 2.生效修改 # source /etc/profile 通过压缩包安装Java####准备工作： jdk-8u11-linux-x64.tar.gz下载地址：https://pan.baidu.com/s/1smNHABN (ps：也可在官网下载最新jdk:http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) shell在windows下载完成jdk后，通过shell发送到Linux上 登录Linux，切换到root用户# su root ---获取root用户权限，当前工作目录不变(需要root密码) 或者 # sudo -i ---不需要root密码直接切换成root（需要当前用户密码） 在usr目录下建立Java安装目录# cd /usr/local/src/ # mkdir java 解压jdk到当前目录,得到文件夹 jdk1.8.0_11# tar -zxvf jdk-8u11-linux-x64.tar.gz 解压完建立一个链接以节省目录长度# ln -s /usr/local/src/java/jdk1.8.0_11/ /usr/local/src/jdk 编辑配置文件，配置环境变量# vim /etc/profile 在文末添加如下内容： # JAVA_HOME=/usr/local/src/jdk # CLASSPATH=$JAVA_HOME/lib/ # PATH=$PATH:$JAVA_HOME/bin # export PATH JAVA_HOME CLASSPATH 重启机器或执行命令# sudo shutdown -r now 查看刚刚安装版本# java -version 安装Maven在线下载安装安装wget命令# yum -y install wget 下载maven安装包# cd /usr/local/src/ # wget http://mirrors.cnnic.cn/apache/maven/maven-3/3.5.4/binaries/apache-maven-3.5.4-bin.tar.gz 解压maven安装包# tar -zxvf apache-maven-3.5.4-bin.tar.gz 配置maven# vi /etc/profile 在配置文件配置 # export MAVEN_HOME=/usr/local/src/apache-maven-3.5.4 # export PATH=$MAVEN_HOME/bin:$PATH 配置文件生效 # source /etc/profile 查看maven# mvn -version 安装包安装 Maven下载地址 安装Nexus3准备工作 安装Java 安装Maven 在线下载安装在线下载安装传送门 安装包安装 Nexus下载地址1Nexus下载地址2 docker安装源码下载不动,无耐想到此法,推荐 Docker安装传送门 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Ops</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>Ops</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《如何阅读一本书》]]></title>
    <url>%2F2019%2F10%2F22%2Fhow-to-read-a-book%2F</url>
    <content type="text"><![CDATA[我是一个不会读书的人，所以需要一份读书指南，指明方向，少走弯路。 《如何阅读一本书》 仅供参考,请支持正版! 传送门 留白 整体来说，这本书到底在谈些什么？ 这本书谈了什么：1.阅读的好处 2.阅读的技巧 书中的细节，作者是怎么谈的？ 细节怎么样： 这本书说的有道理吗？是全部的都有道理还是部分有道理？ 是否有道理：暂无评论资格，实践出真知 这本书跟你自己有什么关系? 跟我们有什么关系：指明方向，少走弯路 脑图 阅读的好处 人的心智，或者说思考能力，和肌肉一样，如果不经常运用就会萎缩，而读书，正是防止心智萎缩、延缓心智衰老的最有效手段。 老生常谈，不做累述。 阅读的技巧 “读得太快或太慢，都一无所获。” ———[法]帕斯卡尔 书的分类书或者说阅读品，可以分为两类： 读得懂的东西，就是报纸、杂志等一些我们一下子就能消化的，属于资讯，却不能够增加我们的理解力，如果你够敏感的话呢，就会发现读多了这样的东西，并没什么营养。 必须读的东西，就是指一个人要试着去读他并不怎么了解的东西，也就是略高于他的读物。“如何阅读一本书”，主要指的是必须读的东西。 一个好的读者 应该更多地去读那些锻炼他的心智的书 必须主动，主动的读者会从阅读中获得更大的收益 技巧牢记四个问题 整体来说，这本书到底在谈些什么？ 书中的细节，作者是怎么谈的？ 这本书说的有道理吗？是全部的都有道理还是部分有道理？ 这本书跟你自己有什么关系? 四个问题对应四种层次由低到高：基础阅读、检视阅读、分析阅读、主题阅读 第一层 基础阅读所谓基础阅读，也就是初级阅读，只要不是文盲，能看懂字面意思，就可以完成，这个不用多说。 第二层 检视阅读简单来说或就是阅读理解，快速浏览。它也分两个阶段： 第一阶段，学会有系统地略读具体的建议顺序是：先看书名、序言和副标题，接着研究目录和索引，然后看看作者简介，再翻开看一下和书名主题相关的篇章，开始读。这个技巧的难点是，需要你有背景知识。不过你书读得越多，就越容易。 第二阶段，叫做快速通读就是说一本书不管你能不能看懂，都从头到尾翻一遍。用这个方法读完一本书之后，无论你用了多短的时间，你都能够对这本书的类别、题材、内容，有一个初步的了解。 第三层 分析阅读比较复杂也是最系统化的层次，分析阅读，主要分为三个阶段： 第一阶段，了解范围 这本书在谈什么？你需要确定主题和书的分类，比如是文学还是历史或者经济学？然后要用一小段内容叙述整本书的内容，把重点的章节列出来，找出作者要在书里讨论的问题是什么？其实，这个阶段也不复杂，你只需要做到一点，不要拿起一本书就闷头读，先搞清楚这本书的结构再下手。 第二阶段，理解内容 这本书作者是怎么写出来的？你需要找出书里反复出现的关键词，需要在那些你认为重要的句子下画出标记，从这些话里找出作者的中心思想，用做笔记的方式重新搭建书里的前因后果，有时候，画一张表就能解决这个问题。看着这张你自己画的笔记图，你可以在脑子里迅速过一遍全书的论述是怎样展开的。 第三阶段，评价 这本书写得怎么样？看任何书，都一定要有评论，要有自己的态度。当你完成了对一本书的评价，才算真正完成了对这本书的阅读。最有学习能力的读者，也就是最能批评的读者。但是记住，不要在读完之前就随便下结论，如果读完以后你不能同意作者的看法，你要学会总结原因，如果你还是没有理解作者的看法，也列举下你的原因。 第四层 主题阅读简单来说就是按图索骥。照着你自己感兴趣的主题找书去读。这个层次的阅读需要更强的主动性，还需要读者有一定的判断力。主题阅读，不是说你读完了一本书接着读第二本，而是说你带着你想解决的问题，去读不同的书里的不同的章节。主题阅读不是为了看书而看书，而是为了解决实用性的问题而看书。 总结《如何阅读一本书》告诉我们阅读的好处和阅读的技巧，阅读，是防止心智萎缩、延缓心智衰老的最有效手段。而阅读的方法，一个总的原则是，我们应该尽量去读那些“略高于我们的”读物，而判断标准就是“这本书谈了什么、细节怎么样、是否有道理、跟我们有什么关系”这四点，这是在翻开一本书的时候应该着重注意的，而相对应的，阅读由低到高，也可以分为四个阶段，分别是：基础阅读、检视阅读、分析阅读和主题阅读，各有不同的技巧和注意事项，当你能够掌握对不同的书的不同阅读方法，你就会收获读书带给你的巨大回报。这本畅销70多年的“阅读宝典”，我就给你说到这，希望它能带给你对于阅读的新启发。 参考本文图文参考：《得到》每天听本书栏目 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>STUDY</tag>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker,轻量级的虚拟化技术]]></title>
    <url>%2F2019%2F10%2F11%2Fdocker%2F</url>
    <content type="text"><![CDATA[Docker 一个利用了lxc的技术的一个虚拟化引擎。 Docker简介什么是虚拟化​ 在计算机中，虚拟化（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。这些资源的新虚拟部份是不受现有资源的架设方式，地域或物理组态所限制。一般所指的虚拟化资源包括计算能力和资料存储。 ​ 在实际的生产环境中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件 对资源充分利用 ​ 虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机等等。 什么是Docker​ Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。 ​ ​ Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。 ​ Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。 ​ 在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。 为什么选择Docker? （1）上手快。 ​ 用户只需要几分钟，就可以把自己的程序“Docker化”。Docker依赖于“写时复制”（copy-on-write）模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改”的境界。 随后，就可以创建容器来运行应用程序了。大多数Docker容器只需要不到1秒中即可启动。由于去除了管理程序的开销，Docker容器拥有很高的性能，同时同一台宿主机中也可以运行更多的容器，使用户尽可能的充分利用系统资源。 （2）职责的逻辑分类 ​ 使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。Docker设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题（测试环境都是正常的，上线后出了问题就归结为肯定是运维的问题）” （3）快速高效的开发生命周期 ​ Docker的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。（通俗一点说，Docker就像一个盒子，里面可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件件的取。） （4）鼓励使用面向服务的架构 ​ Docker还鼓励面向服务的体系结构和微服务架构。Docker推荐单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单，同时也提高了程序的内省性。（当然，可以在一个容器中运行多个应用程序） 1.3 容器与虚拟机比较​ 下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。 与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。 Docker 组件Docker服务器与客户端​ Docker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。 Docker镜像与容器​ 镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。例如： 添加一个文件； 执行一个命令； 打开一个窗口。 也可以将镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新。 ​ Docker可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容器即可。容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。 容器基于镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务。 所以Docker容器就是： ​ 一个镜像格式； ​ 一些列标准操作； ​ 一个执行环境。 ​ Docker借鉴了标准集装箱的概念。标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。 和集装箱一样，Docker在执行上述操作时，并不关心容器中到底装了什么，它不管是web服务器，还是数据库，或者是应用程序服务器什么的。所有的容器都按照相同的方式将内容“装载”进去。 Docker也不关心你要把容器运到何方：我们可以在自己的笔记本中构建容器，上传到Registry，然后下载到一个物理的或者虚拟的服务器来测试，在把容器部署到具体的主机中。像标准集装箱一样，Docker容器方便替换，可以叠加，易于分发，并且尽量通用。 Registry（注册中心）​ Docker用Registry来保存用户构建的镜像。Registry分为公共和私有两种。Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像（说明：在Docker Hub下载镜像巨慢，可以自己构建私有的Registry）。 ​ https://hub.docker.com/ Docker安装与启动安装Docker​ Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。 ​ 由于我们学习的环境都使用的是CentOS，因此这里我们将Docker安装到CentOS上。注意：这里建议安装在CentOS7.x以上的版本，在CentOS6.x的版本中，安装前需要安装其他很多的环境而且Docker很多补丁不支持更新。 ​ 请直接挂载课程配套的Centos7.x镜像 （1）yum 包更新到最新 sudo yum update （2）安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 sudo yum install -y yum-utils device-mapper-persistent-data lvm2 （3）设置yum源为阿里云 sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo （4）安装docker sudo yum install docker-ce （5）安装后查看docker版本 docker -v 设置ustc的镜像ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。 https://lug.ustc.edu.cn/wiki/mirrors/help/docker 编辑该文件： vi /etc/docker/daemon.json 在该文件中输入如下内容： { "registry-mirrors": ["https://docker.mirrors.ustc.edu.cn"] } Docker的启动与停止systemctl命令是系统服务管理器指令 启动docker： systemctl start docker 停止docker： systemctl stop docker 重启docker： systemctl restart docker 查看docker状态： systemctl status docker 开机启动： systemctl enable docker 查看docker概要信息 docker info 查看docker帮助文档 docker --help 常用命令镜像相关命令查看镜像docker images REPOSITORY：镜像名称 TAG：镜像标签 IMAGE ID：镜像ID CREATED：镜像的创建日期（不是获取该镜像的日期） SIZE：镜像大小 这些镜像都是存储在Docker宿主机的/var/lib/docker目录下 搜索镜像如果你需要从网络中查找需要的镜像，可以通过以下命令搜索 docker search 镜像名称 NAME：仓库名称 DESCRIPTION：镜像描述 STARS：用户评价，反应一个镜像的受欢迎程度 OFFICIAL：是否官方 AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的 拉取镜像拉取镜像就是从中央仓库中下载镜像到本地 docker pull 镜像名称 例如，我要下载centos7镜像 docker pull centos:7 删除镜像按镜像ID删除镜像 docker rmi 镜像ID 删除所有镜像 docker rmi `docker images -q` 容器相关命令查看容器查看正在运行的容器 docker ps 查看所有容器 docker ps –a 查看最后一次运行的容器 docker ps –l 查看停止的容器 docker ps -f status=exited 创建与启动容器创建容器常用的参数说明： 创建容器命令：docker run -i：表示运行容器 -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。 –name :为创建的容器命名。 -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。 -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。 -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射 （1）交互式方式创建容器 docker run -it --name=容器名称 镜像名称:标签 /bin/bash 这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态 退出当前容器 exit （2）守护式方式创建容器： docker run -di --name=容器名称 镜像名称:标签 登录守护式容器方式： docker exec -it 容器名称 (或者容器ID) /bin/bash 停止与启动容器停止容器： docker stop 容器名称（或者容器ID） 启动容器： docker start 容器名称（或者容器ID） 文件拷贝如果我们需要将文件拷贝到容器内可以使用cp命令 docker cp 需要拷贝的文件或目录 容器名称:容器目录 也可以将文件从容器内拷贝出来 docker cp 容器名称:容器目录 需要拷贝的文件或目录 目录挂载我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。创建容器 添加-v参数 后边为 宿主机目录:容器目录，例如： docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos3 centos:7 如果你共享的是多级的目录，可能会出现权限不足的提示。 这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数 –privileged=true 来解决挂载的目录没有权限的问题 查看容器IP地址我们可以通过以下命令查看容器运行的各种数据 docker inspect 容器名称（容器ID） 也可以直接执行下面的命令直接输出IP地址 docker inspect --format='{{.NetworkSettings.IPAddress}}' 容器名称（容器ID） 删除容器删除指定的容器： docker rm 容器名称（容器ID） 应用部署MySQL部署（1）拉取mysql镜像 docker pull centos/mysql-57-centos7 （2）创建容器 docker run -di --name=tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql -p 代表端口映射，格式为 宿主机映射端口:容器运行端口 -e 代表添加环境变量 MYSQL_ROOT_PASSWORD 是root用户的登陆密码 （3）远程登录mysql 连接宿主机的IP ,指定端口为33306 tomcat部署（1）拉取镜像 docker pull tomcat:7-jre7 （2）创建容器 创建容器 -p表示地址映射 docker run -di --name=mytomcat -p 9000:8080 -v /usr/local/webapps:/usr/local/tomcat/webapps tomcat:7-jre7 Nginx部署（1）拉取镜像 docker pull nginx （2）创建Nginx容器 docker run -di --name=mynginx -p 80:80 nginx Redis部署（1）拉取镜像 docker pull redis （2）创建容器 docker run -di --name=myredis -p 6379:6379 redis 迁移与备份容器保存为镜像我们可以通过以下命令将容器保存为镜像 docker commit mynginx mynginx_i 镜像备份我们可以通过以下命令将镜像保存为tar 文件 docker save -o mynginx.tar mynginx_i 镜像恢复与迁移首先我们先删除掉mynginx_img镜像 然后执行此命令进行恢复 docker load -i mynginx.tar -i 输入的文件 执行后再次查看镜像，可以看到镜像已经恢复 Dockerfile Dockerfile文件详解 什么是DockerfileDockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。 对于开发人员：可以为开发团队提供一个完全一致的开发环境； 对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了； 对于运维人员：在部署时，可以实现应用的无缝移植。 常用命令 命令 作用 FROM image_name:tag 定义了使用哪个基础镜像启动构建流程 MAINTAINER user_name 声明镜像的创建者 ENV key value 设置环境变量 (可以写多条) RUN command 是Dockerfile的核心部分(可以写多条) ADD source_dir/file dest_dir/file 将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压 COPY source_dir/file dest_dir/file 和ADD相似，但是如果有压缩文件并不能解压 WORKDIR path_dir 设置工作目录 使用脚本创建镜像步骤： （1）创建目录 mkdir –p /usr/local/dockerjdk8 （2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/dockerjdk8目录 （3）创建文件Dockerfile vi Dockerfile #依赖镜像名称和ID FROM centos:7 #指定镜像创建者信息 MAINTAINER ITCAST #切换工作目录 WORKDIR /usr RUN mkdir /usr/local/java #ADD 是相对路径jar,把java添加到容器中 ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/ #配置java环境变量 ENV JAVA_HOME /usr/local/java/jdk1.8.0_171 ENV JRE_HOME $JAVA_HOME/jre ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH ENV PATH $JAVA_HOME/bin:$PATH （4）执行命令构建镜像 docker build -t='jdk1.8' . 注意后边的空格和点，不要省略 （5）查看镜像是否建立完成 docker images Docker私有仓库私有仓库搭建与配置（1）拉取私有仓库镜像（此步省略） docker pull registry （2）启动私有仓库容器 docker run -di --name=registry -p 5000:5000 registry （3）打开浏览器 输入地址http://192.168.184.141:5000/v2/_catalog看到`{"repositories":[]}` 表示私有仓库搭建成功并且内容为空 （4）修改daemon.json vi /etc/docker/daemon.json 添加以下内容，保存退出。 {"insecure-registries":["192.168.184.141:5000"]} 此步用于让 docker信任私有仓库地址 （5）重启docker 服务 systemctl restart docker 镜像上传至私有仓库（1）标记此镜像为私有仓库的镜像 docker tag jdk1.8 192.168.184.141:5000/jdk1.8 （2）再次启动私服容器 docker start registry （3）上传标记的镜像 docker push 192.168.184.141:5000/jdk1.8 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>STUDY</category>
      </categories>
      <tags>
        <tag>STUDY</tag>
        <tag>运维</tag>
        <tag>容器</tag>
        <tag>虚拟化</tag>
        <tag>轻量级</tag>
      </tags>
  </entry>
</search>
