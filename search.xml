<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[软件开发手册]]></title>
    <url>%2F2021%2F02%2F24%2Fsoftware-development-manual%2F</url>
    <content type="text"><![CDATA[无规矩不成方圆 GIT系列开发分支规范 分支 命名 说明 主分支 master 所有提供给用户使用的正式版本，都在这个主分支上发布 开发分支 dev 永远是功能最新最全的分支 功能分支 feature-* 新功能分支，某个功能点正在开发阶段 发布版本 release-* 发布定期要上线的功能 修复分支 bug-* 修复线上代码的 bug document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>手册</category>
      </categories>
      <tags>
        <tag>手册</tag>
        <tag>软件开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记frame/iframe内嵌网页不显示问题]]></title>
    <url>%2F2021%2F02%2F23%2Fx-frame-options-sameorigin%2F</url>
    <content type="text"><![CDATA[前端同事内嵌网页,发现个别网页无法显示并提示,”in a frame because it set ‘X-Frame-Options’ to ‘sameorigin’”的报错(如：youku视频) 一、预备知识点1.同源策略1.1 什么是同源URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。相反，只要协议，域名，端口有任何一个的不同，就被当作是跨域。 1.2 同源策略(Same-Origin-Policy(SOP))浏览器默认采用同源策略，禁止页面加载或执行与自身来源不同的域的任何脚本。 场景： 一个恶意网站的页面通过iframe嵌入了银行的登录页面（二者不同源），如果没有同源限制，恶意网页上的javascript脚本就可以在用户登录银行的时候获取用户名和密码。 浏览器中有哪些不受同源限制呢？ &lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;、&lt;link&gt;这些包含 src 属性的标签可以加载跨域资源。但浏览器限制了JavaScript的权限使其不能读、写加载的内容。 2.跨域跨域是指从一个域的网页去请求另一个域的资源。 3.点击劫持这种攻击在恶意站点诱导用户点击另一个站点的被覆盖元素时出现，另一个站点已经加载到了隐藏的frame或iframe中。 点击劫持的示例 假设一个在线商店拥有一个页面，已登录的用户可以点击“购买”按钮来购买一个商品。用户为了方便，可以选择一直保持商店的登录状态。一个攻击者的站点可能在他们自己的页面上会创建一个“收藏”按钮，并且在一个透明的iframe中加载商店的页面，把“购买”的按钮隐藏起来覆盖在“收藏”上。如果用户访问了攻击者的站点，点击“收藏”按钮会触发对“购买”按钮的无意识的点击，不知不觉中便购买了商品。 二、X-Frame-Options1.什么是X-Frame-OptionsX-Frame-Options HTTP 响应头是用来给浏览器 指示允许一个页面 可否在&lt;frame&gt;,&lt;iframe&gt;, &lt;embed&gt; 或者 &lt;object&gt; 中展现的标记。站点可以通过确保网站没有被嵌入到别人的站点里面，从而避免 clickjacking 攻击。 2.X-Frame-Options有什么用用于点击劫持的防御：现代浏览器遵循X-Frame-Options协议头(RFC 7034规范),根据协议头不同配置,从而决定一个资源是否允许加载到frame或者iframe中。 3.如何配置 Note: 设置 meta 标签是无效的！例如 没有任何效果。只有当像下面示例那样设置 HTTP 头 X-Frame-Options 才会生效。 3.1 X-Frame-Options配置参数 参数 含义 命令 deny 表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。 add_header X-Frame-Options deny; sameorigin 表示该页面可以在相同域名页面的 frame 中展示。 add_header X-Frame-Options sameorigin; allow-from 表示该页面可以在指定来源的 frame 中展示。 add_header X-Frame-Options allow-from https://example.com/; allowall 允许所有站点内嵌展示。 add_header X-Frame-Options allowall; 3.2 配置 Apache配置 Apache 在所有页面上发送 X-Frame-Options 响应头，需要把下面这行添加到 ‘site’ 的配置中: Header always set X-Frame-Options "sameorigin" 要将 Apache 的配置 X-Frame-Options 设置成 deny , 按如下配置去设置你的站点： Header set X-Frame-Options "deny" 要将 Apache 的配置 X-Frame-Options 设置成 allow-from，在配置里添加： Header set X-Frame-Options "allow-from https://example.com/" 3.3 配置 nginx配置 nginx 发送 X-Frame-Options 响应头，把下面这行添加到 ‘http’, ‘server’ 或者 ‘location’ 的配置中: 例如：1.修改配置 add_header X-Frame-Options allowall always; 2.nginx指定目下生效配置 cd ../usr/sbin/ ./nginx -s reload 3.检测是否配置成功 curl -I http://192.168.2.2:5091 3.4 配置 IIS配置 IIS 发送 X-Frame-Options 响应头，添加下面的配置到 Web.config 文件中： &lt;system.webServer&gt; ... &lt;httpProtocol&gt; &lt;customHeaders&gt; &lt;add name="X-Frame-Options" value="sameorigin" /&gt; &lt;/customHeaders&gt; &lt;/httpProtocol&gt; ... &lt;/system.webServer&gt; 3.5 配置 HAProxy配置 HAProxy 发送 X-Frame-Options 头，添加这些到你的前端、监听 listen，或者后端的配置里面： rspadd X-Frame-Options:\ sameorigin 或者，在更加新的版本中： http-response set-header X-Frame-Options sameorigin 3.6 配置 Express要配置 Express 可以发送 X-Frame-Options header，你可以用借助了 frameguard 来设置头部的 helmet。在你的服务器配置里面添加： const helmet = require('helmet'); const app = express(); app.use(helmet.frameguard({ action: "sameorigin" })); 或者，你也可以直接用 frameguard： const frameguard = require('frameguard') app.use(frameguard({ action: 'sameorigin' })) 4.测评 三、最终结果1.猜测优酷开启了同源策略（sameorigin），所以我们的iframe无法内嵌其网页2.解决方案，亲测可以 四、参考链接传送门1传送门2传送门3 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTTP</tag>
        <tag>X-Frame-Options</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三阶魔方教程]]></title>
    <url>%2F2021%2F02%2F21%2F3ordercube%2F</url>
    <content type="text"><![CDATA[三阶魔方是玩任意阶魔方的基础 公式概览：公式一(小花、白十字、白面底)：上左下右 公式二(中间层)：上右下左 公式三(黄十字)：正面顺时针转90度，公式一（上左下右），逆时针转90度回去 公式四(小鱼、黄面)：下右上右，下右右上 公式五(顶层角块)：上右上，底层转180，下左上，底层转180度，右边转180度 公式六(顶层棱块)：下左下右，下右下左，上左，右180度 认识魔方魔方面组成：中心块（6）、棱块（12）、角块（8）国际标准魔方配色： 白底黄顶,左到右红蓝橙绿 使用方法: 层先法（即一层一层还原）本次以白底黄顶作为作为坐标系 拼底层十字（小花/白十字） 顶层黄心白十字(小花) 每个白色棱块另一面与每一面的中心块颜色保持一致,并转到底层(白面)去 底层纯白十字，并且白面棱块的颜色和每个面的中心色保持一致 还原第一层公式一（右手）：上左下右 还原四个底部角块：1.找到顶层有白色面的角块,转到另外两个颜色面中间（另外两个颜色均不是黄色）2.重复做公式一3.直到白色面朝下,另外两个面的颜色和中心块对上 异常情况：1.遇到顶层没有白色角块，白色角块面一定错位在底部，做公式一，将白色转上去，然后继续按步骤还原 还原第二层公式二（左手）：上右下左 还原中间层：1.找到顶层棱块（没有黄色面的棱块），将其中一色(正面)对准中心块,另一面色（顶面色）一定在魔方的左面或者右面2.顶面色远离相同色的面，顶面层转动一面 2.1 顶面层向右转，做左手公式二一次,再将整体向右转一面，做右手公式一一次 2.2 定面层向左转，做右手公式一一次,再将整体向左转一面，做左手公式二一次 异常情况：顶面棱块出现都有黄色面,但是第二层没有还原的情况，将中间层没有还原的棱块放在右手边，右手做一次公式一，向左转一面，左手做一次公式二 拼顶面十字（黄十字）公式三（右手）：正面顺时针转90度，公式一（上左下右），逆时针转90度回去 情况一：单独的一个黄色中心点情况二：中心点+右下棱块是黄色情况三：一条黄色的直线情况四：黄色十字 情况一、二、三需要转换成情况四 情况一：做公式三一次情况二：小拐弯放在右手边（黄顶朝上），做公式三一次情况三：黄色直线平行于我们放（黄顶朝上），做公式三一次 还原顶面颜色（小鱼）公式四（右手）： 下右上右，下右右上 情况一：顶面少两个黄色点情况二：顶面少四个黄色点情况三：顶面少三个黄色点（小鱼） 情况一、二需要转换层三 情况一：将左后方顶层放黄色，黄顶朝上，做公式四情况二: 将后方顶层不要有黄色，黄顶朝上，做公式四 情况三：鱼头放在左上方,黄顶朝上，做公式四 对好顶层角块颜色公式五（右手）：上右上，底层转180，下左上，底层转180，右边转180 黄顶朝上时候，顶层找到两个角块面是一样的颜色（如果没有，则任意朝下），朝下，黄面朝前，做公式五 调整顶层棱块公式六（右手）：下左下右，下右下左，上左，右180度 黄顶朝上，找到侧面已经还原好的一个面（没有则任意面），对着正面，然后做公式六 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>娱乐</category>
      </categories>
      <tags>
        <tag>三阶</tag>
        <tag>魔方</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[听者记2021]]></title>
    <url>%2F2021%2F02%2F19%2Ftingzheji2021%2F</url>
    <content type="text"><![CDATA[涉猎阅未闻,蹔使心魂澄 《卓有成效的管理者》[2021-2-19] 真正重要的不是趋势本身,而是趋势改变。 《高情商是练出来的》[2021-2-20] 强调理性与感性，接收与改变之间的辩证平衡与协调 《微精通》[2021-2-21] 给人生创建一个抽奖系统 《魔鬼经济学1》[2021-2-22] 抛弃常规思维，从“数据分析”的视角,来找事情的真相 《魔鬼经济学2》[2021-2-23] 从客观事实和数据出发，考察具体情境里人们道德选择 《魔鬼经济学3》[2021-2-24] 人号称是理性动物，但现实中的行为却常常是非理性的 《魔鬼经济学4》[2021-2-25] 用数据为线索采用魔鬼式思考 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>视野</category>
      </categories>
      <tags>
        <tag>视野</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计划2021]]></title>
    <url>%2F2021%2F02%2F19%2Fplan2021%2F</url>
    <content type="text"><![CDATA[以教为学,有输入有输出 上半年主线工作MySQL阶段一：2021.01.17 ~ 2021.01.23《MySQL组合拳》 JVM(2021.01.25 ~ )多线程学习软件设计师(2021.02.20 ~ 2021.05.x)生活健身(2021.02.20 ~ 2021.05.x)支线设计模式阶段一：2021.01.05《Java设计模式》 算法NettyJava基础强化听者记《听者记2021》 下半年主线工作中间件框架学习软件架构师 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库优化之组合拳(四)]]></title>
    <url>%2F2021%2F01%2F23%2Fmysql-advanced-4%2F</url>
    <content type="text"><![CDATA[非原创图文,图文来源于黑马官网,此处仅作为备份学习 MySQL数据库优化总概 组合拳（一） 组合拳（二） 组合拳（三） 🚩组合拳（四） 索引 体系结构 应用优化 MySQL 常用工具 视图 存储引擎 查询缓存优化 MySQL 日志 存储过程和函数 优化SQL步骤 内存管理及优化 MySQL 主从复制 触发器 索引使用 MySQL锁问题 SQL优化 常用SQL技巧 1. MySql中常用工具1.1 mysql该mysql不是指mysql服务，而是指mysql的客户端工具。 语法 ： mysql [options] [database] 1.1.1 连接选项参数 ： -u, --user=name 指定用户名 -p, --password[=name] 指定密码 -h, --host=name 指定服务器IP或域名 -P, --port=# 指定连接端口 示例 ： mysql -h 127.0.0.1 -P 3306 -u root -p mysql -h127.0.0.1 -P3306 -uroot -p2143 1.1.2 执行选项-e, --execute=name 执行SQL语句并退出 此选项可以在Mysql客户端执行SQL语句，而不用连接到MySQL数据库再执行，对于一些批处理脚本，这种方式尤其方便。 示例： mysql -uroot -p2143 db01 -e "select * from tb_book"; 1.2 mysqladminmysqladmin 是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等。 可以通过 ： mysqladmin –help 指令查看帮助文档 示例 ： mysqladmin -uroot -p2143 create 'test01'; mysqladmin -uroot -p2143 drop 'test01'; mysqladmin -uroot -p2143 version; 1.3 mysqlbinlog由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到mysqlbinlog 日志管理工具。 语法 ： mysqlbinlog [options] log-files1 log-files2 ... 选项： -d, --database=name : 指定数据库名称，只列出指定的数据库相关操作。 -o, --offset=# : 忽略掉日志中的前n行命令。 -r,--result-file=name : 将输出的文本格式日志输出到指定文件。 -s, --short-form : 显示简单格式， 省略掉一些信息。 --start-datatime=date1 --stop-datetime=date2 : 指定日期间隔内的所有日志。 --start-position=pos1 --stop-position=pos2 : 指定位置间隔内的所有日志。 1.4 mysqldumpmysqldump 客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句。 语法 ： mysqldump [options] db_name [tables] mysqldump [options] --database/-B db1 [db2 db3...] mysqldump [options] --all-databases/-A 1.4.1 连接选项参数 ： -u, --user=name 指定用户名 -p, --password[=name] 指定密码 -h, --host=name 指定服务器IP或域名 -P, --port=# 指定连接端口 1.4.2 输出内容选项参数： --add-drop-database 在每个数据库创建语句前加上 Drop database 语句 --add-drop-table 在每个表创建语句前加上 Drop table 语句 , 默认开启 ; 不开启 (--skip-add-drop-table) -n, --no-create-db 不包含数据库的创建语句 -t, --no-create-info 不包含数据表的创建语句 -d --no-data 不包含数据 -T, --tab=name 自动生成两个文件：一个.sql文件，创建表结构的语句； 一个.txt文件，数据文件，相当于select into outfile 示例 ： mysqldump -uroot -p2143 db01 tb_book --add-drop-database --add-drop-table &gt; a mysqldump -uroot -p2143 -T /tmp test city 1.5 mysqlimport/sourcemysqlimport 是客户端数据导入工具，用来导入mysqldump 加 -T 参数后导出的文本文件。 语法： mysqlimport [options] db_name textfile1 [textfile2...] 示例： mysqlimport -uroot -p2143 test /tmp/city.txt 如果需要导入sql文件,可以使用mysql中的source 指令 : source /root/tb_book.sql 1.6 mysqlshowmysqlshow 客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引。 语法： mysqlshow [options] [db_name [table_name [col_name]]] 参数： --count 显示数据库及表的统计信息（数据库，表 均可以不指定） -i 显示指定数据库或者指定表的状态信息 示例： #查询每个数据库的表的数量及表中记录的数量 mysqlshow -uroot -p2143 --count #查询test库中每个表中的字段书，及行数 mysqlshow -uroot -p2143 test --count #查询test库中book表的详细情况 mysqlshow -uroot -p2143 test book --count 2. Mysql 日志在任何一种数据库中，都会有各种各样的日志，记录着数据库工作的方方面面，以帮助数据库管理员追踪数据库曾经发生过的各种事件。MySQL 也不例外，在 MySQL 中，有 4 种不同的日志，分别是错误日志、二进制日志（BINLOG 日志）、查询日志和慢查询日志，这些日志记录着数据库在不同方面的踪迹。 2.1 错误日志错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，可以首先查看此日志。 该日志是默认开启的 ， 默认存放目录为 mysql 的数据目录（var/lib/mysql）, 默认的日志文件名为 hostname.err（hostname是主机名）。 查看日志位置指令 ： show variables like 'log_error%'; 查看日志内容 ： tail -f /var/lib/mysql/xaxh-server.err 2.2 二进制日志2.2.1概述二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但是不包括数据查询语句。此日志对于灾难时的数据恢复起着极其重要的作用，MySQL的主从复制， 就是通过该binlog实现的。 二进制日志，默认情况下是没有开启的，需要到MySQL的配置文件中开启，并配置MySQL日志的格式。 配置文件位置 : /usr/my.cnf 日志存放位置 : 配置时，给定了文件名但是没有指定路径，日志默认写入Mysql的数据目录。 #配置开启binlog日志， 日志的文件前缀为 mysqlbin -----&gt; 生成的文件名如 : mysqlbin.000001,mysqlbin.000002 log_bin=mysqlbin #配置二进制日志的格式 binlog_format=STATEMENT 2.2.2 日志格式STATEMENT 该日志格式在日志文件中记录的都是SQL语句（statement），每一条对数据进行修改的SQL都会记录在日志文件中，通过Mysql提供的mysqlbinlog工具，可以清晰的查看到每条语句的文本。主从复制的时候，从库（slave）会将日志解析为原文本，并在从库重新执行一次。 ROW 该日志格式在日志文件中记录的是每一行的数据变更，而不是记录SQL语句。比如，执行SQL语句 ： update tb_book set status=’1’ , 如果是STATEMENT 日志格式，在日志中会记录一行SQL文件； 如果是ROW，由于是对全表进行更新，也就是每一行记录都会发生变更，ROW 格式的日志中会记录每一行的数据变更。 MIXED 这是目前MySQL默认的日志格式，即混合了STATEMENT 和 ROW两种格式。默认情况下采用STATEMENT，但是在一些特殊情况下采用ROW来进行记录。MIXED 格式能尽量利用两种模式的优点，而避开他们的缺点。 2.2.3 日志读取由于日志以二进制方式存储，不能直接读取，需要用mysqlbinlog工具来查看，语法如下 ： mysqlbinlog log-file； 查看STATEMENT格式日志 执行插入语句 ： insert into tb_book values(null,'Lucene','2088-05-01','0'); 查看日志文件 ： mysqlbin.index : 该文件是日志索引文件 ， 记录日志的文件名； mysqlbing.000001 ：日志文件 查看日志内容 ： mysqlbinlog mysqlbing.000001； 查看ROW格式日志 配置 : #配置开启binlog日志， 日志的文件前缀为 mysqlbin -----&gt; 生成的文件名如 : mysqlbin.000001,mysqlbin.000002 log_bin=mysqlbin #配置二进制日志的格式 binlog_format=ROW 插入数据 : insert into tb_book values(null,'SpringCloud实战','2088-05-05','0'); 如果日志格式是 ROW , 直接查看数据 , 是查看不懂的 ; 可以在mysqlbinlog 后面加上参数 -vv mysqlbinlog -vv mysqlbin.000002 2.2.4 日志删除对于比较繁忙的系统，由于每天生成日志量大 ，这些日志如果长时间不清楚，将会占用大量的磁盘空间。下面我们将会讲解几种删除日志的常见方法 ： 方式一 通过 Reset Master 指令删除全部 binlog 日志，删除之后，日志编号，将从 xxxx.000001重新开始 。 查询之前 ，先查询下日志文件 ： 执行删除日志指令： Reset Master 执行之后， 查看日志文件 ： 方式二 执行指令 purge master logs to 'mysqlbin.******' ，该命令将删除 ****** 编号之前的所有日志。 方式三 执行指令 purge master logs before 'yyyy-mm-dd hh24:mi:ss' ，该命令将删除日志为 “yyyy-mm-dd hh24:mi:ss” 之前产生的所有日志 。 方式四 设置参数 –expire_logs_days=# ，此参数的含义是设置日志的过期天数， 过了指定的天数后日志将会被自动删除，这样将有利于减少DBA 管理日志的工作量。 配置如下 ： 2.3 查询日志查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。 默认情况下， 查询日志是未开启的。如果需要开启查询日志，可以设置以下配置 ： #该选项用来开启查询日志 ， 可选值 ： 0 或者 1 ； 0 代表关闭， 1 代表开启 general_log=1 #设置日志的文件名 ， 如果没有指定， 默认的文件名为 host_name.log general_log_file=file_name 在 mysql 的配置文件 /usr/my.cnf 中配置如下内容 ： 配置完毕之后，在数据库执行以下操作 ： select * from tb_book; select * from tb_book where id = 1; update tb_book set name = 'lucene入门指南' where id = 5; select * from tb_book where id &lt; 8; 执行完毕之后， 再次来查询日志文件 ： 2.4 慢查询日志慢查询日志记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录数不小于 min_examined_row_limit 的所有的SQL语句的日志。long_query_time 默认为 10 秒，最小为 0， 精度可以到微秒。 2.4.1 文件位置和格式慢查询日志默认是关闭的 。可以通过两个参数来控制慢查询日志 ： # 该参数用来控制慢查询日志是否开启， 可取值： 1 和 0 ， 1 代表开启， 0 代表关闭 slow_query_log=1 # 该参数用来指定慢查询日志的文件名 slow_query_log_file=slow_query.log # 该选项用来配置查询的时间限制， 超过这个时间将认为值慢查询， 将需要进行日志记录， 默认10s long_query_time=10 2.4.2 日志的读取和错误日志、查询日志一样，慢查询日志记录的格式也是纯文本，可以被直接读取。 1） 查询long_query_time 的值。 2） 执行查询操作 select id, title,price,num ,status from tb_item where id = 1; 由于该语句执行时间很短，为0s ， 所以不会记录在慢查询日志中。 select * from tb_item where title like '%阿尔卡特 (OT-927) 炭黑 联通3G手机 双卡双待165454%' ; 该SQL语句 ， 执行时长为 26.77s ，超过10s ， 所以会记录在慢查询日志文件中。 3） 查看慢查询日志文件 直接通过cat 指令查询该日志文件 ： 如果慢查询日志内容很多， 直接查看文件，比较麻烦， 这个时候可以借助于mysql自带的 mysqldumpslow 工具， 来对慢查询日志进行分类汇总。 3. Mysql复制3.1 复制概述复制是指将主数据库的DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。 MySQL支持一台主库同时向多台从库进行复制， 从库同时也可以作为其他从服务器的主库，实现链状复制。 3.2 复制原理MySQL 的主从复制原理如下。 从上层来看，复制分成三步： Master 主库在事务提交时，会把数据变更作为时间 Events 记录在二进制日志文件 Binlog 中。 主库推送二进制日志文件 Binlog 中的日志事件到从库的中继日志 Relay Log 。 slave重做中继日志中的事件，将改变反映它自己的数据。 3.3 复制优势MySQL 复制的有点主要包含以下三个方面： 主库出现问题，可以快速切换到从库提供服务。 可以在从库上执行查询操作，从主库中更新，实现读写分离，降低主库的访问压力。 可以在从库中执行备份，以避免备份期间影响主库的服务。 3.4 搭建步骤3.4.1 master1） 在master 的配置文件（/usr/my.cnf）中，配置如下内容： #mysql 服务ID,保证整个集群环境中唯一 server-id=1 #mysql binlog 日志的存储路径和文件名 log-bin=/var/lib/mysql/mysqlbin #错误日志,默认已经开启 #log-err #mysql的安装目录 #basedir #mysql的临时目录 #tmpdir #mysql的数据存放目录 #datadir #是否只读,1 代表只读, 0 代表读写 read-only=0 #忽略的数据, 指不需要同步的数据库 binlog-ignore-db=mysql #指定同步的数据库 #binlog-do-db=db01 2） 执行完毕之后，需要重启Mysql： service mysql restart ； 3） 创建同步数据的账户，并且进行授权操作： grant replication slave on *.* to 'itcast'@'192.168.192.131' identified by 'itcast'; flush privileges; 4） 查看master状态： show master status; 字段含义： File : 从哪个日志文件开始推送日志文件 Position ： 从哪个位置开始推送日志 Binlog_Ignore_DB : 指定不需要同步的数据库 3.4.2 slave1） 在 slave 端配置文件中，配置如下内容： #mysql服务端ID,唯一 server-id=2 #指定binlog日志 log-bin=/var/lib/mysql/mysqlbin 2） 执行完毕之后，需要重启Mysql： service mysql restart； 3） 执行如下指令 ： change master to master_host= '192.168.192.130', master_user='itcast', master_password='itcast', master_log_file='mysqlbin.000001', master_log_pos=413; 指定当前从库对应的主库的IP地址，用户名，密码，从哪个日志文件开始的那个位置开始同步推送日志。 4） 开启同步操作 start slave; show slave status; 5） 停止同步操作 stop slave; 3.4.3 验证同步操作1） 在主库中创建数据库，创建表，并插入数据 ： create database db01; user db01; create table user( id int(11) not null auto_increment, name varchar(50) not null, sex varchar(1), primary key (id) )engine=innodb default charset=utf8; insert into user(id,name,sex) values(null,'Tom','1'); insert into user(id,name,sex) values(null,'Trigger','0'); insert into user(id,name,sex) values(null,'Dawn','1'); 2） 在从库中查询数据，进行验证 ： 在从库中，可以查看到刚才创建的数据库： 在该数据库中，查询user表中的数据： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL数据库优化之组合拳(四)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库优化之组合拳(三)]]></title>
    <url>%2F2021%2F01%2F23%2Fmysql-advanced-3%2F</url>
    <content type="text"><![CDATA[非原创图文,图文来源于黑马官网,此处仅作为备份学习 MySQL数据库优化总概 组合拳（一） 组合拳（二） 🚩组合拳（三） 组合拳（四） 索引 体系结构 应用优化 MySQL 常用工具 视图 存储引擎 查询缓存优化 MySQL 日志 存储过程和函数 优化SQL步骤 内存管理及优化 MySQL 主从复制 触发器 索引使用 MySQL锁问题 SQL优化 常用SQL技巧 1. 应用优化前面章节，我们介绍了很多数据库的优化措施。但是在实际生产环境中，由于数据库本身的性能局限，就必须要对前台的应用进行一些优化，来降低数据库的访问压力。 1.1 使用连接池对于访问数据库来说，建立连接的代价是比较昂贵的，因为我们频繁的创建关闭连接，是比较耗费资源的，我们有必要建立 数据库连接池，以提高访问的性能。 1.2 减少对MySQL的访问1.2.1 避免对数据进行重复检索在编写应用代码时，需要能够理清对数据库的访问逻辑。能够一次连接就获取到结果的，就不用两次连接，这样可以大大减少对数据库无用的重复请求。 比如 ，需要获取书籍的id 和name字段 ， 则查询如下： select id , name from tb_book; 之后，在业务逻辑中有需要获取到书籍状态信息， 则查询如下： select id , status from tb_book; 这样，就需要向数据库提交两次请求，数据库就要做两次查询操作。其实完全可以用一条SQL语句得到想要的结果。 select id, name , status from tb_book; 1.2.2 增加cache层在应用中，我们可以在应用中增加 缓存 层来达到减轻数据库负担的目的。缓存层有很多种，也有很多实现方式，只要能达到降低数据库的负担又能满足应用需求就可以。 因此可以部分数据从数据库中抽取出来放到应用端以文本方式存储， 或者使用框架(Mybatis, Hibernate)提供的一级缓存/二级缓存，或者使用redis数据库来缓存数据 。 1.3 负载均衡负载均衡是应用中使用非常普遍的一种优化方法，它的机制就是利用某种均衡算法，将固定的负载量分布到不同的服务器上， 以此来降低单台服务器的负载，达到优化的效果。 1.3.1 利用MySQL复制分流查询通过MySQL的主从复制，实现读写分离，使增删改操作走主节点，查询操作走从节点，从而可以降低单台服务器的读写压力。 1.3.2 采用分布式数据库架构分布式数据库架构适合大数据量、负载高的情况，它有良好的拓展性和高可用性。通过在多台服务器之间分布数据，可以实现在多台服务器之间的负载均衡，提高访问效率。 2. Mysql中查询缓存优化2.1 概述开启Mysql的查询缓存，当执行完全相同的SQL语句的时候，服务器就会直接从缓存中读取结果，当数据被修改，之前的缓存会失效，修改比较频繁的表不适合做查询缓存。 2.2 操作流程 客户端发送一条查询给服务器； 服务器先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段； 服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划； MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询； 将结果返回给客户端。 2.3 查询缓存配置 查看当前的MySQL数据库是否支持查询缓存： SHOW VARIABLES LIKE 'have_query_cache'; 查看当前MySQL是否开启了查询缓存 ： SHOW VARIABLES LIKE 'query_cache_type'; 查看查询缓存的占用大小 ： SHOW VARIABLES LIKE 'query_cache_size'; 查看查询缓存的状态变量： SHOW STATUS LIKE 'Qcache%'; 各个变量的含义如下： | 参数 | 含义 || ———————– | ———————————————————— || Qcache_free_blocks | 查询缓存中的可用内存块数 || Qcache_free_memory | 查询缓存的可用内存量 || Qcache_hits | 查询缓存命中数 || Qcache_inserts | 添加到查询缓存的查询数 || Qcache_lowmen_prunes | 由于内存不足而从查询缓存中删除的查询数 || Qcache_not_cached | 非缓存查询的数量（由于 query_cache_type 设置而无法缓存或未缓存） || Qcache_queries_in_cache | 查询缓存中注册的查询数 || Qcache_total_blocks | 查询缓存中的块总数 | 2.4 开启查询缓存MySQL的查询缓存默认是关闭的，需要手动配置参数 query_cache_type ， 来开启查询缓存。query_cache_type 该参数的可取值有三个 ： 值 含义 OFF 或 0 查询缓存功能关闭 ON 或 1 查询缓存功能打开，SELECT的结果符合缓存条件即会缓存，否则，不予缓存，显式指定 SQL_NO_CACHE，不予缓存 DEMAND 或 2 查询缓存功能按需进行，显式指定 SQL_CACHE 的SELECT语句才会缓存；其它均不予缓存 在 /usr/my.cnf 配置中，增加以下配置 ： 配置完毕之后，重启服务既可生效 ； 然后就可以在命令行执行SQL语句进行验证 ，执行一条比较耗时的SQL语句，然后再多执行几次，查看后面几次的执行时间；获取通过查看查询缓存的缓存命中数，来判定是否走查询缓存。 2.5 查询缓存SELECT选项可以在SELECT语句中指定两个与查询缓存相关的选项 ： SQL_CACHE : 如果查询结果是可缓存的，并且 query_cache_type 系统变量的值为ON或 DEMAND ，则缓存查询结果 。 SQL_NO_CACHE : 服务器不使用查询缓存。它既不检查查询缓存，也不检查结果是否已缓存，也不缓存查询结果。 例子： SELECT SQL_CACHE id, name FROM customer; SELECT SQL_NO_CACHE id, name FROM customer; ​ 2.6 查询缓存失效的情况1） SQL 语句不一致的情况， 要想命中查询缓存，查询的SQL语句必须一致。 SQL1 : select count(*) from tb_item; SQL2 : Select count(*) from tb_item; 2） 当查询语句中有一些不确定的时，则不会缓存。如 ： now() , current_date() , curdate() , curtime() , rand() , uuid() , user() , database() 。 SQL1 : select * from tb_item where updatetime < now() limit 1; SQL2 : select user(); SQL3 : select database(); 3） 不使用任何表查询语句。 select 'A'; 4） 查询 mysql， information_schema或 performance_schema 数据库中的表时，不会走查询缓存。 select * from information_schema.engines; 5） 在存储的函数，触发器或事件的主体内执行的查询。 6） 如果表更改，则使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除。这包括使用MERGE映射到已更改表的表的查询。一个表可以被许多类型的语句，如被改变 INSERT， UPDATE， DELETE， TRUNCATE TABLE， ALTER TABLE， DROP TABLE，或 DROP DATABASE 。 3. Mysql内存管理及优化3.1 内存优化原则1） 将尽量多的内存分配给MySQL做缓存，但要给操作系统和其他程序预留足够内存。 2） MyISAM 存储引擎的数据文件读取依赖于操作系统自身的IO缓存，因此，如果有MyISAM表，就要预留更多的内存给操作系统做IO缓存。 3） 排序区、连接区等缓存是分配给每个数据库会话（session）专用的，其默认值的设置要根据最大连接数合理分配，如果设置太大，不但浪费资源，而且在并发连接较高时会导致物理内存耗尽。 3.2 MyISAM 内存优化myisam存储引擎使用 key_buffer 缓存索引块，加速myisam索引的读写速度。对于myisam表的数据块，mysql没有特别的缓存机制，完全依赖于操作系统的IO缓存。 key_buffer_sizekey_buffer_size决定MyISAM索引块缓存区的大小，直接影响到MyISAM表的存取效率。可以在MySQL参数文件中设置key_buffer_size的值，对于一般MyISAM数据库，建议至少将1/4可用内存分配给key_buffer_size。 在/usr/my.cnf 中做如下配置： key_buffer_size=512M read_buffer_size如果需要经常顺序扫描myisam表，可以通过增大read_buffer_size的值来改善性能。但需要注意的是read_buffer_size是每个session独占的，如果默认值设置太大，就会造成内存浪费。 read_rnd_buffer_size对于需要做排序的myisam表的查询，如带有order by子句的sql，适当增加 read_rnd_buffer_size 的值，可以改善此类的sql性能。但需要注意的是 read_rnd_buffer_size 是每个session独占的，如果默认值设置太大，就会造成内存浪费。 3.3 InnoDB 内存优化innodb用一块内存区做IO缓存池，该缓存池不仅用来缓存innodb的索引块，而且也用来缓存innodb的数据块。 innodb_buffer_pool_size该变量决定了 innodb 存储引擎表数据和索引数据的最大缓存区大小。在保证操作系统及其他程序有足够内存可用的情况下，innodb_buffer_pool_size 的值越大，缓存命中率越高，访问InnoDB表需要的磁盘I/O 就越少，性能也就越高。 innodb_buffer_pool_size=512M innodb_log_buffer_size决定了innodb重做日志缓存的大小，对于可能产生大量更新记录的大事务，增加innodb_log_buffer_size的大小，可以避免innodb在事务提交前就执行不必要的日志写入磁盘操作。 innodb_log_buffer_size=10M 4. Mysql并发参数调整从实现上来说，MySQL Server 是多线程结构，包括后台线程和客户服务线程。多线程可以有效利用服务器资源，提高数据库的并发性能。在Mysql中，控制并发连接和线程的主要参数包括 max_connections、back_log、thread_cache_size、table_open_cahce。 4.1 max_connections采用max_connections 控制允许连接到MySQL数据库的最大数量，默认值是 151。如果状态变量 connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。 Mysql 最大可支持的连接数，取决于很多因素，包括给定操作系统平台的线程库的质量、内存大小、每个连接的负荷、CPU的处理速度，期望的响应时间等。在Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。 4.2 back_logback_log 参数控制MySQL监听TCP端口时设置的积压请求栈大小。如果MySql的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默认值为 50 ， 之后的版本默认为 50 + （max_connections / 5）， 但最大不超过900。 如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。 4.3 table_open_cache该参数用来控制所有SQL语句执行线程可打开表缓存的数量， 而在执行SQL语句时，每一个SQL执行线程至少要打开 1 个表缓存。该参数的值应该根据设置的最大连接数 max_connections 以及每个连接执行关联查询中涉及的表的最大数量来设定 ： ​ max_connections x N ； 4.4 thread_cache_size为了加快连接数据库的速度，MySQL 会缓存一定数量的客户服务线程以备重用，通过参数 thread_cache_size 可控制 MySQL 缓存客户服务线程的数量。 4.5 innodb_lock_wait_timeout该参数是用来设置InnoDB 事务等待行锁的时间，默认值是50ms ， 可以根据需要进行动态设置。对于需要快速反馈的业务系统来说，可以将行锁的等待时间调小，以避免事务长时间挂起； 对于后台运行的批量处理程序来说， 可以将行锁的等待时间调大， 以避免发生大的回滚操作。 5. Mysql锁问题5.1 锁概述锁是计算机协调多个进程或线程并发访问某一资源的机制（避免争抢）。 在数据库中，除传统的计算资源（如 CPU、RAM、I/O 等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。 5.2 锁分类从对数据操作的粒度分 ： 1） 表锁：操作时，会锁定整个表。 2） 行锁：操作时，会锁定当前操作行。 从对数据操作的类型分： 1） 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。 2） 写锁（排它锁）：当前操作没有完成之前，它会阻断其他写锁和读锁。 5.3 Mysql 锁相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。下表中罗列出了各存储引擎对锁的支持情况：| 存储引擎 | 表级锁 | 行级锁 | 页面锁 || ——– | —— | —— | —— || MyISAM | 支持 | 不支持 | 不支持 || InnoDB | 支持 | 支持 | 不支持 || MEMORY | 支持 | 不支持 | 不支持 || BDB | 支持 | 不支持 | 支持 | MySQL这3种锁的特性可大致归纳如下 ： 锁类型 特点 表级锁 偏向MyISAM 存储引擎，开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。 行级锁 偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。 页面锁 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。 从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适！仅从锁的角度来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web 应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并查询的应用，如一些在线事务处理（OLTP）系统。 5.2 MyISAM 表锁MyISAM 存储引擎只支持表锁，这也是MySQL开始几个版本中唯一支持的锁类型。 5.2.1 如何加表锁MyISAM 在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。 显示加表锁语法： 加读锁 ： lock table table_name read; 加写锁 ： lock table table_name write； 5.2.2 读锁案例准备环境 create database demo_03 default charset=utf8mb4; use demo_03; CREATE TABLE `tb_book` ( `id` INT(11) auto_increment, `name` VARCHAR(50) DEFAULT NULL, `publish_time` DATE DEFAULT NULL, `status` CHAR(1) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=myisam DEFAULT CHARSET=utf8 ; INSERT INTO tb_book (id, name, publish_time, status) VALUES(NULL,'java编程思想','2088-08-01','1'); INSERT INTO tb_book (id, name, publish_time, status) VALUES(NULL,'solr编程思想','2088-08-08','0'); CREATE TABLE `tb_user` ( `id` INT(11) auto_increment, `name` VARCHAR(50) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=myisam DEFAULT CHARSET=utf8 ; INSERT INTO tb_user (id, name) VALUES(NULL,'令狐冲'); INSERT INTO tb_user (id, name) VALUES(NULL,'田伯光'); 客户端 一 ： 1）获得tb_book 表的读锁 lock table tb_book read; 2） 执行查询操作 select * from tb_book; 可以正常执行 ， 查询出数据。 客户端 二 ： 3） 执行查询操作 select * from tb_book; 客户端 一 ： 4）查询未锁定的表 select name from tb_seller; 客户端 二 ： 5）查询未锁定的表 select name from tb_seller; 可以正常查询出未锁定的表； 客户端 一 ： 6） 执行插入操作 insert into tb_book values(null,'Mysql高级','2088-01-01','1'); 执行插入， 直接报错 ， 由于当前tb_book 获得的是 读锁， 不能执行更新操作。 客户端 二 ： 7） 执行插入操作 insert into tb_book values(null,'Mysql高级','2088-01-01','1'); 当在客户端一中释放锁指令 unlock tables 后 ， 客户端二中的 inesrt 语句 ， 立即执行 ； 5.2.3 写锁案例客户端 一 : 1）获得tb_book 表的写锁 lock table tb_book write ; 2）执行查询操作 select * from tb_book ; 查询操作执行成功； 3）执行更新操作 update tb_book set name = 'java编程思想（第二版）' where id = 1; 更新操作执行成功 ； 客户端 二 : 4）执行查询操作 select * from tb_book ; 当在客户端一中释放锁指令 unlock tables 后 ， 客户端二中的 select 语句 ， 立即执行 ； 5.2.4 结论锁模式的相互兼容性如表中所示： 由上表可见： ​ 1） 对MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求； ​ 2） 对MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作； ​ 简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁，则既会阻塞读，又会阻塞写。 此外，MyISAM 的读写锁调度是写优先，这也是MyISAM不适合做写为主的表的存储引擎的原因。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。 5.2.5 查看锁的争用情况show open tables； In_user : 表当前被查询使用的次数。如果该数为零，则表是打开的，但是当前没有被使用。 Name_locked：表名称是否被锁定。名称锁定用于取消表或对表进行重命名等操作。 show status like 'Table_locks%'; Table_locks_immediate ： 指的是能够立即获得表级锁的次数，每立即获取锁，值加1。 Table_locks_waited ： 指的是不能立即获取表级锁而需要等待的次数，每等待一次，该值加1，此值高说明存在着较为严重的表级锁争用情况。 5.3 InnoDB 行锁5.3.1 行锁介绍行锁特点 ：偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。 InnoDB 与 MyISAM 的最大不同有两点：一是支持事务；二是 采用了行级锁。 5.3.2 背景知识事务及其ACID属性 事务是由一组SQL语句组成的逻辑处理单元。 事务具有以下4个特性，简称为事务ACID属性。 ACID属性 含义 原子性（Atomicity） 事务是一个原子操作单元，其对数据的修改，要么全部成功，要么全部失败。 一致性（Consistent） 在事务开始和完成时，数据都必须保持一致状态。 隔离性（Isolation） 数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的 “独立” 环境下运行。 持久性（Durable） 事务完成之后，对于数据的修改是永久的。 并发事务处理带来的问题 问题 含义 丢失更新（Lost Update） 当两个或多个事务选择同一行，最初的事务修改的值，会被后面的事务修改的值覆盖。 脏读（Dirty Reads） 当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。 不可重复读（Non-Repeatable Reads） 一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现和以前读出的数据不一致。 幻读（Phantom Reads） 一个事务按照相同的查询条件重新读取以前查询过的数据，却发现其他事务插入了满足其查询条件的新数据。 事务隔离级别 为了解决上述提到的事务并发问题，数据库提供一定的事务隔离机制来解决这个问题。数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使用事务在一定程度上“串行化” 进行，这显然与“并发” 是矛盾的。 数据库的隔离级别有4个，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏写、脏读、不可重复读、幻读这几类问题。 隔离级别 丢失更新 脏读 不可重复读 幻读 Read uncommitted × √ √ √ Read committed × × √ √ Repeatable read（默认） × × × √ Serializable × × × × 备注 ： √ 代表可能出现 ， × 代表不会出现 。 Mysql 的数据库的默认隔离级别为 Repeatable read ， 查看方式： show variables like 'tx_isolation'; 5.3.3 InnoDB 的行锁模式InnoDB 实现了以下两种类型的行锁。 共享锁（S）：又称为读锁，简称S锁，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。 排他锁（X）：又称为写锁，简称X锁，排他锁就是不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。 对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)； 对于普通SELECT语句，InnoDB不会加任何锁； 可以通过以下语句显示给记录集加共享锁或排他锁 。 共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE 排他锁（X) ：SELECT * FROM table_name WHERE ... FOR UPDATE 5.3.4 案例准备工作create table test_innodb_lock( id int(11), name varchar(16), sex varchar(1) )engine = innodb default charset=utf8; insert into test_innodb_lock values(1,'100','1'); insert into test_innodb_lock values(3,'3','1'); insert into test_innodb_lock values(4,'400','0'); insert into test_innodb_lock values(5,'500','1'); insert into test_innodb_lock values(6,'600','0'); insert into test_innodb_lock values(7,'700','0'); insert into test_innodb_lock values(8,'800','1'); insert into test_innodb_lock values(9,'900','1'); insert into test_innodb_lock values(1,'200','0'); create index idx_test_innodb_lock_id on test_innodb_lock(id); create index idx_test_innodb_lock_name on test_innodb_lock(name); 5.3.5 行锁基本演示 Session-1 Session-2 关闭自动提交功能 关闭自动提交功能 可以正常的查询出全部的数据 可以正常的查询出全部的数据 查询id 为3的数据 ； 获取id为3的数据 ； 更新id为3的数据，但是不提交； 更新id为3 的数据， 出于等待状态 通过commit， 提交事务 解除阻塞，更新正常进行 以上， 操作的都是同一行的数据，接下来，演示不同行的数据 ： 更新id为3数据，正常的获取到行锁 ， 执行更新 ； 由于与Session-1 操作不是同一行，获取当前行锁，执行更新； 5.3.6 无索引行锁升级为表锁如果不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，实际效果跟表锁一样。 查看当前表的索引 ： show index from test_innodb_lock ; Session-1 Session-2 关闭事务的自动提交 关闭事务的自动提交 执行更新语句 ： 执行更新语句， 但处于阻塞状态： 提交事务： 解除阻塞，执行更新成功 ： 执行提交操作 ： 由于 执行更新时 ， name字段本来为varchar类型， 我们是作为数组类型使用，存在类型转换，索引失效，最终行锁变为表锁 ； 5.3.7 间隙锁危害当我们用范围条件，而不是使用相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据进行加锁； 对于键值在条件范围内但并不存在的记录，叫做 “间隙（GAP）” ， InnoDB也会对这个 “间隙” 加锁，这种锁机制就是所谓的 间隙锁（Next-Key锁） 。 示例 ： Session-1 Session-2 关闭事务自动提交 关闭事务自动提交 根据id范围更新数据 插入id为2的记录， 出于阻塞状态 提交事务 ； 解除阻塞 ， 执行插入操作 ： 提交事务 ： 5.3.8 InnoDB 行锁争用情况show status like 'innodb_row_lock%'; Innodb_row_lock_current_waits: 当前正在等待锁定的数量 Innodb_row_lock_time: 从系统启动到现在锁定总时间长度 Innodb_row_lock_time_avg:每次等待所花平均时长 Innodb_row_lock_time_max:从系统启动到现在等待最长的一次所花的时间 Innodb_row_lock_waits: 系统启动后到现在总共等待的次数 当等待的次数很高，而且每次等待的时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。 5.3.9 总结InnoDB存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面带来了性能损耗可能比表锁会更高一些，但是在整体并发处理能力方面要远远由于MyISAM的表锁的。当系统并发量较高的时候，InnoDB的整体性能和MyISAM相比就会有比较明显的优势。 但是，InnoDB的行级锁同样也有其脆弱的一面，当我们使用不当的时候，可能会让InnoDB的整体性能表现不仅不能比MyISAM高，甚至可能会更差。 优化建议： 尽可能让所有数据检索都能通过索引来完成，避免无索引行锁升级为表锁。 合理设计索引，尽量缩小锁的范围 尽可能减少索引条件，及索引范围，避免间隙锁 尽量控制事务大小，减少锁定资源量和时间长度 尽可使用低级别事务隔离（但是需要业务层面满足需求） 6. 常用SQL技巧6.1 SQL执行顺序编写顺序 SELECT DISTINCT FROM JOIN ON WHERE GROUP BY HAVING ORDER BY LIMIT 执行顺序 FROM &lt;left_table> ON &lt;join_condition> &lt;join_type> JOIN &lt;right_table> WHERE &lt;where_condition> GROUP BY &lt;group_by_list> HAVING &lt;having_condition> SELECT DISTINCT &lt;select list> ORDER BY &lt;order_by_condition> LIMIT &lt;limit_params> 6.2 正则表达式使用正则表达式（Regular Expression）是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。 符号 含义 ^ 在字符串开始处进行匹配 $ 在字符串末尾处进行匹配 . 匹配任意单个字符, 包括换行符 […] 匹配出括号内的任意字符 [^…] 匹配不出括号内的任意字符 a* 匹配零个或者多个a(包括空串) a+ 匹配一个或者多个a(不包括空串) a? 匹配零个或者一个a a1\ a2 匹配a1或a2 a(m) 匹配m个a a(m,) 至少匹配m个a a(m,n) 匹配m个a 到 n个a a(,n) 匹配0到n个a (…) 将模式元素组成单一元素 select * from emp where name regexp '^T'; select * from emp where name regexp '2$'; select * from emp where name regexp '[uvw]'; 6.3 MySQL 常用函数数字函数 函数名称 作 用 ABS 求绝对值 SQRT 求二次方根 MOD 求余数 CEIL 和 CEILING 两个函数功能相同，都是返回不小于参数的最小整数，即向上取整 FLOOR 向下取整，返回值转化为一个BIGINT RAND 生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列 ROUND 对所传参数进行四舍五入 SIGN 返回参数的符号 POW 和 POWER 两个函数的功能相同，都是所传参数的次方的结果值 SIN 求正弦值 ASIN 求反正弦值，与函数 SIN 互为反函数 COS 求余弦值 ACOS 求反余弦值，与函数 COS 互为反函数 TAN 求正切值 ATAN 求反正切值，与函数 TAN 互为反函数 COT 求余切值 字符串函数 函数名称 作 用 LENGTH 计算字符串长度函数，返回字符串的字节长度 CONCAT 合并字符串函数，返回结果为连接参数产生的字符串，参数可以使一个或多个 INSERT 替换字符串函数 LOWER 将字符串中的字母转换为小写 UPPER 将字符串中的字母转换为大写 LEFT 从左侧字截取符串，返回字符串左边的若干个字符 RIGHT 从右侧字截取符串，返回字符串右边的若干个字符 TRIM 删除字符串左右两侧的空格 REPLACE 字符串替换函数，返回替换后的新字符串 SUBSTRING 截取字符串，返回从指定位置开始的指定长度的字符换 REVERSE 字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串 日期函数 函数名称 作 用 CURDATE 和 CURRENT_DATE 两个函数作用相同，返回当前系统的日期值 CURTIME 和 CURRENT_TIME 两个函数作用相同，返回当前系统的时间值 NOW 和 SYSDATE 两个函数作用相同，返回当前系统的日期和时间值 MONTH 获取指定日期中的月份 MONTHNAME 获取指定日期中的月份英文名称 DAYNAME 获取指定曰期对应的星期几的英文名称 DAYOFWEEK 获取指定日期对应的一周的索引位置值 WEEK 获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53 DAYOFYEAR 获取指定曰期是一年中的第几天，返回值范围是1~366 DAYOFMONTH 获取指定日期是一个月中是第几天，返回值范围是1~31 YEAR 获取年份，返回值范围是 1970〜2069 TIME_TO_SEC 将时间参数转换为秒数 SEC_TO_TIME 将秒数转换为时间，与TIME_TO_SEC 互为反函数 DATE_ADD 和 ADDDATE 两个函数功能相同，都是向日期添加指定的时间间隔 DATE_SUB 和 SUBDATE 两个函数功能相同，都是向日期减去指定的时间间隔 ADDTIME 时间加法运算，在原始时间上添加指定的时间 SUBTIME 时间减法运算，在原始时间上减去指定的时间 DATEDIFF 获取两个日期之间间隔，返回参数 1 减去参数 2 的值 DATE_FORMAT 格式化指定的日期，根据参数返回指定格式的值 WEEKDAY 获取指定日期在一周内的对应的工作日索引 聚合函数 函数名称 作用 MAX 查询指定列的最大值 MIN 查询指定列的最小值 COUNT 统计查询结果的行数 SUM 求和，返回指定列的总和 AVG 求平均值，返回指定列数据的平均值 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL数据库优化之组合拳(三)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库优化之组合拳(二)]]></title>
    <url>%2F2021%2F01%2F23%2Fmysql-advanced-2%2F</url>
    <content type="text"><![CDATA[非原创图文,图文来源于黑马官网,此处仅作为备份学习 MySQL数据库优化总概 组合拳（一） 🚩组合拳（二） 组合拳（三） 组合拳（四） 索引 体系结构 应用优化 MySQL 常用工具 视图 存储引擎 查询缓存优化 MySQL 日志 存储过程和函数 优化SQL步骤 内存管理及优化 MySQL 主从复制 触发器 索引使用 MySQL锁问题 SQL优化 常用SQL技巧 1. Mysql的体系结构概览 整个MySQL Server由以下组成 Connection Pool : 连接池组件 Management Services &amp; Utilities : 管理服务和工具组件 SQL Interface : SQL接口组件 Parser : 查询分析器组件 Optimizer : 优化器组件 Caches &amp; Buffers : 缓冲池组件 Pluggable Storage Engines : 存储引擎 File System : 文件系统 1） 连接层 最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于 TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 2） 服务层 第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。 3） 引擎层 存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。 4）存储层 数据存储层， 主要是将数据存储在文件系统之上，并完成与存储引擎的交互。 和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。 2. 存储引擎2.1 存储引擎概述​ 和大多数的数据库不同, MySQL中有一个存储引擎的概念, 针对不同的存储需求可以选择最优的存储引擎。 ​ 存储引擎就是存储数据，建立索引，更新查询数据等等技术的实现方式 。存储引擎是基于表的，而不是基于库的。所以存储引擎也可被称为表类型。 ​ Oracle，SqlServer等数据库只有一种存储引擎。MySQL提供了插件式的存储引擎架构。所以MySQL存在多种存储引擎，可以根据需要使用相应引擎，或者编写存储引擎。 ​ MySQL5.0支持的存储引擎包含 ： InnoDB 、MyISAM 、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等，其中InnoDB和BDB提供事务安全表，其他存储引擎是非事务安全表。 可以通过指定 show engines ， 来查询当前数据库支持的存储引擎 ： 创建新表时如果不指定存储引擎，那么系统就会使用默认的存储引擎，MySQL5.5之前的默认存储引擎是MyISAM，5.5之后就改为了InnoDB。 查看Mysql数据库默认的存储引擎 ， 指令 ： show variables like '%storage_engine%' ； 2.2 各种存储引擎特性下面重点介绍几种常用的存储引擎， 并对比各个存储引擎之间的区别， 如下表所示 ： 特点 InnoDB MyISAM MEMORY MERGE NDB 存储限制 64TB 有 有 没有 有 事务安全 ==支持== 锁机制 ==行锁(适合高并发)== ==表锁== 表锁 表锁 行锁 B树索引 支持 支持 支持 支持 支持 哈希索引 支持 全文索引 支持(5.6版本之后) 支持 集群索引 支持 数据索引 支持 支持 支持 索引缓存 支持 支持 支持 支持 支持 数据可压缩 支持 空间使用 高 低 N/A 低 低 内存使用 高 低 中等 低 高 批量插入速度 低 高 高 高 高 支持外键 ==支持== 下面我们将重点介绍最长使用的两种存储引擎： InnoDB、MyISAM ， 另外两种 MEMORY、MERGE ， 了解即可。 2.2.1 InnoDB​ InnoDB存储引擎是Mysql的默认存储引擎。InnoDB存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引。 InnoDB存储引擎不同于其他存储引擎的特点 ： 事务控制 create table goods_innodb( id int NOT NULL AUTO_INCREMENT, name varchar(20) NOT NULL, primary key(id) )ENGINE=innodb DEFAULT CHARSET=utf8; start transaction; insert into goods_innodb(id,name)values(null,'Meta20'); commit; 测试，发现在InnoDB中是存在事务的 ； 外键约束 ​ MySQL支持外键的存储引擎只有InnoDB ， 在创建外键的时候， 要求父表必须有对应的索引 ， 子表在创建外键的时候， 也会自动的创建对应的索引。 ​ 下面两张表中 ， country_innodb是父表 ， country_id为主键索引，city_innodb表是子表，country_id字段为外键，对应于country_innodb表的主键country_id 。 create table country_innodb( country_id int NOT NULL AUTO_INCREMENT, country_name varchar(100) NOT NULL, primary key(country_id) )ENGINE=InnoDB DEFAULT CHARSET=utf8; create table city_innodb( city_id int NOT NULL AUTO_INCREMENT, city_name varchar(50) NOT NULL, country_id int NOT NULL, primary key(city_id), key idx_fk_country_id(country_id), CONSTRAINT `fk_city_country` FOREIGN KEY(country_id) REFERENCES country_innodb(country_id) ON DELETE RESTRICT ON UPDATE CASCADE )ENGINE=InnoDB DEFAULT CHARSET=utf8; insert into country_innodb values(null,'China'),(null,'America'),(null,'Japan'); insert into city_innodb values(null,'Xian',1),(null,'NewYork',2),(null,'BeiJing',1); 在创建索引时， 可以指定在删除、更新父表时，对子表进行的相应操作，包括 RESTRICT、CASCADE、SET NULL 和 NO ACTION。 RESTRICT和NO ACTION相同， 是指限制在子表有关联记录的情况下， 父表不能更新； CASCADE表示父表在更新或者删除时，更新或者删除子表对应的记录； SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被SET NULL 。 针对上面创建的两个表， 子表的外键指定是ON DELETE RESTRICT ON UPDATE CASCADE 方式的， 那么在主表删除记录的时候， 如果子表有对应记录， 则不允许删除， 主表在更新记录的时候， 如果子表有对应记录， 则子表对应更新 。 表中数据如下图所示 ： 外键信息可以使用如下两种方式查看 ： show create table city_innodb ; 删除country_id为1 的country数据： delete from country_innodb where country_id = 1; 更新主表country表的字段 country_id : update country_innodb set country_id = 100 where country_id = 1; 更新后， 子表的数据信息为 ： 存储方式 InnoDB 存储表和索引有以下两种方式 ： ①. 使用共享表空间存储， 这种方式创建的表的表结构保存在.frm文件中， 数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path定义的表空间中，可以是多个文件。 ②. 使用多表空间存储， 这种方式创建的表的表结构仍然存在 .frm 文件中，但是每个表的数据和索引单独保存在 .ibd 中。 2.2.2 MyISAM​ MyISAM 不支持事务、也不支持外键，其优势是访问的速度快，对事务的完整性没有要求或者以SELECT、INSERT为主的应用基本上都可以使用这个引擎来创建表 。有以下两个比较重要的特点： 不支持事务 create table goods_myisam( id int NOT NULL AUTO_INCREMENT, name varchar(20) NOT NULL, primary key(id) )ENGINE=myisam DEFAULT CHARSET=utf8; 通过测试，我们发现，在MyISAM存储引擎中，是没有事务控制的 ； 文件存储方式 每个MyISAM在磁盘上存储成3个文件，其文件名都和表名相同，但拓展名分别是 ： .frm (存储表定义)； .MYD(MYData , 存储数据)； .MYI(MYIndex , 存储索引)； 2.2.3 MEMORY​ Memory存储引擎将表的数据存放在内存中。每个MEMORY表实际对应一个磁盘文件，格式是.frm ，该文件中只存储表的结构，而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。MEMORY 类型的表访问非常地快，因为他的数据是存放在内存中的，并且默认使用HASH索引 ， 但是服务一旦关闭，表中的数据就会丢失。 2.2.4 MERGE​ MERGE存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，MERGE表本身并没有存储数据，对MERGE类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行的。 ​ 对于MERGE类型表的插入操作，是通过INSERT_METHOD子句定义插入的表，可以有3个不同的值，使用FIRST 或 LAST 值使得插入操作被相应地作用在第一或者最后一个表上，不定义这个子句或者定义为NO，表示不能对这个MERGE表执行插入操作。 ​ 可以对MERGE表进行DROP操作，但是这个操作只是删除MERGE表的定义，对内部的表是没有任何影响的。 下面是一个创建和使用MERGE表的示例 ： 1）. 创建3个测试表 order_1990, order_1991, order_all , 其中order_all是前两个表的MERGE表 ： create table order_1990( order_id int , order_money double(10,2), order_address varchar(50), primary key (order_id) )engine = myisam default charset=utf8; create table order_1991( order_id int , order_money double(10,2), order_address varchar(50), primary key (order_id) )engine = myisam default charset=utf8; create table order_all( order_id int , order_money double(10,2), order_address varchar(50), primary key (order_id) )engine = merge union = (order_1990,order_1991) INSERT_METHOD=LAST default charset=utf8; 2）. 分别向两张表中插入记录 insert into order_1990 values(1,100.0,'北京'); insert into order_1990 values(2,100.0,'上海'); insert into order_1991 values(10,200.0,'北京'); insert into order_1991 values(11,200.0,'上海'); 3）. 查询3张表中的数据。 order_1990中的数据 ： order_1991中的数据 ： order_all中的数据 ： ​ 4）. 往order_all中插入一条记录 ，由于在MERGE表定义时，INSERT_METHOD 选择的是LAST，那么插入的数据会想最后一张表中插入。 insert into order_all values(100,10000.0,'西安'); 2.3 存储引擎的选择​ 在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。以下是几种常用的存储引擎的使用环境。 InnoDB : 是Mysql的默认存储引擎，用于事务处理应用程序，支持外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询意外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。InnoDB存储引擎除了有效的降低由于删除和更新导致的锁定， 还可以确保事务的完整提交和回滚，对于类似于计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB是最合适的选择。 MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。 MEMORY：将所有数据保存在RAM中，在需要快速定位记录和其他类似数据环境下，可以提供几块的访问。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。MEMORY表通常用于更新不太频繁的小表，用以快速得到访问结果。 MERGE：用于将一系列等同的MyISAM表以逻辑方式组合在一起，并作为一个对象引用他们。MERGE表的优点在于可以突破对单个MyISAM表的大小限制，并且通过将不同的表分布在多个磁盘上，可以有效的改善MERGE表的访问效率。这对于存储诸如数据仓储等VLDB环境十分合适。 3. 优化SQL步骤在应用的的开发过程中，由于初期数据量小，开发人员写 SQL 语句时更重视功能上的实现，但是当应用系统正式上线后，随着生产数据量的急剧增长，很多 SQL 语句开始逐渐显露出性能问题，对生产的影响也越来越大，此时这些有问题的 SQL 语句就成为整个系统性能的瓶颈，因此我们必须要对它们进行优化，本章将详细介绍在 MySQL 中优化 SQL 语句的方法。 当面对一个有 SQL 性能问题的数据库时，我们应该从何处入手来进行系统的分析，使得能够尽快定位问题 SQL 并尽快解决问题。 3.1 查看SQL执行频率MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。show [session|global] status 可以根据需要加上参数“session”或者“global”来显示 session 级（当前连接）的计结果和 global 级（自数据库上次启动至今）的统计结果。如果不写，默认使用参数是“session”。 下面的命令显示了当前 session 中所有统计参数的值： show status like 'Com_______'; show status like 'Innodb_rows_%'; Com_xxx 表示每个 xxx 语句执行的次数，我们通常比较关心的是以下几个统计参数。 参数 含义 Com_select 执行 select 操作的次数，一次查询只累加 1。 Com_insert 执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。 Com_update 执行 UPDATE 操作的次数。 Com_delete 执行 DELETE 操作的次数。 Innodb_rows_read select 查询返回的行数。 Innodb_rows_inserted 执行 INSERT 操作插入的行数。 Innodb_rows_updated 执行 UPDATE 操作更新的行数。 Innodb_rows_deleted 执行 DELETE 操作删除的行数。 Connections 试图连接 MySQL 服务器的次数。 Uptime 服务器工作时间。 Slow_queries 慢查询的次数。 Com_*** : 这些参数对于所有存储引擎的表操作都会进行累计。 Innodb_*** : 这几个参数只是针对InnoDB 存储引擎的，累加的算法也略有不同。 3.2 定位低效率执行SQL可以通过以下两种方式定位执行效率较低的 SQL 语句。 慢查询日志 : 通过慢查询日志定位那些执行效率较低的 SQL 语句，用–log-slow-queries[=file_name]选项启动时，mysqld 写一个包含所有执行时间超过 long_query_time 秒的 SQL 语句的日志文件。具体可以查看本书第 26 章中日志管理的相关部分。 show processlist : 慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用show processlist命令查看当前MySQL在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。 1） id列，用户登录mysql时，系统分配的"connection_id"，可以使用函数connection_id()查看 2） user列，显示当前用户。如果不是root，这个命令就只显示用户权限范围的sql语句 3） host列，显示这个语句是从哪个ip的哪个端口上发的，可以用来跟踪出现问题语句的用户 4） db列，显示这个进程目前连接的是哪个数据库 5） command列，显示当前连接的执行的命令，一般取值为休眠（sleep），查询（query），连接（connect）等 6） time列，显示这个状态持续的时间，单位是秒 7） state列，显示使用当前连接的sql语句的状态，很重要的列。state描述的是语句执行中的某一个状态。一个sql语句，以查询为例，可能需要经过copying to tmp table、sorting result、sending data等状态才可以完成 8） info列，显示这个sql语句，是判断问题语句的一个重要依据 3.3 explain分析执行计划通过以上步骤查询到效率低的 SQL 语句后，可以通过 EXPLAIN或者 DESC命令获取 MySQL如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。 查询SQL语句的执行计划 ： explain select * from tb_item where id = 1; explain select * from tb_item where title = '阿尔卡特 (OT-979) 冰川白 联通3G手机3'; 字段 含义 id select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。 select_type 表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个 SELECT）等 table 输出结果集的表 type 表示表的连接类型，性能由好到差的连接类型为( system —&gt; const —–&gt; eq_ref ——&gt; ref ——-&gt; ref_or_null—-&gt; index_merge —&gt; index_subquery —–&gt; range —–&gt; index ——&gt; all ) possible_keys 表示查询时，可能使用的索引 key 表示实际使用的索引 key_len 索引字段的长度 rows 扫描行的数量 extra 执行情况的说明和描述 3.3.1 环境准备 CREATE TABLE `t_role` ( `id` varchar(32) NOT NULL, `role_name` varchar(255) DEFAULT NULL, `role_code` varchar(255) DEFAULT NULL, `description` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `unique_role_name` (`role_name`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `t_user` ( `id` varchar(32) NOT NULL, `username` varchar(45) NOT NULL, `password` varchar(96) NOT NULL, `name` varchar(45) NOT NULL, PRIMARY KEY (`id`), UNIQUE KEY `unique_user_username` (`username`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `user_role` ( `id` int(11) NOT NULL auto_increment , `user_id` varchar(32) DEFAULT NULL, `role_id` varchar(32) DEFAULT NULL, PRIMARY KEY (`id`), KEY `fk_ur_user_id` (`user_id`), KEY `fk_ur_role_id` (`role_id`), CONSTRAINT `fk_ur_role_id` FOREIGN KEY (`role_id`) REFERENCES `t_role` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT `fk_ur_user_id` FOREIGN KEY (`user_id`) REFERENCES `t_user` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION ) ENGINE=InnoDB DEFAULT CHARSET=utf8; insert into `t_user` (`id`, `username`, `password`, `name`) values('1','super','$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe','超级管理员'); insert into `t_user` (`id`, `username`, `password`, `name`) values('2','admin','$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe','系统管理员'); insert into `t_user` (`id`, `username`, `password`, `name`) values('3','itcast','$2a$10$8qmaHgUFUAmPR5pOuWhYWOr291WJYjHelUlYn07k5ELF8ZCrW0Cui','test02'); insert into `t_user` (`id`, `username`, `password`, `name`) values('4','stu1','$2a$10$pLtt2KDAFpwTWLjNsmTEi.oU1yOZyIn9XkziK/y/spH5rftCpUMZa','学生1'); insert into `t_user` (`id`, `username`, `password`, `name`) values('5','stu2','$2a$10$nxPKkYSez7uz2YQYUnwhR.z57km3yqKn3Hr/p1FR6ZKgc18u.Tvqm','学生2'); insert into `t_user` (`id`, `username`, `password`, `name`) values('6','t1','$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe','老师1'); INSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES('5','学生','student','学生'); INSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES('7','老师','teacher','老师'); INSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES('8','教学管理员','teachmanager','教学管理员'); INSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES('9','管理员','admin','管理员'); INSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES('10','超级管理员','super','超级管理员'); INSERT INTO user_role(id,user_id,role_id) VALUES(NULL, '1', '5'),(NULL, '1', '7'),(NULL, '2', '8'),(NULL, '3', '9'),(NULL, '4', '8'),(NULL, '5', '10') ; 3.3.2 explain 之 idid 字段是 select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。id 情况有三种 ： 1） id 相同表示加载表的顺序是从上到下。 explain select * from t_role r, t_user u, user_role ur where r.id = ur.role_id and u.id = ur.user_id ; 2） id 不同id值越大，优先级越高，越先被执行。 EXPLAIN SELECT * FROM t_role WHERE id = (SELECT role_id FROM user_role WHERE user_id = (SELECT id FROM t_user WHERE username = 'stu1')) 3） id 有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。 EXPLAIN SELECT * FROM t_role r , (SELECT * FROM user_role ur WHERE ur.`user_id` = '2') a WHERE r.id = a.role_id ; 3.3.3 explain 之 select_type 表示 SELECT 的类型，常见的取值，如下表所示： select_type 含义 SIMPLE 简单的select查询，查询中不包含子查询或者UNION PRIMARY 查询中若包含任何复杂的子查询，最外层查询标记为该标识 SUBQUERY 在SELECT 或 WHERE 列表中包含了子查询 DERIVED 在FROM 列表中包含的子查询，被标记为 DERIVED（衍生） MYSQL会递归执行这些子查询，把结果放在临时表中 UNION 若第二个SELECT出现在UNION之后，则标记为UNION ； 若UNION包含在FROM子句的子查询中，外层SELECT将被标记为 ： DERIVED UNION RESULT 从UNION表获取结果的SELECT 3.3.4 explain 之 table展示这一行的数据是关于哪一张表的 3.3.5 explain 之 typetype 显示的是访问类型，是较为重要的一个指标，可取值为： type 含义 NULL MySQL不访问任何表，索引，直接返回结果 system 表只有一行记录(等于系统表)，这是const类型的特例，一般不会出现 const 表示通过索引一次就找到了，const 用于比较primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL 就能将该查询转换为一个常亮。const于将 “主键” 或 “唯一” 索引的所有部分与常量值进行比较 eq_ref 类似ref，区别在于使用的是唯一索引，使用主键的关联查询，关联查询出的记录只有一条。常见于主键或唯一索引扫描 ref 非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，返回所有匹配某个单独值的所有行（多个） range 只检索给定返回的行，使用一个索引来选择行。 where 之后出现 between ， &lt; , &gt; , in 等操作。 index index 与 ALL的区别为 index 类型只是遍历了索引树， 通常比ALL 快， ALL 是遍历数据文件。 all 将遍历全表以找到匹配的行 结果值从最好到最坏以此是： NULL &gt; system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL ==一般来说， 我们需要保证查询至少达到 range 级别， 最好达到ref 。== 3.3.6 explain 之 keypossible_keys : 显示可能应用在这张表的索引， 一个或多个。 key ： 实际使用的索引， 如果为NULL， 则没有使用索引。 key_len : 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。 3.3.7 explain 之 rows扫描行的数量。 3.3.8 explain 之 extra其他的额外的执行计划信息，在该列展示 。 extra 含义 using filesort 说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取， 称为 “文件排序”, 效率低。 using temporary 使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于 order by 和 group by； 效率低 using index 表示相应的select操作使用了覆盖索引， 避免访问表的数据行， 效率不错。 3.4 show profile分析SQLMysql从5.0.37版本开始增加了对 show profiles 和 show profile 语句的支持。show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。 通过 have_profiling 参数，能够看到当前MySQL是否支持profile： 默认profiling是关闭的，可以通过set语句在Session级别开启profiling： set profiling=1; //开启profiling 开关; 通过profile，我们能够更清楚地了解SQL执行的过程。 首先，我们可以执行一系列的操作，如下图所示： show databases; use db01; show tables; select * from tb_item where id &lt; 5; select count(*) from tb_item; 执行完上述命令之后，再执行show profiles 指令， 来查看SQL语句执行的耗时： 通过show profile for query query_id 语句可以查看到该SQL执行过程中每个线程的状态和消耗的时间： TIP ： Sending data 状态表示MySQL线程开始访问数据行并把结果返回给客户端，而不仅仅是返回个客户端。由于在Sending data状态下，MySQL线程往往需要做大量的磁盘读取操作，所以经常是整各查询中耗时最长的状态。 在获取到最消耗时间的线程状态后，MySQL支持进一步选择all、cpu、block io 、context switch、page faults等明细类型类查看MySQL在使用什么资源上耗费了过高的时间。例如，选择查看CPU的耗费时间 ： 字段 含义 Status sql 语句执行的状态 Duration sql 执行过程中每一个步骤的耗时 CPU_user 当前用户占有的cpu CPU_system 系统占有的cpu 3.5 trace分析优化器执行计划MySQL5.6提供了对SQL的跟踪trace, 通过trace文件能够进一步了解为什么优化器选择A计划, 而不是选择B计划。 打开trace ， 设置格式为 JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。 SET optimizer_trace="enabled=on",end_markers_in_json=on; set optimizer_trace_max_mem_size=1000000; 执行SQL语句 ： select * from tb_item where id &lt; 4; 最后， 检查information_schema.optimizer_trace就可以知道MySQL是如何执行SQL的 ： select * from information_schema.optimizer_trace\G; *************************** 1. row *************************** QUERY: select * from tb_item where id &lt; 4 TRACE: { "steps": [ { "join_preparation": { "select#": 1, "steps": [ { "expanded_query": "/* select#1 */ select `tb_item`.`id` AS `id`,`tb_item`.`title` AS `title`,`tb_item`.`price` AS `price`,`tb_item`.`num` AS `num`,`tb_item`.`categoryid` AS `categoryid`,`tb_item`.`status` AS `status`,`tb_item`.`sellerid` AS `sellerid`,`tb_item`.`createtime` AS `createtime`,`tb_item`.`updatetime` AS `updatetime` from `tb_item` where (`tb_item`.`id` &lt; 4)" } ] /* steps */ } /* join_preparation */ }, { "join_optimization": { "select#": 1, "steps": [ { "condition_processing": { "condition": "WHERE", "original_condition": "(`tb_item`.`id` &lt; 4)", "steps": [ { "transformation": "equality_propagation", "resulting_condition": "(`tb_item`.`id` &lt; 4)" }, { "transformation": "constant_propagation", "resulting_condition": "(`tb_item`.`id` &lt; 4)" }, { "transformation": "trivial_condition_removal", "resulting_condition": "(`tb_item`.`id` &lt; 4)" } ] /* steps */ } /* condition_processing */ }, { "table_dependencies": [ { "table": "`tb_item`", "row_may_be_null": false, "map_bit": 0, "depends_on_map_bits": [ ] /* depends_on_map_bits */ } ] /* table_dependencies */ }, { "ref_optimizer_key_uses": [ ] /* ref_optimizer_key_uses */ }, { "rows_estimation": [ { "table": "`tb_item`", "range_analysis": { "table_scan": { "rows": 9816098, "cost": 2.04e6 } /* table_scan */, "potential_range_indices": [ { "index": "PRIMARY", "usable": true, "key_parts": [ "id" ] /* key_parts */ } ] /* potential_range_indices */, "setup_range_conditions": [ ] /* setup_range_conditions */, "group_index_range": { "chosen": false, "cause": "not_group_by_or_distinct" } /* group_index_range */, "analyzing_range_alternatives": { "range_scan_alternatives": [ { "index": "PRIMARY", "ranges": [ "id &lt; 4" ] /* ranges */, "index_dives_for_eq_ranges": true, "rowid_ordered": true, "using_mrr": false, "index_only": false, "rows": 3, "cost": 1.6154, "chosen": true } ] /* range_scan_alternatives */, "analyzing_roworder_intersect": { "usable": false, "cause": "too_few_roworder_scans" } /* analyzing_roworder_intersect */ } /* analyzing_range_alternatives */, "chosen_range_access_summary": { "range_access_plan": { "type": "range_scan", "index": "PRIMARY", "rows": 3, "ranges": [ "id &lt; 4" ] /* ranges */ } /* range_access_plan */, "rows_for_plan": 3, "cost_for_plan": 1.6154, "chosen": true } /* chosen_range_access_summary */ } /* range_analysis */ } ] /* rows_estimation */ }, { "considered_execution_plans": [ { "plan_prefix": [ ] /* plan_prefix */, "table": "`tb_item`", "best_access_path": { "considered_access_paths": [ { "access_type": "range", "rows": 3, "cost": 2.2154, "chosen": true } ] /* considered_access_paths */ } /* best_access_path */, "cost_for_plan": 2.2154, "rows_for_plan": 3, "chosen": true } ] /* considered_execution_plans */ }, { "attaching_conditions_to_tables": { "original_condition": "(`tb_item`.`id` &lt; 4)", "attached_conditions_computation": [ ] /* attached_conditions_computation */, "attached_conditions_summary": [ { "table": "`tb_item`", "attached": "(`tb_item`.`id` &lt; 4)" } ] /* attached_conditions_summary */ } /* attaching_conditions_to_tables */ }, { "refine_plan": [ { "table": "`tb_item`", "access_type": "range" } ] /* refine_plan */ } ] /* steps */ } /* join_optimization */ }, { "join_execution": { "select#": 1, "steps": [ ] /* steps */ } /* join_execution */ } ] /* steps */ } 4. 索引的使用索引是数据库优化最常用也是最重要的手段之一, 通过索引通常可以帮助用户解决大多数的MySQL的性能优化问题。 4.1 验证索引提升查询效率在我们准备的表结构tb_item 中， 一共存储了 300 万记录； A. 根据ID查询 select * from tb_item where id = 1999\G; 查询速度很快， 接近0s ， 主要的原因是因为id为主键， 有索引； 2). 根据 title 进行精确查询 select * from tb_item where title = 'iphoneX 移动3G 32G941'\G; 查看SQL语句的执行计划 ： 处理方案 ， 针对title字段， 创建索引 ： create index idx_item_title on tb_item(title); 索引创建完成之后，再次进行查询 ： 通过explain ， 查看执行计划，执行SQL时使用了刚才创建的索引 4.2 索引的使用4.2.1 准备环境create table `tb_seller` ( `sellerid` varchar (100), `name` varchar (100), `nickname` varchar (50), `password` varchar (60), `status` varchar (1), `address` varchar (100), `createtime` datetime, primary key(`sellerid`) )engine=innodb default charset=utf8mb4; insert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('alibaba','阿里巴巴','阿里小店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00'); insert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('baidu','百度科技有限公司','百度小店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00'); insert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('huawei','华为科技有限公司','华为小店','e10adc3949ba59abbe56e057f20f883e','0','北京市','2088-01-01 12:00:00'); insert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('itcast','传智播客教育科技有限公司','传智播客','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00'); insert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('itheima','黑马程序员','黑马程序员','e10adc3949ba59abbe56e057f20f883e','0','北京市','2088-01-01 12:00:00'); insert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('luoji','罗技科技有限公司','罗技小店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00'); insert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('oppo','OPPO科技有限公司','OPPO官方旗舰店','e10adc3949ba59abbe56e057f20f883e','0','北京市','2088-01-01 12:00:00'); insert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('ourpalm','掌趣科技股份有限公司','掌趣小店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00'); insert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('qiandu','千度科技','千度小店','e10adc3949ba59abbe56e057f20f883e','2','北京市','2088-01-01 12:00:00'); insert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('sina','新浪科技有限公司','新浪官方旗舰店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00'); insert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('xiaomi','小米科技','小米官方旗舰店','e10adc3949ba59abbe56e057f20f883e','1','西安市','2088-01-01 12:00:00'); insert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values('yijia','宜家家居','宜家家居旗舰店','e10adc3949ba59abbe56e057f20f883e','1','北京市','2088-01-01 12:00:00'); create index idx_seller_name_sta_addr on tb_seller(name,status,address); 4.2.2 避免索引失效1). 全值匹配 ，对索引中所有列都指定具体值。 改情况下，索引生效，执行效率高。 explain select * from tb_seller where name='小米科技' and status='1' and address='北京市'\G; 2). 最左前缀法则 如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。 匹配最左前缀法则，走索引： 违法最左前缀法则 ， 索引失效： 如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效： 3). 范围查询右边的列，不能使用索引 。 根据前面的两个字段name ， status 查询是走索引的， 但是最后一个条件address 没有用到索引。 4). 不要在索引列上进行运算操作， 索引将失效。 5). 字符串不加单引号，造成索引失效。 由于，在查询是，没有对字符串加单引号，MySQL的查询优化器，会自动的进行类型转换，造成索引失效。 6). 尽量使用覆盖索引，避免select * 尽量使用覆盖索引（只访问索引的查询（索引列完全包含查询列）），减少select * 。 如果查询列，超出索引列，也会降低性能。 TIP : using index ：使用覆盖索引的时候就会出现 using where：在查找使用索引的情况下，需要回表去查询所需的数据 using index condition：查找使用了索引，但是需要回表查询数据 using index ; using where：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据 7). 用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。 示例，name字段是索引列 ， 而createtime不是索引列，中间是or进行连接是不走索引的 ： explain select * from tb_seller where name='黑马程序员' or createtime = '2088-01-01 12:00:00'\G; 8). 以%开头的Like模糊查询，索引失效。 如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。 解决方案 ： 通过覆盖索引来解决 9). 如果MySQL评估使用索引比全表更慢，则不使用索引。 10). is NULL ， is NOT NULL 有时索引失效。 11). in 走索引， not in 索引失效。 12). 单列索引和复合索引。 尽量使用复合索引，而少使用单列索引 。 创建复合索引 create index idx_name_sta_address on tb_seller(name, status, address); 就相当于创建了三个索引 ： name name + status name + status + address 创建单列索引 create index idx_seller_name on tb_seller(name); create index idx_seller_status on tb_seller(status); create index idx_seller_address on tb_seller(address); 数据库会选择一个最优的索引（辨识度最高索引）来使用，并不会使用全部索引 。 4.3 查看索引使用情况show status like 'Handler_read%'; show global status like 'Handler_read%'; Handler_read_first：索引中第一条被读的次数。如果较高，表示服务器正执行大量全索引扫描（这个值越低越好）。 Handler_read_key：如果索引正在工作，这个值代表一个行被索引值读的次数，如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好）。 Handler_read_next ：按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。 Handler_read_prev：按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY ... DESC。 Handler_read_rnd ：根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救。 Handler_read_rnd_next：在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。 5. SQL优化5.1 大批量插入数据环境准备 ： CREATE TABLE `tb_user_2` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(45) NOT NULL, `password` varchar(96) NOT NULL, `name` varchar(45) NOT NULL, `birthday` datetime DEFAULT NULL, `sex` char(1) DEFAULT NULL, `email` varchar(45) DEFAULT NULL, `phone` varchar(45) DEFAULT NULL, `qq` varchar(32) DEFAULT NULL, `status` varchar(32) NOT NULL COMMENT '用户状态', `create_time` datetime NOT NULL, `update_time` datetime DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `unique_user_username` (`username`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 ; 当使用load 命令导入数据的时候，适当的设置可以提高导入的效率。 对于 InnoDB 类型的表，有以下几种方式可以提高导入的效率： 1） 主键顺序插入 因为InnoDB类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果InnoDB表没有主键，那么系统会自动默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这点，来提高导入数据的效率。 脚本文件介绍 : sql1.log ----&gt; 主键有序 sql2.log ----&gt; 主键无序 插入ID顺序排列数据： 插入ID无序排列数据： 2） 关闭唯一性校验 在导入数据前执行 SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行SET UNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率。 3） 手动提交事务 如果应用使用自动提交的方式，建议在导入前执行 SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行 SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。 5.2 优化insert语句当进行数据的insert操作的时候，可以考虑采用以下几种优化方案。 如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句，这种方式将大大的缩减客户端与数据库之间的连接、关闭等消耗。使得效率比分开执行的单个insert语句快。 示例， 原始方式为： insert into tb_test values(1,'Tom'); insert into tb_test values(2,'Cat'); insert into tb_test values(3,'Jerry'); 优化后的方案为 ： insert into tb_test values(1,'Tom'),(2,'Cat')，(3,'Jerry'); 在事务中进行数据插入。 start transaction; insert into tb_test values(1,'Tom'); insert into tb_test values(2,'Cat'); insert into tb_test values(3,'Jerry'); commit; 数据有序插入 insert into tb_test values(4,'Tim'); insert into tb_test values(1,'Tom'); insert into tb_test values(3,'Jerry'); insert into tb_test values(5,'Rose'); insert into tb_test values(2,'Cat'); 优化后 insert into tb_test values(1,'Tom'); insert into tb_test values(2,'Cat'); insert into tb_test values(3,'Jerry'); insert into tb_test values(4,'Tim'); insert into tb_test values(5,'Rose'); 5.3 优化order by语句5.3.1 环境准备CREATE TABLE `emp` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(100) NOT NULL, `age` int(3) NOT NULL, `salary` int(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; insert into `emp` (`id`, `name`, `age`, `salary`) values('1','Tom','25','2300'); insert into `emp` (`id`, `name`, `age`, `salary`) values('2','Jerry','30','3500'); insert into `emp` (`id`, `name`, `age`, `salary`) values('3','Luci','25','2800'); insert into `emp` (`id`, `name`, `age`, `salary`) values('4','Jay','36','3500'); insert into `emp` (`id`, `name`, `age`, `salary`) values('5','Tom2','21','2200'); insert into `emp` (`id`, `name`, `age`, `salary`) values('6','Jerry2','31','3300'); insert into `emp` (`id`, `name`, `age`, `salary`) values('7','Luci2','26','2700'); insert into `emp` (`id`, `name`, `age`, `salary`) values('8','Jay2','33','3500'); insert into `emp` (`id`, `name`, `age`, `salary`) values('9','Tom3','23','2400'); insert into `emp` (`id`, `name`, `age`, `salary`) values('10','Jerry3','32','3100'); insert into `emp` (`id`, `name`, `age`, `salary`) values('11','Luci3','26','2900'); insert into `emp` (`id`, `name`, `age`, `salary`) values('12','Jay3','37','4500'); create index idx_emp_age_salary on emp(age,salary); 5.3.2 两种排序方式1). 第一种是通过对返回数据进行排序，也就是通常说的 filesort 排序，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。 2). 第二种通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。 多字段排序 了解了MySQL的排序方式，优化目标就清晰了：尽量减少额外的排序，通过索引直接返回有序数据。where 条件和Order by 使用相同的索引，并且Order By 的顺序和索引顺序相同， 并且Order by 的字段都是升序，或者都是降序。否则肯定需要额外的操作，这样就会出现FileSort。 5.3.3 Filesort 的优化通过创建合适的索引，能够减少 Filesort 的出现，但是在某些情况下，条件限制不能让Filesort消失，那就需要加快 Filesort的排序操作。对于Filesort ， MySQL 有两种排序算法： 1） 两次扫描算法 ：MySQL4.1 之前，使用该方式排序。首先根据条件取出排序字段和行指针信息，然后在排序区 sort buffer 中排序，如果sort buffer不够，则在临时表 temporary table 中存储排序结果。完成排序之后，再根据行指针回表读取记录，该操作可能会导致大量随机I/O操作。 2）一次扫描算法：一次性取出满足条件的所有字段，然后在排序区 sort buffer 中排序后直接输出结果集。排序时内存开销较大，但是排序效率比两次扫描算法要高。 MySQL 通过比较系统变量 max_length_for_sort_data 的大小和Query语句取出的字段总大小， 来判定是否那种排序算法，如果max_length_for_sort_data 更大，那么使用第二种优化之后的算法；否则使用第一种。 可以适当提高 sort_buffer_size 和 max_length_for_sort_data 系统变量，来增大排序区的大小，提高排序的效率。 5.4 优化group by 语句由于GROUP BY 实际上也同样会进行排序操作，而且与ORDER BY 相比，GROUP BY 主要只是多了排序之后的分组操作。当然，如果在分组的时候还使用了其他的一些聚合函数，那么还需要一些聚合函数的计算。所以，在GROUP BY 的实现过程中，与 ORDER BY 一样也可以利用到索引。 如果查询包含 group by 但是用户想要避免排序结果的消耗， 则可以执行order by null 禁止排序。如下 ： drop index idx_emp_age_salary on emp; explain select age,count(*) from emp group by age; 优化后 explain select age,count(*) from emp group by age order by null; 从上面的例子可以看出，第一个SQL语句需要进行”filesort”，而第二个SQL由于order by null 不需要进行 “filesort”， 而上文提过Filesort往往非常耗费时间。 创建索引 ： create index idx_emp_age_salary on emp(age,salary)； 5.5 优化嵌套查询Mysql4.1版本之后，开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询是可以被更高效的连接（JOIN）替代。 示例 ，查找有角色的所有的用户信息 : explain select * from t_user where id in (select user_id from user_role ); 执行计划为 : 优化后 : explain select * from t_user u , user_role ur where u.id = ur.user_id; 连接(Join)查询之所以更有效率一些 ，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上需要两个步骤的查询工作。 5.6 优化OR条件对于包含OR的查询子句，如果要利用索引，则OR之间的每个条件列都必须用到索引 ， 而且不能使用到复合索引； 如果没有索引，则应该考虑增加索引。 获取 emp 表中的所有的索引 ： 示例 ： explain select * from emp where id = 1 or age = 30; 建议使用 union 替换 or ： 我们来比较下重要指标，发现主要差别是 type 和 ref 这两项 type 显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是： system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL UNION 语句的 type 值为 ref，OR 语句的 type 值为 range，可以看到这是一个很明显的差距 UNION 语句的 ref 值为 const，OR 语句的 type 值为 null，const 表示是常量值引用，非常快 这两项的差距就说明了 UNION 要优于 OR 。 5.7 优化分页查询一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是 limit 2000000,10 ，此时需要MySQL排序前2000010 记录，仅仅返回2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。 5.7.1 优化思路一在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。 5.7.2 优化思路二该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。 5.8 使用SQL提示SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。 5.8.1 USE INDEX在查询语句中表名的后面，添加 use index 来提供希望MySQL去参考的索引列表，就可以让MySQL不再考虑其他可用的索引。 create index idx_seller_name on tb_seller(name); 5.8.2 IGNORE INDEX如果用户只是单纯的想让MySQL忽略一个或者多个索引，则可以使用 ignore index 作为 hint 。 explain select * from tb_seller ignore index(idx_seller_name) where name = '小米科技'; 5.8.3 FORCE INDEX为强制MySQL使用一个特定的索引，可在查询中使用 force index 作为hint 。 create index idx_seller_address on tb_seller(address); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL数据库优化之组合拳(二)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库优化之组合拳(一)]]></title>
    <url>%2F2021%2F01%2F17%2Fmysql-advanced-1%2F</url>
    <content type="text"><![CDATA[非原创图文,图文来源于黑马官网,此处仅作为备份学习 MySQL数据库优化总概 🚩组合拳（一） 组合拳（二） 组合拳（三） 组合拳（四） 索引 体系结构 应用优化 MySQL 常用工具 视图 存储引擎 查询缓存优化 MySQL 日志 存储过程和函数 优化SQL步骤 内存管理及优化 MySQL 主从复制 触发器 索引使用 MySQL锁问题 SQL优化 常用SQL技巧 1. 索引1.1 索引概述MySQL官方对索引的定义为：索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。如下面示意图所示 : 左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速获取到相应数据。一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据库中用来提高性能的最常用的工具。 1.2 索引优势劣势优势1） 类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本。2） 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。 劣势1） 实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空间的。2） 虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。 1.3 索引结构索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型的。MySQL目前提供了以下4种索引： BTREE 索引 ： 最常见的索引类型，大部分索引都支持 B 树索引。 HASH 索引：只有Memory引擎支持 ， 使用场景简单 。 R-tree 索引（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍。 Full-text （全文索引） ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从Mysql5.6版本开始支持全文索引。 MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持 索引 InnoDB引擎 MyISAM引擎 Memory引擎 BTREE索引 支持 支持 支持 HASH 索引 不支持 不支持 支持 R-tree 索引 不支持 支持 不支持 Full-text 5.6版本之后支持 支持 不支持 我们平常所说的索引，如果没有特别指明，都是指B+树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引、复合索引、前缀索引、唯一索引默认都是使用 B+tree 索引，统称为 索引。 1.3.1 BTREE 结构BTree又叫多路平衡搜索树，一颗m叉的BTree特性如下： 树中每个节点最多包含m个孩子。 除根节点与叶子节点外，每个节点至少有[ceil(m/2)]个孩子。 若根节点不是叶子节点，则至少有两个孩子。 所有的叶子节点都在同一层。 每个非叶子节点由n个key与n+1个指针组成，其中[ceil(m/2)-1] &lt;= n &lt;= m-1 以5叉BTree为例，key的数量：公式推导[ceil(m/2)-1] &lt;= n &lt;= m-1。所以 2 &lt;= n &lt;=4 。当n&gt;4时，中间节点分裂到父节点，两边节点分裂。插入 C N G A H E K Q M F W L T Z D P R X Y S 数据为例。 演变过程如下： 1). 插入前4个字母 C N G A 2). 插入H，n&gt;4，中间元素G字母向上分裂到新的节点 3). 插入E，K，Q不需要分裂 4). 插入M，中间元素M字母向上分裂到父节点G 5). 插入F，W，L，T不需要分裂 6). 插入Z，中间元素T向上分裂到父节点中 7). 插入D，中间元素D向上分裂到父节点中。然后插入P，R，X，Y不需要分裂 8). 最后插入S，NPQR节点n&gt;5，中间节点Q向上分裂，但分裂后父节点DGMT的n&gt;5，中间节点M向上分裂 到此，该BTREE树就已经构建完成了， BTREE树 和 二叉树 相比， 查询数据的效率更高， 因为对于相同的数据量来说，BTREE的层级结构比二叉树小，因此搜索速度快。 1.3.3 B+TREE 结构B+Tree为BTree的变种，B+Tree与BTree的区别为： 1). n叉B+Tree最多含有n个key，而BTree最多含有n-1个key。2). B+Tree的叶子节点保存所有的key信息，依key大小顺序排列。3). 所有的非叶子节点都可以看作是key的索引部分。 由于B+Tree只有叶子节点保存key信息，查询任何key都要从root走到叶子。所以B+Tree的查询效率更加稳定。 1.3.3 MySQL中的B+TreeMySql索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。 MySQL中的 B+Tree 索引结构示意图: 1.4 索引分类1） 单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引2） 唯一索引 ：索引列的值必须唯一，但允许有空值3） 复合索引 ：即一个索引包含多个列 1.5 索引语法索引在创建表的时候，可以同时创建， 也可以随时增加新的索引。 准备环境: create database demo_01 default charset=utf8mb4; use demo_01; CREATE TABLE `city` ( `city_id` int(11) NOT NULL AUTO_INCREMENT, `city_name` varchar(50) NOT NULL, `country_id` int(11) NOT NULL, PRIMARY KEY (`city_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `country` ( `country_id` int(11) NOT NULL AUTO_INCREMENT, `country_name` varchar(100) NOT NULL, PRIMARY KEY (`country_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; insert into `city` (`city_id`, `city_name`, `country_id`) values(1,'西安',1); insert into `city` (`city_id`, `city_name`, `country_id`) values(2,'NewYork',2); insert into `city` (`city_id`, `city_name`, `country_id`) values(3,'北京',1); insert into `city` (`city_id`, `city_name`, `country_id`) values(4,'上海',1); insert into `country` (`country_id`, `country_name`) values(1,'China'); insert into `country` (`country_id`, `country_name`) values(2,'America'); insert into `country` (`country_id`, `country_name`) values(3,'Japan'); insert into `country` (`country_id`, `country_name`) values(4,'UK'); 1.5.1 创建索引语法 ： CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name [USING index_type] ON tbl_name(index_col_name,...) index_col_name : column_name[(length)][ASC | DESC] 示例 ： 为city表中的city_name字段创建索引 ； create index idx_city_name on city(city_name); 1.5.2 查看索引语法： show index from table_name; 示例：查看city表中的索引信息； 1.5.3 删除索引语法 ： DROP INDEX index_name ON tbl_name; 示例 ： 想要删除city表上的索引idx_city_name，可以操作如下： drop index idx_city_name on city; 1.5.4 ALTER命令-- 添加一个主键,索引值必须唯一,且不能为NULL alter table tb_name add primary key(column_list); -- 添加唯一索引,索引的值必须唯一(除了NULL外,NULL可能会出现多次) alter table tb_name add unique index_name(column_list); -- 添加普通索引,索引值可以出现多次 alter table tb_name add index index_name(column_list); -- 指定了索引为FULLTEXT,用于全文索引 alter table tb_name add fulltext index_name(column_list); 1.6 索引设计原则​ 索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。 对查询频次较高，且数据量比较大的表建立索引。 索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。 使用唯一索引，区分度越高，使用索引的效率越高。 索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。 使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率。 利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。 创建复合索引: CREATE INDEX idx_name_email_status ON tb_seller(NAME,email,STATUS); 就相当于 对name 创建索引 ; 对name , email 创建了索引 ; 对name , email, status 创建了索引 ; 2. 视图2.1 视图概述​ 视图（View）是一种虚拟存在的表。视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。通俗的讲，视图就是一条SELECT语句执行后返回的结果集。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。视图相对于普通的表的优势主要包括以下几项。 简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。 安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。 数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。 2.2 创建或者修改视图创建视图的语法为： CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement [WITH [CASCADED | LOCAL] CHECK OPTION] 修改视图的语法为： ALTER [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement [WITH [CASCADED | LOCAL] CHECK OPTION] 选项 : WITH [CASCADED | LOCAL] CHECK OPTION 决定了是否允许更新数据使记录不再满足视图的条件。 LOCAL ： 只要满足本视图的条件就可以更新。 CASCADED ： 必须满足所有针对该视图的所有视图的条件才可以更新。 默认值. 示例 , 创建city_country_view视图 , 执行如下SQL : create or replace view city_country_view as select t.*,c.country_name from country c , city t where c.country_id = t.country_id; 查询视图 : 2.3 查看视图​ 从 MySQL 5.1 版本开始，使用 SHOW TABLES 命令的时候不仅显示表的名字，同时也会显示视图的名字，而不存在单独显示视图的 SHOW VIEWS 命令。 同样，在使用 SHOW TABLE STATUS 命令的时候，不但可以显示表的信息，同时也可以显示视图的信息。 如果需要查询某个视图的定义，可以使用 SHOW CREATE VIEW 命令进行查看 ： 2.4 删除视图语法 : DROP VIEW [IF EXISTS] view_name [, view_name] ...[RESTRICT | CASCADE] 示例 , 删除视图city_country_view : DROP VIEW city_country_view ; 3. 存储过程和函数3.1 存储过程和函数概述​ 存储过程和函数是 事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 存储过程和函数的区别在于函数必须有返回值，而存储过程没有。​ 函数 ： 是一个有返回值的过程 ；​ 过程 ： 是一个没有返回值的函数 ； 3.2 创建存储过程CREATE PROCEDURE procedure_name ([proc_parameter[,...]]) begin -- SQL语句 end ; 示例 ： delimiter $ create procedure pro_test1() begin select 'Hello Mysql' ; end$ delimiter ; 知识小贴士 DELIMITER ​ 该关键字用来声明SQL语句的分隔符 , 告诉 MySQL 解释器，该段命令是否已经结束了，mysql是否可以执行了。默认情况下，delimiter是分号;。在命令行客户端中，如果有一行命令以分号结束，那么回车后，mysql将会执行该命令。 3.3 调用存储过程call procedure_name() ; 3.4 查看存储过程-- 查询db_name数据库中的所有的存储过程 select name from mysql.proc where db='db_name'; -- 查询存储过程的状态信息 show procedure status; -- 查询某个存储过程的定义 show create procedure test.pro_test1 \G; 3.5 删除存储过程DROP PROCEDURE [IF EXISTS] sp_name; 3.6 语法存储过程是可以编程的，意味着可以使用变量，表达式，控制结构 ， 来完成比较复杂的功能。 3.6.1 变量 DECLARE 通过 DECLARE 可以定义一个局部变量，该变量的作用范围只能在 BEGIN…END 块中。 DECLARE var_name[,...] type [DEFAULT value] 示例 : delimiter $ create procedure pro_test2() begin declare num int default 5; select num+ 10; end$ delimiter ; SET 直接赋值使用 SET，可以赋常量或者赋表达式，具体语法如下： SET var_name = expr [, var_name = expr] ... 示例 : DELIMITER $ CREATE PROCEDURE pro_test3() BEGIN DECLARE NAME VARCHAR(20); SET NAME = 'MYSQL'; SELECT NAME ; END$ DELIMITER ; 也可以通过select … into 方式进行赋值操作 : DELIMITER $ CREATE PROCEDURE pro_test5() BEGIN declare countnum int; select count(*) into countnum from city; select countnum; END$ DELIMITER ; 3.6.2 if条件判断语法结构 : if search_condition then statement_list [elseif search_condition then statement_list] ... [else statement_list] end if; 示例 : 根据定义的身高变量，判定当前身高的所属的身材类型 180 及以上 ———-&gt; 身材高挑 170 - 180 ———&gt; 标准身材 170 以下 ———-&gt; 一般身材 delimiter $ create procedure pro_test6() begin declare height int default 175; declare description varchar(50); if height >= 180 then set description = '身材高挑'; elseif height >= 170 and height &lt; 180 then set description = '标准身材'; else set description = '一般身材'; end if; select description ; end$ delimiter ; 调用结果为 : 3.6.3 传递参数语法格式 : create procedure procedure_name([in/out/inout] 参数名 参数类型) ... IN : 该参数可以作为输入,也就是需要调用方传入值 , 默认 OUT: 该参数作为输出,也就是该参数可以作为返回值 INOUT: 既可以作为输入参数,也可以作为输出参数 1) IN - 输入 示例 :根据定义的身高变量，判定当前身高的所属的身材类型 delimiter $ create procedure pro_test5(in height int) begin declare description varchar(50) default ''; if height >= 180 then set description='身材高挑'; elseif height >= 170 and height &lt; 180 then set description='标准身材'; else set description='一般身材'; end if; select concat('身高 ', height , '对应的身材类型为:',description); end$ delimiter ; 2) OUT-输出 示例: 根据传入的身高变量，获取当前身高的所属的身材类型 create procedure pro_test5(in height int , out description varchar(100)) begin if height >= 180 then set description='身材高挑'; elseif height >= 170 and height &lt; 180 then set description='标准身材'; else set description='一般身材'; end if; end$ 调用: call pro_test5(168, @description)$ select @description$ 小知识 @description 这种变量要在变量名称前面加上“@”符号，叫做用户会话变量，代表整个会话过程他都是有作用的，这个类似于全局变量一样。 @@global.sort_buffer_size 这种在变量前加上 “@@” 符号, 叫做 系统变量 3.6.4 case结构语法结构 : 方式一 : CASE case_value WHEN when_value THEN statement_list [WHEN when_value THEN statement_list] ... [ELSE statement_list] END CASE; 方式二 : CASE WHEN search_condition THEN statement_list [WHEN search_condition THEN statement_list] ... [ELSE statement_list] END CASE; 示例 :给定一个月份, 然后计算出所在的季度 delimiter $ create procedure pro_test9(month int) begin declare result varchar(20); case when month >= 1 and month &lt;=3 then set result = '第一季度'; when month >= 4 and month &lt;=6 then set result = '第二季度'; when month >= 7 and month &lt;=9 then set result = '第三季度'; when month >= 10 and month &lt;=12 then set result = '第四季度'; end case; select concat('您输入的月份为 :', month , ' , 该月份为 : ' , result) as content ; end$ delimiter ; 3.6.5 while循环语法结构: while search_condition do statement_list end while; 需求: 示例 :计算从1加到n的值 delimiter $ create procedure pro_test8(n int) begin declare total int default 0; declare num int default 1; while num&lt;=n do set total = total + num; set num = num + 1; end while; select total; end$ delimiter ; 3.6.6 repeat结构有条件的循环控制语句, 当满足条件的时候退出循环 。while 是满足条件才执行，repeat 是满足条件就退出循环。 语法结构 : REPEAT statement_list UNTIL search_condition END REPEAT; 示例 :计算从1加到n的值 delimiter $ create procedure pro_test10(n int) begin declare total int default 0; repeat set total = total + n; set n = n - 1; until n=0 end repeat; select total ; end$ delimiter ; 3.6.7 loop语句LOOP 实现简单的循环，退出循环的条件需要使用其他的语句定义，通常可以使用 LEAVE 语句实现，具体语法如下： [begin_label:] LOOP statement_list END LOOP [end_label] 如果不在 statement_list 中增加退出循环的语句，那么 LOOP 语句可以用来实现简单的死循环。 3.6.8 leave语句用来从标注的流程构造中退出，通常和 BEGIN … END 或者循环一起使用。下面是一个使用 LOOP 和 LEAVE 的简单例子 , 退出循环： delimiter $ CREATE PROCEDURE pro_test11(n int) BEGIN declare total int default 0; ins: LOOP IF n &lt;= 0 then leave ins; END IF; set total = total + n; set n = n - 1; END LOOP ins; select total; END$ delimiter ; 3.6.9 游标/光标游标是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用光标对结果集进行循环的处理。光标的使用包括光标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。 声明光标： DECLARE cursor_name CURSOR FOR select_statement ; OPEN 光标： OPEN cursor_name ; FETCH 光标： FETCH cursor_name INTO var_name [, var_name] ... CLOSE 光标： CLOSE cursor_name ; 示例 : 初始化脚本: create table emp( id int(11) not null auto_increment , name varchar(50) not null comment '姓名', age int(11) comment '年龄', salary int(11) comment '薪水', primary key(`id`) )engine=innodb default charset=utf8 ; insert into emp(id,name,age,salary) values(null,'金毛狮王',55,3800),(null,'白眉鹰王',60,4000),(null,'青翼蝠王',38,2800),(null,'紫衫龙王',42,1800); -- 查询emp表中数据, 并逐行获取进行展示 create procedure pro_test11() begin declare e_id int(11); declare e_name varchar(50); declare e_age int(11); declare e_salary int(11); declare emp_result cursor for select * from emp; open emp_result; fetch emp_result into e_id,e_name,e_age,e_salary; select concat('id=',e_id , ', name=',e_name, ', age=', e_age, ', 薪资为: ',e_salary); fetch emp_result into e_id,e_name,e_age,e_salary; select concat('id=',e_id , ', name=',e_name, ', age=', e_age, ', 薪资为: ',e_salary); fetch emp_result into e_id,e_name,e_age,e_salary; select concat('id=',e_id , ', name=',e_name, ', age=', e_age, ', 薪资为: ',e_salary); fetch emp_result into e_id,e_name,e_age,e_salary; select concat('id=',e_id , ', name=',e_name, ', age=', e_age, ', 薪资为: ',e_salary); fetch emp_result into e_id,e_name,e_age,e_salary; select concat('id=',e_id , ', name=',e_name, ', age=', e_age, ', 薪资为: ',e_salary); close emp_result; end$ 通过循环结构 , 获取游标中的数据 : DELIMITER $ create procedure pro_test12() begin DECLARE id int(11); DECLARE name varchar(50); DECLARE age int(11); DECLARE salary int(11); DECLARE has_data int default 1; DECLARE emp_result CURSOR FOR select * from emp; DECLARE EXIT HANDLER FOR NOT FOUND set has_data = 0; open emp_result; repeat fetch emp_result into id , name , age , salary; select concat('id为',id, ', name 为' ,name , ', age为 ' ,age , ', 薪水为: ', salary); until has_data = 0 end repeat; close emp_result; end$ DELIMITER ; 3.7 存储函数语法结构: CREATE FUNCTION function_name([param type ... ]) RETURNS type BEGIN ... END; 示例 : 定义一个存储过程, 请求满足条件的总记录数 ; delimiter $ create function count_city(countryId int) returns int begin declare cnum int ; select count(*) into cnum from city where country_id = countryId; return cnum; end$ delimiter ; 调用: select count_city(1); select count_city(2); 4. 触发器4.1 介绍触发器是与表有关的数据库对象，指在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。 使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。 触发器类型 NEW 和 OLD的使用 INSERT 型触发器 NEW 表示将要或者已经新增的数据 UPDATE 型触发器 OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据 DELETE 型触发器 OLD 表示将要或者已经删除的数据 4.2 创建触发器语法结构 : create trigger trigger_name before/after insert/update/delete on tbl_name [ for each row ] -- 行级触发器 begin trigger_stmt ; end; 示例 通过触发器记录 emp 表的数据变更日志 , 包含增加, 修改 , 删除 ; 1) 首先创建一张日志表 : create table emp_logs( id int(11) not null auto_increment, operation varchar(20) not null comment '操作类型, insert/update/delete', operate_time datetime not null comment '操作时间', operate_id int(11) not null comment '操作表的ID', operate_params varchar(500) comment '操作参数', primary key(`id`) )engine=innodb default charset=utf8; 2) 创建 insert 型触发器，完成插入数据时的日志记录 : DELIMITER $ create trigger emp_logs_insert_trigger after insert on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,'insert',now(),new.id,concat('插入后(id:',new.id,', name:',new.name,', age:',new.age,', salary:',new.salary,')')); end $ DELIMITER ; 3) 创建 update 型触发器，完成更新数据时的日志记录 : DELIMITER $ create trigger emp_logs_update_trigger after update on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,'update',now(),new.id,concat('修改前(id:',old.id,', name:',old.name,', age:',old.age,', salary:',old.salary,') , 修改后(id',new.id, 'name:',new.name,', age:',new.age,', salary:',new.salary,')')); end $ DELIMITER ; 4) 创建delete 行的触发器 , 完成删除数据时的日志记录 : DELIMITER $ create trigger emp_logs_delete_trigger after delete on emp for each row begin insert into emp_logs (id,operation,operate_time,operate_id,operate_params) values(null,'delete',now(),old.id,concat('删除前(id:',old.id,', name:',old.name,', age:',old.age,', salary:',old.salary,')')); end $ DELIMITER ; 5)测试： insert into emp(id,name,age,salary) values(null, '光明左使',30,3500); insert into emp(id,name,age,salary) values(null, '光明右使',33,3200); update emp set age = 39 where id = 3; delete from emp where id = 5; 4.3 删除触发器语法结构 : drop trigger [schema_name.]trigger_name 如果没有指定 schema_name，默认为当前数据库 。 4.4 查看触发器可以通过执行 SHOW TRIGGERS 命令查看触发器的状态、语法等信息。 语法结构 ： show triggers; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL数据库优化之组合拳(一)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习指南]]></title>
    <url>%2F2021%2F01%2F12%2Fstudy-guide%2F</url>
    <content type="text"><![CDATA[学习本身比学习内容更重要 任务式学习：1.家庭2.工作3.成长 一、寻找学习资源1.1 搜索网站、公众号 1.2 专业平台工具1.3 跟人学​三级导师制：入门、进圈、拜佛 入门：第一级导师-任意干这行的人（询问牛人（关注他们，散射他们的关注）、书）​进圈：机会​拜佛：接触：好问题 好问题： 1.请问在像您这样的专家心目中，您这个领域公认的大神是谁？ 2.我特别遗憾，我一直没有机会系统地去学，您这个领域的知识。我四十多岁了，想从现在开始学起，那在入门阶段，您推荐我读哪本书？ 3.老师，我想在大学毕业之后从事投资工作。您是做投资的，您觉得从事这一行业基本能力的要求是什么？我应该从哪开始作准备？ 4.老师，从事这个行业，您觉得最关键的环节有哪些？您都遇到过哪几个重要挑战？您是怎么过来的？ 5.在您这个领域，您觉得一般人和高手之间最大的区别是什么？ 6.如果您要带一个徒弟，您会重点教他关注哪几个魔鬼细节？为什么是这几个细节特别重要？ 7.老师，最近好长时间没见了，最近半年您觉得有什么问题、什么新闻或者哪本书，是对您触动特别大的吗？ 这个问题，是我自己很喜欢问的一个问题。首先，这个问题很轻，对方容易回答。但是在他的回答当中，我们又能收集到很多想法，收获很大。在闲谈的时候，最适合问这样的问题。 8.最近你们行业发生了一件XXX大事，您能帮我分析分析，这背后到底是怎么回事吗？ 9.老师，我现在此时此刻已经在做一件什么事。这个事，我有个难点一直没想明白，能不能请您给我指点一下？ 10.假如，此刻是你生命的最后十分钟。你有个机会，可以给这个世界留下一段话，说说你自己这个专业。请问你会说什么？ 二、定目标2.1 有场景：2.2 有距离：目标和现状有差距，跳一跳才能够得着，2.3 有抓手：距离得合适,具体可入手的地方2.3.1 开始结束时间​2.3.2 具体的执行动作​2.3.3 执行动作的数量​2.3.4 动作的完成度 2.4 有阶梯：拒绝平均用力从易到难排序，先选最易的处理（小步子原理,先摘好摘的果子） 三、提高效率3.1 五阶学习法3.1.1 测试法（设计学习任务）3.1.2 指读法3.1.3 多环境输入法（看听）3.1.4 记忆宫殿（抗遗忘）3.1.5 刷书（不读细,读广,视野） 序言，开头，倒数第二章 居高临下关注（挑战，任务清单） 四、输出倒逼输入4.1 记笔记（两轮笔记法）​ 1轮（手写）：实际输入的（关键词记录） | 当时的想法感受（讯飞语记）​ 2轮 重新用自己的逻辑写出来 4.2 讲出来 10岁-具象能懂，抽象不懂 4.3 迁移：触类旁通​ 4.3.1 能用的场景​ 4.3.2 不能用的场景 4.4 夯实，拉出操作清单 ：清单体（迭代清单1.0-&gt;2.0-&gt;3.0-&gt; …）五、正反馈（自驱力）-想方设法5.1 记笔记，小本记5.2 公开平台，定期发表自己的成果5.3 环境场（结界）5.4 惊奇日记（每日一句话） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>手册</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式]]></title>
    <url>%2F2021%2F01%2F05%2Fdesign-pattern%2F</url>
    <content type="text"><![CDATA[概述： 本质：面向对象设计原则的实际运用，是对类的封装、继承和多态性以及类的关联关系和组合关系的充分理解。 分类: 1. 创建型模式：共5种，用于描述“怎样创建对象”，主要特点是“将对象的创建与使用分离”(解耦)。客户程序仅仅需要去使用对象，而不再关心创建对象过程中的逻辑。 2. 结构型模式：共7种，用于描述如何将类或对象按某种布局组成更大的结构。 3. 行为型模式：共11种，用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。 一、6大设计原则1. 单一职责原则 (SRP)英文：Single Responsibility Principle 定义：有且仅有一个原因引起类的变更 优点： ​ 1.类的复杂性降低 ​ 2.可读性提高 ​ 3.可维护性提高 ​ 4.变更引起的风险降低 难点：职责界限的划分 适用范围：接口(一定)、类(尽量)、方法(尽可能) 2. 里式替换原则 (LSP)英文：Liskov Substitution Principle 定义： ​ 定义1：如果对每一个类型为S的对象o1,都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时,程序P的行为没有发生变化，那么类型S是类型T的子类型。 ​ 定义2：所有引用基类的地方必须能透明地使用其子类的对象。 ​ 通俗解释：父类出现的地方,子类能完美替换父类,且不会产生任何错误和异常;反之,子类出现的地方,父类未必能适应。 定义拆解： ​ 4层含义： ​ 1.子类必须完全实现父类的方法 ​ 2.子类可以有自己的个性 ​ 3.[契约设计]覆盖或实现父类的方法时输入参数，要么一样（覆写），要么可以被放大（重载） ​ 4.覆写或实现父类的方法时输出结果（返回类型）可以被缩小 优点：增强程序的健壮性 应用：版本升级(待实践) 最佳实践：在项目中,采用LSP时，尽量避免子类的“个性”，一旦子类有“个性”，这个子类和父类之间的关系就很难调和了，把子类当做父类使用，子类的“个性”被抹杀–委屈了点；把子类单独作为一个业务来使用，则会让代码间的耦合关系变的扑朔迷离–缺乏替换的标准。 3. 依赖导致原则 (DIP)英文：Dependence Inversion Principle 定义：High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions. 定义拆解： ​ 1.高层模块不应该依赖底层模块，两者都应该依赖其抽象 ​ 2.抽象不应该依赖细节，细节应该依赖抽象 优点：减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。 依赖三种写法： ​ 1.构造函数传递依赖对象 ​ 2.Setter方法传递依赖对象 ​ 3.接口声明依赖对象 本质： ​ 遵循规则： ​ 1.基本要求：通过抽象(接口或抽象类),使各类或模块的实现彼此独立,不相相互影响,实现模块间的松耦合。 ​ 2.变量的表面类型尽量是接口或者是抽象类：一个变量可以有两种类型：表面类型和实际类型，表面类型是在定义的时候赋予的类型，实际类型是对象的类型。 ​ 3.任何类都不应该从具体类派生 ​ 4.尽量不要覆写基类的方法 ​ 5.结合里氏替换原则使用 ​ 核心：“面向接口编程” 4. 接口隔离原则 (ISP)英文: Interface Segregation Principle 定义： ​ 定义1：客户端不应该依赖它不需要的接口 ​ 定义2：类间的依赖关系应该建立在最小的接口上 ​ 通俗解释：建立单一接口，不要臃肿肥大的接口。接口尽量细化，接口中的方法尽量少。 区分：单一职责原则(SRP) 和 接口隔离原则(ISP)的区别，SRP强调单一职责，要求类和职责单一，注重职责，这是逻辑业务上划分，而ISP要求接口的方法尽量少。 规范拆解： ​ 1.接口尽量小：“小”有限度，必须 满足单一职责 (SRP) ​ 2.接口要高内聚：高内聚就是提高接口、类、模块的处理能力，减少对外的交互。接口中尽量少公布public方法，接口的对外的承诺越少对系统的开发越有利，变更的风险就越少，同时也有利于降低成本。 ​ 3.定制服务：单独为一个个体体用优良的服务。只提供访问者需要的方法。 ​ 4.接口设计是由限度的:接口设计粒度越小越灵活，灵活带来了接口复杂化，开发难度增加，可维护性降低。把握好“度”。 5. 迪米特法则（LKP/LoD）英文：Law of Demeter 也称 Least Knowledge Principle 关键词：高内聚、低耦合 定义：一个对象应该对其他对象有最少的了解。 ​ 通俗解释：一个类应该对自己需要耦合或者调用的类知道得越少(即解耦、弱耦) 定义拆解： ​ 4层含义： ​ 1.只与直接的朋友通信 ，朋友类：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类 ​ 2.朋友间是有距离的：尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛，多使用private、package-private、protect等访问权限 ​ 3.是自己的就是自己的：如果一个方法放在本类中，即不增加类间关系，也对本类不产生负面影响，那就放置在本类中。 ​ 4.谨慎使用Serializable 最佳实践：一个类跳转两次以上才能访问到另一个类，就需要想办法进行重构 6. 开闭原则（OCP）英文：Open Closed Principle 定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭 二、23种设计模式（5）1. 创建型模式1.1. 简单工厂模式（SFP）英文：Simple Factory Pattern 定义：由一个工厂对象决定创建出哪一种类型实例。客户端只需传入工厂类的参数，无需关心创建过程。 优点：具体产品从客户端代码中抽离出来，解耦。 缺点：工厂类职责过重，增加新的类型时，得修改工厂类的代码，违背OCP。 最佳实践：严格意义来说，SFP不属于设计模式的一种 举例：简单工厂模式-糖果生产 创建糖果抽象类 public abstract class Candy { public abstract void eat(); } 创建抽象糖果实现类-巧克力等 public class Chocolate extends Candy{ @Override public void eat() { System.out.println("eat chocolate ing..."); } } 创建糖果工厂类 public class CandyFactory { public Candy product(String candyName){ if("chocolate".equalsIgnoreCase(candyName)){ return new Chocolate(); }else{ return null; } } } 测试 public class SfpTest { public static void main(String[] args) { CandyFactory candyFactory = new CandyFactory(); Candy chocolate = candyFactory.product("chocolate"); chocolate.eat(); } } 输出 eat chocolate ing... 1.2. 工厂方法模式（FMP）英文：Factory Method Pattern 定义：定义创建对象的接口，让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类进行。 优点： 具体产品从客户端代码中抽离出来，实现了解耦。 加入新的类型时，只需添加新的工厂方法（无需修改旧的工厂方法代码），符合OCP。 缺点：类的个数容易过多，增加复杂度。 最佳实践： 举例： 创建糖果抽象类 public abstract class Candy { public abstract void eat(); } 创建抽象工厂类 public abstract class CandyFactory { public abstract Candy product(); } 创建抽象糖果实现类-玉米软糖等 public class CornFudge extends Candy{ @Override public void eat() { System.out.println("eat corn fudge ing..."); } } 创建抽象工厂实现类-玉米软糖工厂等 public class CornFudgeFactory extends CandyFactory { @Override public Candy product() { return new CornFudge(); } } 测试 public class FmpTest { public static void main(String[] args) { CornFudgeFactory cornFudgeFactory = new CornFudgeFactory(); Candy cornFudge = cornFudgeFactory.product(); cornFudge.eat(); } } 6.输出 eat corn fudge ing... 1.3. 抽象工厂模式（AFP）英文：Abstract Factory Pattern 定义：提供了一系列相关或者相互依赖的对象的接口 优点： 具体产品从客户端代码中抽离出来，实现解耦。 将一个系列的产品族统一到一起创建 缺点：拓展新的功能困难，需要修改抽象工厂的接口 最佳实践： 举例： 创建抽象糖果类 public abstract class Candy { public abstract void eat(); public abstract void buy(); } 创建抽象价格类 public abstract class Price { public abstract void pay(); } 创建抽象工厂接口 public interface CandyFactory { Candy getCandy(); Price getPrice(); } 实现抽象工厂接口-棒棒糖工厂 public class LollipopFactory implements CandyFactory{ @Override public Candy getCandy() { return new Lollipop(); } @Override public Price getPrice() { return new LollipopPrice(); } } 创建产品族 public class Lollipop extends Candy { @Override public void eat() { System.out.println("eat lollipop ing..."); } @Override public void buy() { System.out.println("buy lollipop"); } } public class LollipopPrice extends Price{ @Override public void pay() { System.out.println("lollipop sell $2"); } } 测试 public class afpTest { public static void main(String[] args) { LollipopFactory lollipopFactory = new LollipopFactory(); lollipopFactory.getPrice().pay(); lollipopFactory.getCandy().buy(); lollipopFactory.getCandy().eat(); } } 输出 lollipop sell $2 buy lollipop eat lollipop ing... 1.4. 建造者模式（BP）英文：Builder Pattern 定义：也称为生成器模式，将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。简单来说就是，相同的过程可以创建不同的产品。 优点： 封装性好，创建和使用分离 拓展性好，建造类之间独立，一定程度上解耦。 缺点： 产生多余的Builder对象； 产品内部发生变化，建造者需要更改，成本较大。 最佳实践： 一个对象有非常复杂的内部结构（很多属性） 想将复杂对象的创建和使用分离。 举例： 创建商铺类Store(包含多属性) public class Store { private String name; private String location; private String type; @Override public String toString() { return "Store{" + "name='" + name + '\'' + ", location='" + location + '\'' + ", type='" + type + '\'' + '}'; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getLocation() { return location; } public void setLocation(String location) { this.location = location; } public String getType() { return type; } public void setType(String type) { this.type = type; } } 创建商铺抽象生成器 StoreBuilder（包含和Store相同的属性及对应的抽象构造方法） public abstract class StoreBuilder { private String name; private String location; private String type; public abstract void name(String name); public abstract void location(String location); public abstract void type(String type); public abstract Store build(); } 创建商铺抽象生成器的实现，糖果铺构造器CandyStoreBuilder public class CandyStoreBuilder extends StoreBuilder { private Store store = new Store(); @Override public void name(String name) { this.store.setName(name); } @Override public void location(String location) { this.store.setLocation(location); } @Override public void type(String type) { this.store.setType(type); } @Override public Store build() { return store; } } 创建经销商类Dealer,用于通过StoreBuilder构建具体的商铺 public class Dealer { private StoreBuilder storeBuilder; public void setStoreBuilder(StoreBuilder storeBuilder) { this.storeBuilder = storeBuilder; } public Store build(String name, String location, String type) { this.storeBuilder.name(name); this.storeBuilder.location(location); this.storeBuilder.type(type); return storeBuilder.build(); } } 测试 public class BpTest { public static void main(String[] args) { Dealer dealer = new Dealer(); dealer.setStoreBuilder(new CandyStoreBuilder()); Store store = dealer.build("甜蜜蜜糖果店", "上海市陆家嘴77号", "糖果经销"); System.out.println(store); } } 输出 Store{name='甜蜜蜜糖果店', location='上海市陆家嘴77号', type='糖果经销'} 1.5. 单例模式 (SP)英文：Singleton Pattern 定义：一个类只有一个实例 优点： 内存中只有一个实例，减少了内存开销； 避免对资源的多重占用； 缺点：没有接口，拓展困难。 最佳实践： 模式 描述 方式 优点 缺点 是否推荐 饿汉模式 不管需不需要用到实例都要去创建实例 - 线程安全 不管用到与否,类加载到内存后，就实例化一个单例 有缺点,简单实用,推荐使用 懒汉模式 需要用到创建实例了程序再去创建实例 方式一：锁,双重判空方式 1.线程安全 2.用的时候,再实例化 降低程序效率(判空+锁) 不推荐 方式二：静态内部类方式 1.线程安全(JVM保证单例) 2.加载外部类不会加载内部类,实现了懒加载 - 完美写法,推荐 枚举模式 - - 1. 解决线程同步2. 防止反序列化原因：由于枚举没有构造方法，不会被反射反射原理：类的class文件加载到内存,反射（反序列化的方式）new一个实例（前提要有构造方法） - 完美中的完美,推荐 举例： 饿汉模式、懒汉模式、单例模式 1.1. 饿汉模式 方式一：间接声明-静态代码块new public class SingletonHunger01 { //方式一 ：间接声明-静态代码块new private static final SingletonHunger01 INSTANCE; static{ INSTANCE = new SingletonHunger01(); } //构造方法设为私有,使得其他类不能new private SingletonHunger01(){}; public static SingletonHunger01 getInstance(){ return INSTANCE; } } ​ 方式二：直接声明-直接new public class SingletonHunger02 { //方式二：直接声明-直接new private static final SingletonHunger02 INSTANCE = new SingletonHunger02(); //构造方法设为私有,使得其他类不能new private SingletonHunger02(){}; public static SingletonHunger02 getInstance(){ return INSTANCE; } } ​ 1.2. 懒汉模式 ​ 方式一：锁,双重判空方式 public class SingletonLazy01 { public static SingletonLazy01 INSTANCE = null; //构造方法设为私有,使得其他类不能new private SingletonLazy01(){}; public static SingletonLazy01 getInstance(){ if(INSTANCE == null){ //降低每次进来都需要判断锁 synchronized (SingletonLazy01.class){ if(INSTANCE == null){ INSTANCE = new SingletonLazy01(); } } } return INSTANCE; } } ​ 方式二：静态内部类方式 public class SingletonLazy02 { private SingletonLazy02(){}; //静态内部类 private static class StaticInner{ private final static SingletonLazy02 INSTANCE = new SingletonLazy02(); } public static SingletonLazy02 getInstance(){ return StaticInner.INSTANCE; } } ​ 1.3. 枚举单例 public enum SingletonEnum { //单例枚举 INSTANCE; } 测试 public class SpTest { public static void main(String[] args) { System.out.println("HASHCODE-hash码,同一个类中的hash码不会相同,不同类的hashcode不能保证相同"); System.out.println("饿汉模式-间接声明方式-"+SingletonHunger01.getInstance().hashCode()); System.out.println("饿汉模式-直接声明方式-"+SingletonHunger02.getInstance().hashCode()); System.out.println("懒汉模式-锁,双重判空方式-"+SingletonLazy01.getInstance().hashCode()); System.out.println("懒汉模式-静态内部类方式-"+SingletonLazy02.getInstance().hashCode()); System.out.println("单例模式-"+SingletonEnum.INSTANCE.hashCode()); } } 输出 HASHCODE-hash码,同一个类中的hash码不会相同,不同类的hashcode不能保证相同 饿汉模式-间接声明方式-1856056345 饿汉模式-直接声明方式-221036634 懒汉模式-锁,双重判空方式-1418370913 懒汉模式-静态内部类方式-707610042 单例模式-551734240 1.6. 原型模式（PP）英文：Prototype Pattern 定义：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象 优点： 原型模式是在内存中二进制流的拷贝，要比new一个对象的性能要好，特别是需要产生大量对象时。 简化创建对象过程。 缺点： 对象必须重写Object克隆方法； 直接在内存中拷贝，构造函数是不会执行 复杂对象的克隆方法写起来较麻烦（浅克隆、深克隆） 克隆会破坏实现了Cloneable接口的单例对象 最佳实践： 如果类的初始化需要耗费较多的资源，那么可以通过原型拷贝避免这些消耗。 通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以拷贝多个对象供调用者使用，即保护性拷贝。 拓展： 克隆分类 实现 浅克隆 只复制基本类型的数据，引用类型的数据只复制了引用的地址，引用的对象并没有复制，在新的对象中修改引用类型的数据会影响原对象中的引用。 深克隆 方式一：嵌套重写clone方法：实现Cloneable接口（引用数据类型也要实现Cloneable接口），重写clone方法，clone的嵌套，复制后的对象与原对象之间完全不会影响。方式二：序列化对象：实现序列化Serializable接口（不实现Cloneable接口），（引用数据类型也要实现Serializable），对象序列化后写入流中，此时不存在引用数据类型的概念，从流中读取，生成新的对象，新对象和原对象之间也是完全互不影响的。 举例： 1.1. 浅克隆（简单属性）：创建对象，实现Cloneable，重写clone方法 public class CandyShallow implements Cloneable { private String name; private String color; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } //浅克隆 @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } @Override public String toString() { return "CandyShallow{" + "name='" + name + '\'' + ", color='" + color + '\'' + '}'; } } 1.2. 测试 public class PpTest { public static void main(String[] args) throws CloneNotSupportedException { CandyShallow candyShallow = new CandyShallow(); ArrayList&lt;CandyShallow> list = new ArrayList&lt;>(); for (int i = 0; i &lt; 3; i++) { CandyShallow clone = (CandyShallow)candyShallow.clone(); clone.setName("ALPENLIEBE"+i); clone.setColor("color"+i); list.add(clone); } System.out.println(list); } } 1.3. 输出 [Candy{name='ALPENLIEBE0', color='color0'}, Candy{name='ALPENLIEBE1', color='color1'}, Candy{name='ALPENLIEBE2', color='color2'}] 2.1. 方式一：实现Cloneable,嵌套重写clone方法 public class CandyDeep implements Cloneable { private String name; private String color; private Stuffing stuffing; //--------------------------------------重点↓ /** * 方式一：重写clone方法，实现深拷贝 * 注：该方式的缺陷是需要单独处理所有要克隆的类中的引用数据类型(Stuffing) */ @Override protected Object clone(){ CandyDeep candyDeep = null; try { candyDeep = (CandyDeep) super.clone(); candyDeep.stuffing = (Stuffing)this.stuffing.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } return candyDeep; } //--------------------------------------重点↑ @Override public String toString() { return "CandyDeep{" + "name='" + name + '\'' + ", color='" + color + '\'' + ", stuffing=" + stuffing + '}'; } public CandyDeep(String name, String color, Stuffing stuffing) { this.name = name; this.color = color; this.stuffing = stuffing; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } public Stuffing getStuffing() { return stuffing; } public void setStuffing(Stuffing stuffing) { this.stuffing = stuffing; } } public class Stuffing implements Cloneable{ private String body; private String form; private String color; //--------------------------------------重点↓ //无引用数据类型,浅克隆即可 @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } //--------------------------------------重点↑ @Override public String toString() { return "Stuffing{" + "body='" + body + '\'' + ", form='" + form + '\'' + ", color='" + color + '\'' + '}'; } public Stuffing(String body, String form, String color) { this.body = body; this.form = form; this.color = color; } public String getBody() { return body; } public void setBody(String body) { this.body = body; } public String getForm() { return form; } public void setForm(String form) { this.form = form; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } } 2.2. 方式二（推荐）：序列化对象 public class CandyDeep2 implements Serializable { private static final long serialVersionUID = 1L; private String name; private String color; private Stuffing2 stuffing2; //--------------------------------------重点↓ public CandyDeep2 deepClone() { ByteArrayOutputStream bos = null; ObjectOutputStream oos = null; ByteArrayInputStream bis = null; ObjectInputStream ois = null; try { //创建序列化流 bos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(bos); //将当前对象以对象流的方式输出 oos.writeObject(this); //创建反序列化流 bis = new ByteArrayInputStream(bos.toByteArray()); ois = new ObjectInputStream(bis); //将流对象反序列化,从而实现类的深拷贝 return (CandyDeep2) ois.readObject(); } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); return null; } finally { try { //资源释放 bos.close(); bis.close(); oos.close(); ois.close(); } catch (IOException e) { e.printStackTrace(); } } } //--------------------------------------重点↑ @Override public String toString() { return "CandyDeep2{" + "name='" + name + '\'' + ", color='" + color + '\'' + ", stuffing2=" + stuffing2 + '}'; } public CandyDeep2(String name, String color, Stuffing2 stuffing2) { this.name = name; this.color = color; this.stuffing2 = stuffing2; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } public Stuffing2 getStuffing2() { return stuffing2; } public void setStuffing2(Stuffing2 stuffing2) { this.stuffing2 = stuffing2; } } public class Stuffing2 implements Serializable { private static final long serialVersionUID = 1L; private String body; private String form; private String color; @Override public String toString() { return "Stuffing2{" + "body='" + body + '\'' + ", form='" + form + '\'' + ", color='" + color + '\'' + '}'; } public Stuffing2(String body, String form, String color) { this.body = body; this.form = form; this.color = color; } public String getBody() { return body; } public void setBody(String body) { this.body = body; } public String getForm() { return form; } public void setForm(String form) { this.form = form; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } } 2.3. 测试 public static void main(String[] args) { System.out.println("深克隆,方式一:"); CandyDeep candyDeep = new CandyDeep("黑色","酒心巧克力",new Stuffing("酒饮料","液体","无色")); System.out.println(candyDeep); //candyDeep 和 cloneCandy 非同一个对象 CandyDeep cloneCandy = (CandyDeep) candyDeep.clone(); System.out.println(cloneCandy); System.out.println("+++++++++++++++++++华丽的分界线++++++++++++++++++++++"); System.out.println("深克隆,方式二:"); CandyDeep2 candyDeep2 = new CandyDeep2("白色","果仁巧克力",new Stuffing2("果仁","固体","棕色")); System.out.println(candyDeep2); //candyDeep2 和 cloneCandy2 非同一个对象 CandyDeep2 cloneCandy2 = candyDeep2.deepClone(); System.out.println(cloneCandy2); } 2.4. 输出 深克隆,方式一: CandyDeep{name='黑色', color='酒心巧克力', stuffing=Stuffing{body='酒饮料', form='液体', color='无色'}} CandyDeep{name='黑色', color='酒心巧克力', stuffing=Stuffing{body='酒饮料', form='液体', color='无色'}} +++++++++++++++++++华丽的分界线++++++++++++++++++++++ 深克隆,方式二: CandyDeep2{name='白色', color='果仁巧克力', stuffing2=Stuffing2{body='果仁', form='固体', color='棕色'}} CandyDeep2{name='白色', color='果仁巧克力', stuffing2=Stuffing2{body='果仁', form='固体', color='棕色'}} 2.结构型模式（7）2.1. 外观模式（FP）英文：Facade Pattern 定义：外观模式又叫门面模式，提供了统一的接口，用来访问子系统中的一群接口。 优点： 简化了调用过程，无需了解深入子系统 减低耦合度； 更好的层次划分； 符合LKP。 缺点： 增加子系统，拓展子系统行为容易引入风险； 不符合OCP。 最佳实践： 子系统越来越复杂，增加外观模式提供简单接口调用； 构建多层系统结构，利用外观对象作为每层的入口，简化层间调用。 举例： 客户购买现做蛋糕，客户直接和前台打交道，前台和后台(制作蛋糕,装饰,打包)传达信息，后台对于客户被透明化 创建蛋糕信息实体 public class CakeInfo { private String cakeName; private Double amount; private Integer num; @Override public String toString() { return "CakeInfo{" + "cakeName='" + cakeName + '\'' + ", amount=" + amount + ", num=" + num + '}'; } public Double getAmount() { return amount; } public void setAmount(Double amount) { this.amount = amount; } public Integer getNum() { return num; } public void setNum(Integer num) { this.num = num; } public String getCakeName() { return cakeName; } public void setCakeName(String cakeName) { this.cakeName = cakeName; } } 创建后台-制作服务 public class MakeService { public boolean makeCake(String cakeName){ System.out.println("糕点师制作"+cakeName); return true; } } 创建后台-装饰服务 public class DecorateService { public boolean decorateCake(String cakeName){ System.out.println("装饰师装饰"+cakeName); return true; } } 创建后台-打包服务 public class PackageService { public boolean packageCake(String cakeName){ System.out.println("打包师打包"+cakeName+",并转交前台"); return true; } } 创建前台服务聚合后台服务 public class FrontDeskService { private MakeService maker = new MakeService(); private DecorateService decorator = new DecorateService(); private PackageService packer = new PackageService(); public void sellCake(CakeInfo cakeInfo){ System.out.println("前台从客户接受蛋糕信息:"+cakeInfo); String cakeName = cakeInfo.getCakeName(); if(maker.makeCake(cakeName)){ if(decorator.decorateCake(cakeName)){ if(packer.packageCake(cakeName)){ System.out.println("前台收到蛋糕->转交客户->收银->销售成功"); } } } } } 测试 public class FpTest { public static void main(String[] args) { CakeInfo cakeInfo = new CakeInfo(); cakeInfo.setAmount(100.00); cakeInfo.setNum(1); cakeInfo.setCakeName("巧克力蛋糕"); FrontDeskService frontDeskService = new FrontDeskService(); frontDeskService.sellCake(cakeInfo); } } 输出 前台从客户接受蛋糕信息:CakeInfo{cakeName='巧克力蛋糕', amount=100.0, num=1} 糕点师制作巧克力蛋糕 装饰师装饰巧克力蛋糕 打包师打包巧克力蛋糕,并转交前台 前台收到蛋糕->转交客户->收银->销售成功 2.2. 装饰者模式（DP）英文：Decorator Pattern 定义：在不改变原有对象的基础之上，将功能附加到对象上，提供了比继承更有弹性的替代方案 优点： 继承的有力补充，不改变原有对象的情况下给对象拓展功能 通过使用不同的装饰类、不同的组合方式，实现不同的效果 符合OCP 缺点：增加程序复杂性 最佳实践： 拓展一个类的功能 动态给对象添加功能，并且动态撤销 举例： 客户买蛋糕，要求对蛋糕加不同材料(果切，奶油，巧克力，装饰画等)，价格也随之变动 1.创建蛋糕套餐抽象类 public abstract class CakePackage { public abstract String remark(); public abstract int price(); } 2.创建装饰器类继承蛋糕套餐抽象类 public class CakeDecorator extends CakePackage{ private CakePackage cakePackage; public CakeDecorator(CakePackage cakePackage) { this.cakePackage = cakePackage; } @Override public String remark() { return cakePackage.remark(); } @Override public int price() { return cakePackage.price(); } } 3.创建标准蛋糕套餐类 public class StandardCakePackage extends CakePackage{ @Override public String remark() { return "蛋糕胚\n"; } @Override public int price() { return 5; } } 4.创建加奶油、水果、糖果等增值套餐类 public class CreamCakePackage extends CakeDecorator { public CreamCakePackage(CakePackage cakePackage) { super(cakePackage); } @Override public String remark() { return super.remark()+"加奶油\n"; } @Override public int price() { return super.price()+5; } } public class FruitCakePackage extends CakeDecorator { public FruitCakePackage(CakePackage cakePackage) { super(cakePackage); } @Override public String remark() { return super.remark() + "加水果\n"; } @Override public int price() { return super.price()+10; } } public class CandyCakePackage extends CakeDecorator { public CandyCakePackage(CakePackage cakePackage) { super(cakePackage); } @Override public String remark() { return super.remark()+"加糖果\n"; } @Override public int price() { return super.price()+15; } } 5.测试 public class DpTest { public static void main(String[] args) { CakePackage cake = new StandardCakePackage(); cake = new CreamCakePackage(cake); cake = new FruitCakePackage(cake); cake = new CandyCakePackage(cake); System.out.println(cake.remark()+"价格："+cake.price()+"元"); } } 6.输出 蛋糕胚 加奶油 加水果 加糖果 价格：35元 2.3. 适配器模式（AP）英文：Adapter Pattern 定义：将一个类的接口转换为期望的另一个接口，使原本不兼容的类可以一起工作 优点： 提高类的透明性和复用，现有的类复用但不需改变 目标类和适配器类解耦，提高程序拓展性 符合OCP 缺点： 适配器编写过程需要全面考虑，可能会增加系统的复杂性 降低代码可读性 最佳实践：已存在的类，它的方法和需求不匹配时（方法结果相同或者相似） 举例： 原有的蛋糕产品线，新增一个物料产品线(水果、奶油等)，在不修改原产品线的同时,两个产品线共同工作 创建蛋糕产品线类 public class Cake { public void makeCakes(){ System.out.println("生产蛋糕"); } } 创建物料产品线接口 public interface Materiel { void make(); } 蛋糕产品类加入到物料产品线，创建一个适配器 //一般适配器 public class CreamCakeAdaptor extends Cake implements Materiel{ @Override public void make() { System.out.println("生产奶油预备"); super.makeCakes(); System.out.println("混合成奶油蛋糕"); } } //对象适配器 public class FruitCakeAdaptor implements Materiel{ Cake cake = new Cake(); @Override public void make() { System.out.println("生产果切预备"); cake.makeCakes(); System.out.println("混合成水果蛋糕"); } } 测试 public class ApTest { public static void main(String[] args) { CreamCakeAdaptor creamCakeAdaptor = new CreamCakeAdaptor(); creamCakeAdaptor.make(); System.out.println("++++++++++++++华丽的分割线+++++++++++++++"); FruitCakeAdaptor fruitCakeAdaptor = new FruitCakeAdaptor(); fruitCakeAdaptor.make(); } } 输出 生产奶油预备 生产蛋糕 混合成奶油蛋糕 ++++++++++++++华丽的分割线+++++++++++++++ 生产果切预备 生产蛋糕 混合成水果蛋糕 2.4. 享元模式（FP）英文：Flyweight Pattern 定义：提供了减少对象数量从而改善应用所需的对象结构的方式，运用共享技术有效地支持大量细粒度的对象。 优点：减少对象的创建，降低内存占用； 缺点： 关注内部状态或外部状态，关注线程安全问题；（内部状态：享元对象的属性状态，不会因为外部的改变而改变； 外部状态：方法参数） 程序的逻辑复杂化。 最佳实践： 减少对象的创建，降低内存占用； 统拥有大量相似对象，需要缓冲池的场景。 举例：制作大量相同类型的蛋糕（代码关键是通过HashMap存储对象） 创建蛋糕接口 public interface Cake { void make() throws InterruptedException; } 具体类(如：水果类型蛋糕)实现蛋糕接口 public class FruitCake implements Cake { private String name; private LocalDateTime productTime; public FruitCake(String name){ this.name = name; } public void setProductTime(LocalDateTime productTime) { this.productTime = productTime; } @Override public void make() { try { Thread.sleep(100); System.out.println(name+"生产时间："+this.productTime); } catch (InterruptedException e) { e.printStackTrace(); } } } 创建水果蛋糕的工厂 public class FruitCakeFactory { //关键点 private static final HashMap&lt;String,FruitCake> CAKE_HASH_MAP = new HashMap&lt;>(); public static FruitCake product(String name){ FruitCake fruitCake = CAKE_HASH_MAP.get(name); if(fruitCake == null){ System.out.println("没有"+name+"制作方法,学习制作方法"); fruitCake = new FruitCake(name); CAKE_HASH_MAP.put(name,fruitCake); } return fruitCake; } } 测试 public class FpTest { private static final String[] CAKE_TYPE = {"蓝莓蛋糕","火龙果蛋糕","草莓蛋糕","香蕉蛋糕"}; public static void main(String[] args) { IntStream.range(0,10).forEach((i)->{ String name = CAKE_TYPE[(int)(Math.random() * CAKE_TYPE.length)]; FruitCake cake = FruitCakeFactory.product(name); cake.setProductTime(LocalDateTime.now()); cake.make(); }); } } 输出 10次循环中，只生产了4个对象，很好的描述了系统有大量相似对象，需要缓冲池的场景。 JDK中的字符串常量池，数据库连接池等都是用的享元模式。 没有蓝莓蛋糕制作方法,学习制作方法 蓝莓蛋糕生产时间：2020-12-13T10:49:17.647076600 蓝莓蛋糕生产时间：2020-12-13T10:49:17.779721700 没有草莓蛋糕制作方法,学习制作方法 草莓蛋糕生产时间：2020-12-13T10:49:17.881450300 草莓蛋糕生产时间：2020-12-13T10:49:17.982180600 没有香蕉蛋糕制作方法,学习制作方法 香蕉蛋糕生产时间：2020-12-13T10:49:18.085903500 蓝莓蛋糕生产时间：2020-12-13T10:49:18.204594900 蓝莓蛋糕生产时间：2020-12-13T10:49:18.305322300 香蕉蛋糕生产时间：2020-12-13T10:49:18.430981100 草莓蛋糕生产时间：2020-12-13T10:49:18.541684900 蓝莓蛋糕生产时间：2020-12-13T10:49:18.645407200 2.5. 组合模式（CP）英文：Composite Pattern 定义：又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。 优点： 层次清晰 客户端不必关系层次差异，方便控制 符合OCP 缺点：树形处理较为复杂 最佳实践： 客户端可以忽略组合对象与单个对象的差异 处理树形结构数据 举例：菜单按钮组成的树形 创建菜单按钮组合抽象类 public abstract class MenuButton { public void add(MenuButton menuButton) { throw new UnsupportedOperationException("不支持创建操作"); } public String getName() { throw new UnsupportedOperationException("不支持名称获取"); } public String getType() { throw new UnsupportedOperationException("不支持类型获取"); } public String getIcon() { throw new UnsupportedOperationException("不支持图标"); } public void print() { throw new UnsupportedOperationException("不支持打印操作"); } } 创建按钮类 public class Button extends MenuButton{ private String name; public Button(String name) { this.name = name; } @Override public String getName() { return name; } @Override public String getType(){ return "按钮"; } @Override public void print() { System.out.println(getName() + "[" + getType() + "]"); } } 创建菜单类 public class Menu extends MenuButton { private List&lt;MenuButton> items = new ArrayList&lt;>(); private String name; private String icon; private Integer level; public Menu(String name, String icon, Integer level) { this.name = name; this.icon = icon; this.level = level; } @Override public void add(MenuButton menuButton){ items.add(menuButton); } @Override public String getName() { return this.name; } @Override public String getType() { return "菜单"; } @Override public String getIcon() { return this.icon; } @Override public void print() { System.out.println(getIcon() + getName() + "[" + getType() + "]"); for (MenuButton item : items) { if (this.level != null) { for (int i = 0; i &lt; this.level; i++) { System.out.print(" "); } } item.print(); } } } 测试 public class CpTest { public static void main(String[] args) { Menu userMenu = new Menu("用户管理", "🧑", 2); Button createUser = new Button("新增用户"); Button updateUser = new Button("修改用户"); Button deleteUser = new Button("删除用户"); userMenu.add(createUser); userMenu.add(updateUser); userMenu.add(deleteUser); Menu logMenu = new Menu("操作日志", "📃", 2); Button export = new Button("导出Excel"); logMenu.add(export); Menu systemMenu = new Menu("系统管理", "🔨", 1); systemMenu.add(userMenu); systemMenu.add(logMenu); systemMenu.print(); } } 输出 🔨系统管理[菜单] 🧑用户管理[菜单] 新增用户[按钮] 修改用户[按钮] 删除用户[按钮] 📃操作日志[菜单] 导出Excel[按钮] 2.6. 桥接模式（BP）英文：Bridge Pattern 定义：将抽象部分和具体实现部分分离，使它们都可以独立变化。通过组合的方式建立两个类之间的关系，而不是通过继承。 优点： 分离抽象部分和具体实现部分 提高了系统可拓展性 符合OCP和合成复用原则 缺点：增加了系统的理解和设计难度 最佳实践： 抽象和实体实现之间增加更多的灵活性 一个类存在多个独立变化的维度，并且需要独立拓展 不希望使用继承 举例： 1.创建蛋糕的接口类 public interface Cake { Cake makeCake(); void getCake(); } 2.创建蛋糕接口的实现类 水果蛋糕 public class FruitCake implements Cake { @Override public Cake makeCake() { System.out.println("制作水果蛋糕"); return new FruitCake(); } @Override public void getCake() { System.out.println("获得水果蛋糕"); } } 奶油蛋糕 public class CreamCake implements Cake { @Override public Cake makeCake() { System.out.println("制作奶油蛋糕"); return new CreamCake(); } @Override public void getCake() { System.out.println("获得奶油蛋糕"); } } 3.创建店铺抽象类,通过属性的方式和蛋糕接口相关联，目的是可以在不同的店铺实现类中灵活地制作各种蛋糕 店铺抽象类 public abstract class Store { protected Cake cake; public Store(Cake cake){ this.cake = cake; } abstract Cake makeCake(); } 店铺实现类 public class ZhangSanStore extends Store{ public ZhangSanStore(Cake cake) { super(cake); } @Override Cake makeCake() { System.out.println("张三的蛋糕店"); return cake.makeCake(); } } public class LiSiStore extends Store { public LiSiStore(Cake cake) { super(cake); } @Override Cake makeCake() { System.out.println("李四的蛋糕店"); return cake.makeCake(); } } 4.测试 public class BpTest { public static void main(String[] args) { ZhangSanStore zhangSanStore = new ZhangSanStore(new FruitCake()); Cake cake = zhangSanStore.makeCake(); cake.getCake(); System.out.println("++++++++++++++++华丽的分割线+++++++++++++++++"); LiSiStore liSiStore = new LiSiStore(new CreamCake()); Cake cake1 = liSiStore.makeCake(); cake1.getCake(); } } 5.输出 张三的蛋糕店 制作水果蛋糕 获得水果蛋糕 ++++++++++++++++华丽的分割线+++++++++++++++++ 李四的蛋糕店 制作奶油蛋糕 获得奶油蛋糕 2.7. 代理模式（PP）英文：Proxy Pattern 定义：为其他对象提供一种代理，以控制对这个对象的访问，代理对象在客户端和目标对象之间起到了中介的作用 优点： 将代理对象和真实被调用的目标对象分离 降低耦合，拓展性好 保护目标对象，增强目标对象 缺点： 造成类的数目增加，增加复杂度 客户端和目标对象增加代理对象，会造成处理速度变慢 最佳实践： 保护目标对象 增强目标对象 代理分类 功能 缺点 静态代理 通过在代码中显式地定义了一个代理类，在代理类中通过同名的方法对目标对象的方法进行包装，客户端通过调用代理类的方法来调用目标对象的方法。 每需要代理一个类，就需要手写对应的代理类 动态代理 JDK的动态代理只能代理接口，通过接口的方法名在动态生成的代理类中调用业务实现类的同名方法。 CGLib代理 通过继承来实现，生成的代理类就是目标对象类的子类，通过重写业务方法来实现代理 Spring对代理模式的拓展 1. 当Bean有实现接口时，使用JDK动态代理； 2. 当Bean没有实现接口时，使用CGLib代理。 举例： 1.静态代理 （1）创建糖果类接口 public interface ICandyService { void makeCandy(); } （2）创建糖果类实现类 public class CandyServiceServiceImpl implements ICandyService { @Override public void makeCandy() { System.out.println("制作糖果"); } } （3）创建代理对象 public class ProxyService { private ICandyService iCandyService; public void makeCandy(){ beforeMethod(); iCandyService = new CandyServiceServiceImpl(); iCandyService.makeCandy(); afterMethod(); } private void afterMethod() { System.out.println("包装"); } private void beforeMethod() { System.out.println("准备材料"); } } （4）测试 public class PpTest { public static void main(String[] args) { System.out.println("[代理模式-静态代理]"); ProxyService proxyService = new ProxyService(); proxyService.makeCandy(); } } （5）输出 [代理模式-静态代理] 准备材料 制作糖果 包装 2.动态代理 （1）创建饼干类接口 public interface IBiscuitService { void makeBiscuit(String ingredients); } （2）创建饼干类实现类 public class BiscuitServiceImpl implements IBiscuitService { @Override public void makeBiscuit(String ingredients) { System.out.println("制作"+ingredients+"饼干"); } } （3）创建动态代理 public class DynamicProxy implements InvocationHandler { // 代理的目标对象 private Object object; public DynamicProxy(Object object) { this.object = object; } public Object proxy(){ Class&lt;?> clazz = object.getClass(); return Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this); } /** * @param proxy 动态生成的代理对象 * @param method 代理方法 * @param args 代理方法的方法参数 * @return 结果 * @throws Throwable 异常 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { beforeMethod(object); // 反射执行代理对象的目标方法 Object result = method.invoke(object, args); afterMethod(object); return result; } private void beforeMethod(Object object) { if (object instanceof IBiscuitService) { System.out.println("准备饼干配料"); } else if (object instanceof ICandyService) { System.out.println("准备糖果配料"); } else { throw new RuntimeException("暂不支持代理" + object.getClass() + "类型"); } } private void afterMethod(Object object) { if (object instanceof IBiscuitService) { System.out.println("包装饼干"); } else if (object instanceof ICandyService) { System.out.println("包装糖果"); } else { throw new RuntimeException("暂不支持代理" + object.getClass() + "类型"); } } } （4）测试 public class Pp2Test { public static void main(String[] args) { System.out.println("[代理模式-动态代理]"); ICandyService candyService = (ICandyService) new DynamicProxy(new CandyServiceServiceImpl()).proxy(); candyService.makeCandy(); System.out.println("++++++++++++++++华丽的分割线+++++++++++++++++"); IBiscuitService biscuitService = (IBiscuitService) new DynamicProxy(new BiscuitServiceImpl()).proxy(); biscuitService.makeBiscuit("草莓"); System.out.println("++++++++++++++++华丽的分割线+++++++++++++++++"); biscuitService.makeBiscuit("奶油"); } } （5）输出 [代理模式-动态代理] 准备糖果配料 制作糖果 包装糖果 ++++++++++++++++华丽的分割线+++++++++++++++++ 准备饼干配料 制作草莓饼干 包装饼干 ++++++++++++++++华丽的分割线+++++++++++++++++ 准备饼干配料 制作奶油饼干 包装饼干 3.CGLib代理 ​ 通过继承来实现，生成的代理类就是目标对象类的子类，通过重写业务方法来实现代理。 4.Spring对代理模式的扩展 ​ 可以通过以下配置强制使用CGLib代理; spring: aop: proxy-target-class: true 3.行为型模式（11）3.1. 模板方法模式（TP）英文：Template Pattern 定义：模板方法模式定义了一个流程的骨架，由多个方法组成。并允许子类为一个或多个步骤提供实现。简而言之就是公共的不变的部分由父类统一实现，变化的部分由子类来个性化实现。 优点： 提高复用性 提高拓展性 OCP 缺点： 类的数目增加 增加了系统实现的复杂度 父类添加新的抽象方法，所有子类都要改一遍 最佳实践： 举例：外卖1.创建固定流程抽象类 public abstract class Takeaway { final void order() { System.out.println("(流程固定)下单"); } final void packageSend() { System.out.println("(流程固定)打包派送"); } protected abstract void make(); protected boolean needTableware() { return true; } final void flow() { this.order(); this.make(); if (needTableware()) { System.out.println("赠送一次性餐具"); } this.packageSend(); } } 2.创建子类实现类 public class CakeTakeaway extends Takeaway{ @Override protected void make() { System.out.println("制作蛋糕"); } @Override protected boolean needTableware(){ return super.needTableware(); } } public class BiscuitTakeaway extends Takeaway{ @Override protected void make() { System.out.println("制作饼干"); } @Override protected boolean needTableware() { return false; } } 3.测试 public class TpTest { public static void main(String[] args) { CakeTakeaway cakeTakeaway = new CakeTakeaway(); cakeTakeaway.flow(); System.out.println("++++++++++++++华丽的分割线+++++++++++++++"); BiscuitTakeaway biscuitTakeaway = new BiscuitTakeaway(); biscuitTakeaway.flow(); } } 4.实现 (流程固定)下单 制作蛋糕 赠送一次性餐具 (流程固定)打包派送 ++++++++++++++华丽的分割线+++++++++++++++ (流程固定)下单 制作饼干 (流程固定)打包派送 3.2. 迭代器模式（IP）英文：Iterator Pattern 定义：迭代器模式，又称游标模式。这种模式提供一种方法访问一个容器对象中各个元素，而又不需要暴露该对象的内部细节。 优点： 1.它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。替换迭代器就可以切换遍历方法。 2.迭代器简化了聚合类。聚合对象可以不用自己再提供遍历方法。 3.在迭代器模式中由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足“开闭原则”的要求。 缺点： 1.由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器来，类的个数成对增加，这在一定程度上增加了系统的复杂性。 2.抽象迭代器设计难度相对较大，需要充分考虑到系统将来的扩展，，例如JDK内置迭代器Iterator就无法实现逆向遍历，如果需要实现逆向遍历，只能通过其子类ListIterator等来实现，而ListIterator迭代器无法用于操作Set类型的聚合对象。 最佳实践： 1.访问一个聚合对象的内容而无须暴露它的内部表示。将聚合对象的访问与内部数据的存储分离，使得访问聚合对象时无须了解其内部实现细节。 2.需要为一个聚合对象提供多种遍历方式。 3.为遍历不同聚合结构提供统一的接口，该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性的操作该接口。 举例： 1.创建抽象容器 public interface Aggregate { void add(Object obj); void remove(Object obj); Iterator iterator(); } 2.创建容器实现类 public class ConcreteAggregate implements Aggregate{ private List list = new ArrayList(); @Override public void add(Object obj) { list.add(obj); } @Override public void remove(Object obj) { list.remove(obj); } @Override public Iterator iterator() { return new ConcreteIterator(list); } } 3.创建抽象迭代器 public interface Iterator { Object next(); boolean hasNext(); } 4.创建具体迭代器实现类 public class ConcreteIterator implements Iterator { private List list = new ArrayList(); private int cursor = 0; public ConcreteIterator(List list) { this.list = list; } @Override public Object next() { Object obj = null; if (this.hasNext()) { obj = this.list.get(cursor++); } return obj; } @Override public boolean hasNext() { if (cursor == list.size()) { return false; } return true; } } 5.测试 public class IpTest { public static void main(String[] args) { Aggregate ag = new ConcreteAggregate(); ag.add("a"); ag.add("b"); ag.add("c"); Iterator it = ag.iterator(); while(it.hasNext()){ String str = (String)it.next(); System.out.println(str); } } } 6.输出 a b c 3.3. 策略模式（SP）英文：Strategy Pattern 定义：策略模式定义了算法家族，分别封装起来，让它们之间可以互相替换。此模式让算法的变化不会影响到使用算法的用户。策略模式常用于消除大量的if else代码。 优点： 缺点： 最佳实践： 系统有很多类，它们的区别仅仅在于行为不同 一个系统需要动态地在几种算法中选择一种 举例：促销活动 1.创建活动接口 public interface Activity { void discount(); } 2.创建多接口实现类 public class StrategyOne implements Activity{ @Override public void discount() { System.out.println("满减返现"); } } public class StrategyTwo implements Activity { @Override public void discount() { System.out.println("满减打折"); } } 3.测试 public class SpTest { public static void main(String[] args) { String plan = "A"; if("A".equalsIgnoreCase(plan)){ StrategyOne strategyOne = new StrategyOne(); strategyOne.discount(); }else if("B".equalsIgnoreCase(plan)){ StrategyTwo strategyTwo = new StrategyTwo(); strategyTwo.discount(); }else{ throw new RuntimeException("暂不支持活动策略"); } } } 4.输出 满减返现 3.4. 解释器模式（IP）– TODO英文：Interpreter Pattern 定义： 优点： 缺点： 最佳实践： 举例：最难模式，不常用，后补充 3.5. 观察者模式（OP）英文：Observer Pattern 定义：观察者模式定义了对象之间的一对多依赖，让多个观察者同时监听某个主题对象，当主体对象发生变化时，它的所有观察者都会收到响应的通知。 优点： 观察者和被观察者之间建立一个抽象的耦合； 观察者模式支持广播通信。 缺点： 观察者之间有过多的细节依赖，提高时间消耗及程序复杂度 应避免循环调用 最佳实践： 举例：公众号推送文章 1.创建被观察者(公众号) public class OfficialAccount extends Observable { private String accountName; public OfficialAccount(String accountName) { this.accountName = accountName; } public String getAccountName() { return accountName; } public void push(Article article) { System.out.println("【"+this.accountName+"】" +"发起推送>>>"+article.getAuthor()+"的《"+article.getName()+"》"); // 设置标识位 changed = true，表示被观察者发生了改变 setChanged(); // 通知观察者，可以给观察者传递数据 notifyObservers(article); } } 2.创建观察者（订阅者） public class Followers implements Observer { private String name; public Followers(String name) { this.name = name; } @Override public void update(Observable o, Object arg) { OfficialAccount officialAccount = (OfficialAccount) o; Article article = (Article) arg; System.out.println(name+":::收到【"+officialAccount.getAccountName()+"】的推送:"+article.getAuthor()+"的《"+article.getName()+"》"); } } 3.创建推送对象（文章） public class Article { private String name; private String author; public Article(String name, String author) { this.name = name; this.author = author; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } } 4.测试 public class OpTest { public static void main(String[] args) { OfficialAccount officialAccount = new OfficialAccount("JAVA大本营"); //添加订阅者 Followers follower1 = new Followers("路人甲"); officialAccount.addObserver(follower1); Followers follower2 = new Followers("路人乙"); officialAccount.addObserver(follower2); //推送 Article article = new Article("大话设计模式","菜鸟"); officialAccount.push(article); } } 5.输出 【JAVA大本营】发起推送>>>菜鸟的《大话设计模式》 路人乙:::收到【JAVA大本营】的推送:菜鸟的《大话设计模式》 路人甲:::收到【JAVA大本营】的推送:菜鸟的《大话设计模式》 3.6. 备忘录模式（MP）英文：Memento Pattern 定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。 优点： 1.它提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原。 2.备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。备忘录保存了原发器的状态，采用列表、堆栈等集合来存储备忘录对象可以实现多次撤销操作。 缺点：资源消耗过大，如果需要保存的原发器类的成员变量太多，就不可避免需要占用大量的存储空间，每保存一次对象的状态都需要消耗一定的系统资源。 最佳实践： 保存一个对象在某一个时刻的全部状态或部分状态，这样以后需要时它能够恢复到先前的状态，实现撤销操作。 防止外界对象破坏一个对象历史状态的封装性，避免将对象历史状态的实现细节暴露给外界对象。 名称 作用 原发器类（Originator） 创建一个备忘录对象，使用备忘录存储它的内部状态 负责人类（CareTaker） 负责保存好备忘录对象，不能检查或操作备忘录的内容 备忘录类（Memento） 将原发器的内部状态存储起来，原发器根据需要决定备忘录存储原发器的哪些内部状态 举例：冒险岛闯关 1.创建游戏类 public class AdventureIslandGame { /**关卡*/ private Integer point; /**建档*/ public GameMemento createMemento(Integer point){ return new GameMemento(point); } /**开始游戏*/ public void play(){ point = 1; } /**恢复备份*/ public void restore(GameMemento gameMemento){ this.point = gameMemento.getPoint(); } public Integer getPoint() { return point; } public void setPoint(Integer point) { this.point = point; } } 2.创建备份 public class GameMemento { /**关卡*/ private Integer point; /** * 备份关卡 */ public GameMemento(int point){ this.point = point; } public Integer getPoint() { return point; } public void setPoint(Integer point) { this.point = point; } } 3.创建备份管理类 public class Caretaker { private GameMemento gameMemento; /**恢复备份*/ public GameMemento retrieveMemento(){ return this.gameMemento; } /**保存备份*/ public void saveMemento(GameMemento gameMemento){ this.gameMemento = gameMemento; } } 4.测试 public class MpTest { public static void main(String[] args) { System.out.println("[冒险岛闯关游戏]"); AdventureIslandGame game = new AdventureIslandGame(); System.out.println("游戏开始"); game.play(); System.out.println("进入第"+game.getPoint()+"关"); System.out.println("击杀第"+game.getPoint()+"关boss,进入下一关"); System.out.println("创建新档..."); GameMemento gameMemento = game.createMemento(game.getPoint()); Caretaker caretaker = new Caretaker(); caretaker.saveMemento(gameMemento); System.out.println("~~~~~~第"+game.getPoint()+"关,存档完成~~~~~~"); game.setPoint(game.getPoint()+1); System.out.println("进入第"+game.getPoint()+"关"); System.out.println("击杀第"+game.getPoint()+"关boss,进入下一关"); gameMemento.setPoint(game.getPoint()); caretaker.saveMemento(gameMemento); System.out.println("~~~~~~第"+game.getPoint()+"关,存档完成~~~~~~"); game.setPoint(game.getPoint()+1); System.out.println("进入第"+game.getPoint()+"关"); System.out.println("被第"+game.getPoint()+"关boss杀死,游戏结束"); System.out.println("回退关卡..."); game.restore(caretaker.retrieveMemento()); System.out.println("~~~~~~回退完成,当前关卡第"+game.getPoint()+"关~~~~~~"); game.setPoint(game.getPoint()+1); System.out.println("获取当前关卡：进入第"+game.getPoint()+"关"); } } 5.输出 [冒险岛闯关游戏] 游戏开始 进入第1关 击杀第1关boss,进入下一关 创建新档... 进入第2关 击杀第2关boss,进入下一关 ​~~~~~~第2关,存档完成~~~~~~ 进入第3关 被第3关boss杀死,游戏结束 回退关卡... ​~~~~~~回退完成,当前关卡第2关~~~~~~ 获取当前关卡：进入第3关 3.7. 命令模式（CP）英文：Command Pattern 定义： 将一个请求封装为一个对象，从而使我们可用不同的请求对用户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。 名称 作用 抽象命令者（Command） 定义命令的接口，声明执行的方法。 具体命令类（ConcreteCommand） 命令接口实现对象，是“虚”的实现；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。 接收者（Receiver） 真正执行命令的对象。任何类都可能成为一个接收者，只要它能够根据命令要求实现的相应功能。 调用者（Invoker） 要求命令要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这是用户端真正出发命令并要求命令执行相应操作的地方，也就是说，相当于使用命令对象的入口。 具体命令对象（client） 创建具体的命令对象，并且设置命令对象的接收者。也可以理解为装配者。 优点： 降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。 新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求。 缺点：使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用。 最佳实践： 1.系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。 2.系统需要在不同的时间指定请求、将请求排队和执行请求。 举例：Siri语音助手 1.创建命令接口 public interface Command { //执行命令 void execute(); } 2.创建具体实现命令实现类 public class OpenCommand implements Command { private Application app; public OpenCommand(Application app){ this.app = app; } @Override public void execute() { app.on(); } } public class CloseCommand implements Command { private Application app; public CloseCommand(Application app){ this.app = app; } @Override public void execute() { app.off(); } } 3.创建应用抽象类 public abstract class Application { public abstract void on(); public abstract void off(); } 4.创建应用实现类 public class WeChat extends Application { @Override public void on() { System.out.println("微信打开了"); } @Override public void off() { System.out.println("微信关闭了"); } } public class Alipay extends Application { @Override public void on() { System.out.println("支付宝打开了"); } @Override public void off() { System.out.println("支付宝关闭了"); } } 5.实现命令发起者 public class Siri { private Command command; /** * 设置要执行的命令 * @param command 命令 */ public void setCommand(Command command){ this.command = command; } /** * 执行命令 */ public void executeCommand(){ command.execute(); } } 6.测试 public class CpTest { public static void main(String[] args) { Siri siri = new Siri(); System.out.println("嘿 siri， 打开微信"); Application weChat = new WeChat(); Command command = new OpenCommand(weChat); //siri传递命令 siri.setCommand(command); siri.executeCommand(); System.out.println("嘿 siri，打开支付宝"); Application alipay = new Alipay(); command = new OpenCommand(alipay); //siri传递命令 siri.setCommand(command); siri.executeCommand(); } } 7.输出 嘿 siri， 打开微信 微信打开了 嘿 siri，打开支付宝 支付宝打开了 3.8. 中介者模式（MP）英文：Mediator Pattern 定义：中介者模式是指用一个中介对象来封装一系列的对象交互。中介者使个对象不需要显示的相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 优点： 1.简化了对象之间的交互，它用中介者和同事的一对多交互代替了原来同事之间的多对多交互，一对多关系更容易理解、维护扩展，将原本难以理解的网状结构转换成相对简单的星型结构。 2.可将各同事对象解耦。中介者有利于各同事之间的松耦合，我们可以独立的改变和复用每一个同事和中介者，增加新的中介者和新的同事类都比较方便，更好的符合“开闭原则”。 3.可以减少子类生成，中介者将原本分布于多个对象间的行为集中在一起，改变这些行为只需生成新的中介者子类即可，这使得各个同事类可被重用，无须对同事类进行扩展。 缺点：在具体中介者类中包含了大量同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。 最佳实践： 1.系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。 2.一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。 3.想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的具体中介者类。 举例：同事类相互影响 1.创建同事类抽象类 public abstract class Colleague { protected int number; public int getNumber() { return number; } public void setNumber(int number){ this.number = number; } public abstract void setNumber(int number, Mediator mediator); } 2.创建同事类实现类 public class ColleagueA extends Colleague{ @Override public void setNumber(int number, Mediator mediator) { this.number = number; mediator.A2B(); } } public class ColleagueB extends Colleague{ @Override public void setNumber(int number, Mediator mediator) { this.number = number; mediator.B2A(); } } 3.创建中介者抽象类 public abstract class Mediator { protected Colleague ca; protected Colleague cb; public Mediator(Colleague a, Colleague b) { this.ca = a; this.cb = b; } public abstract void A2B(); public abstract void B2A(); } 4.创建中介者实现类 public class MediatorImpl extends Mediator { public MediatorImpl(Colleague a, Colleague b) { super(a, b); } @Override public void A2B() { int number = ca.getNumber(); cb.setNumber(number*100); } @Override public void B2A() { int number = cb.getNumber(); ca.setNumber(number/100); } } 5.测试 public class MpTest { public static void main(String[] args) { ColleagueA colleagueA = new ColleagueA(); ColleagueB colleagueB = new ColleagueB(); Mediator mediator = new MediatorImpl(colleagueA,colleagueB); System.out.println("++++++++++++通过设置A影响B++++++++++++"); colleagueA.setNumber(1000,mediator); System.out.println("A的值为："+colleagueA.getNumber()); System.out.println("B的值为A的10倍："+colleagueB.getNumber()); System.out.println("++++++++++++通过设置B影响A++++++++++++"); colleagueB.setNumber(2000,mediator); System.out.println("B的值为："+colleagueB.getNumber()); System.out.println("A的值为B的0.1倍："+colleagueA.getNumber()); } } 6.输出 ++++++++++++通过设置A影响B++++++++++++ A的值为：1000 B的值为A的10倍：100000 ++++++++++++通过设置B影响A++++++++++++ B的值为：2000 A的值为B的0.1倍：20 3.9. 职责链模式（CRP）英文：Chain of Responsibility Pattern 定义：责任链模式是为了避免请求的发送者和接收者之间的耦合关系，使多个接收对象都有机会处理请求。将这些对象练成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 职责链分类 定义 纯的职责链模式 纯的职责链模式要求一个具体的处理者对象只能在两个行为中选择一个：一个是承担责任；二是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又把责任向下传的情况。在一个纯的职责链中，一个请求必须被某一个处理者对象所接受。 不纯的职责链模式 不纯的职责链模式中允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收。 优点： 1.请求不需要指出被哪个对象处理了，这样的效果是请求者和接收者之间的解耦，而且链中的对象也不需要清楚其他链的结构，也降低了耦合。 2.请求处理对象仅需要维护一个指向其后继者的的引用，而不需要维护所有的处理对象，简化了对象之间的相互连接。 3.在给对象分派职责时，职责链可以给我们更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责。 4.新增一个请求处理对象，不需要改动现有代码，只需要重新设置连接即可，符合“开闭原则”。 缺点： 1.如果一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理。 2.对于比较长的职责链，请求的处理可能涉及到多个处理对象，不仅增加了代码的复杂性并且系统性能也将受到一定影响，而且在进行代码调试时不太方便。 3.若建链不当，可能会造成循环调用，将导致系统陷入死循环。 最佳实践： 1.有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的。 2.在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3.可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。其实在我们日常开发中也会有适用到责任链模式的场景，try/catch、servlet(各个servelt互相调用)、以及filter等 举例：请假审批 1.创建请假对象 public class Leave { //姓名 private String name; //部门 private String department; //天数 private Double day; //原因 private String cause; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDepartment() { return department; } public void setDepartment(String department) { this.department = department; } public Double getDay() { return day; } public void setDay(Double day) { this.day = day; } public String getCause() { return cause; } public void setCause(String cause) { this.cause = cause; } @Override public String toString() { return "Leave{" + "name='" + name + '\'' + ", department='" + department + '\'' + ", day=" + day + ", cause='" + cause + '\'' + '}'; } } 2.创建审批者抽象类 public abstract class Approver { //审核人名 public String name; //下一个审核人 public Approver nextApprove; public Approver(String name) { this.name = name; } //设置下一个审核人 public void setNextApprove(Approver nextApprove) { this.nextApprove = nextApprove; } //审核 public abstract void approval(Leave leave); } 3.创建审批者实现类 public class Manager extends Approver { public Manager(String name) { super(name); } @Override public void approval(Leave leave) { if(leave.getDay() &lt; 5){ System.out.println(name+"权限范围内,批准了"); System.out.println("结束审批"); }else{ if(Objects.nonNull(nextApprove)){ System.out.println(name+"权限范围外,移交上一级领导"); this.nextApprove.approval(leave); }else{ System.out.println("领导不在,审批质押"); } } } } public class Boss extends Approver { public Boss(String name) { super(name); } @Override public void approval(Leave leave) { if (leave.getDay() > 5 &amp;&amp; leave.getDay() &lt; 10) { System.out.println(name+"：未超预期,批准"); System.out.println("结束审批"); } else { System.out.println(name+"时间太长了,影响公司挣钱,驳回"); System.out.println("结束审批"); } } } 4.测试 public class CrpTest { public static void main(String[] args) { Leave leave = new Leave(); leave.setName("小王"); leave.setDepartment("研发部"); leave.setDay(8.0D); leave.setCause("结婚"); Manager manager = new Manager("李经理"); Boss boss = new Boss("钱总"); manager.setNextApprove(boss); System.out.println("请假发起者："+leave.toString()); manager.approval(leave); } } 5.输出 请假发起者：Leave{name='小王', department='研发部', day=8.0, cause='结婚'} 李经理权限范围外,移交上一级领导 钱总：未超预期,批准 结束审批 3.10. 访问者模式（VP）英文：Visitor Pattern 定义：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。 优点： 1.符合单一职责原则 2.优秀的扩展性 3.灵活性 缺点： 1.具体元素对访问者公布细节，违反了迪米特原则 2.具体元素变更比较困难 3.违反了依赖倒置原则，依赖了具体类，没有依赖抽象。 最佳实践： 1.对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2.需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。 注意事项：访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。 举例： 场景： CEO和CTO开始评定员工一年的工作绩效，员工分为工程师和经理，CTO关注工程师的代码量、经理的新产品数量；CEO关注的是工程师的KPI和经理的KPI以及新产品数量。由于CEO和CTO对于不同员工的关注点是不一样的，这就需要对不同员工类型进行不同的处理。访问者模式此时可以派上用场了。 1.创建抽象员工类 public abstract class Staff { //员工姓名 public String name; //员工KPI public Integer kpi; public Staff(String name) { this.name = name; this.kpi = new Random().nextInt(10); } //接受visitor访问 public abstract void accept(Visitor visitor); } 2.创建员工实现类 public class Engineer extends Staff { public Engineer(String name) { super(name); } @Override public void accept(Visitor visitor) { visitor.visit(this); } public int getCodeLines(){ return new Random().nextInt(100000); } } public class Manager extends Staff { public Manager(String name) { super(name); } @Override public void accept(Visitor visitor) { visitor.visit(this); } public int getProductNum(){ return new Random().nextInt(10); } } 3.创建观接口 public interface Visitor { // 访问工程师类型 void visit(Engineer engineer); // 访问经理类型 void visit(Manager manager); } 4.创建观察者接口实现类 public class CEO implements Visitor { private String name; public CEO(String name) { this.name = name; } @Override public void visit(Engineer engineer) { System.out.println(name+"查看:"+engineer.name+"的KPI："+engineer.kpi); } @Override public void visit(Manager manager) { System.out.println(name+"查看:"+manager.name+"的KPI："+manager.kpi); } } public class CTO implements Visitor { private String name; public CTO(String name) { this.name = name; } @Override public void visit(Engineer engineer) { System.out.println(name+"查看:"+engineer.name+"的代码数："+engineer.getCodeLines()); } @Override public void visit(Manager manager) { System.out.println(name+"查看:"+manager.name+"的产品数："+manager.getProductNum()); } } 5.创建报表类 public class ExcelReport { private List&lt;Staff> staffs = new ArrayList&lt;>(); public ExcelReport(){ staffs.add(new Manager("李经理")); staffs.add(new Manager("张经理")); staffs.add(new Engineer("小王")); staffs.add(new Engineer("小李")); } public void showReport(Visitor visitor){ for (Staff staff : staffs) { staff.accept(visitor); } } } 6.测试 public class VpTest { public static void main(String[] args) { ExcelReport excelReport = new ExcelReport(); excelReport.showReport(new CEO("吴董")); excelReport.showReport(new CTO("程总")); } } 7.输出 吴董查看:李经理的KPI：3 吴董查看:张经理的KPI：7 吴董查看:小王的KPI：5 吴董查看:小李的KPI：8 程总查看:李经理的产品数：1 程总查看:张经理的产品数：3 程总查看:小王的代码数：55701 程总查看:小李的代码数：31420 3.11. 状态模式（SP）英文：State Pattern 定义：允许一个对象在其状态改变时，改变它的行为，对象看起来似乎修改了它的类。 优点： 1.封装了状态的转换规则，在状态模式中可以将状态转换的工作封装在环境类或具体的状态类中，可以对状态转换码进行集中管理，而不是分散在一个个的业务中。 2.将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为。 3.允许状态转换逻辑与状态对象合为一体，而不是提供一个巨大的条件语句块，状态模式可以让我们避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起。 缺点： 1.状态模式的使用必然会增加系统中类和对象的个数，导致系统运行开销增大。 2.状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，增加系统设计的难度。 最佳实践： 1.对象的行为依赖于它的状态（如某些属性值），状态的改变将导致行为的变化。 2.在代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，并且导致客户类与类库之间的耦合增强。 举例：请假审核 1.创建请假对象 public class LeaveApply { //申请单初始状态是待提交状态 private ApplyState applyState = new Audit(); //设置状态 public void setState(ApplyState state){ applyState = state; } //状态变化后,更新对象自身的行为 public void getResult(){ applyState.changeHandle(); } } 2.创建审核状态接口 public interface ApplyState { //状态变化处理操作 void changeHandle(); } 3.创建各审核状态具体实现类 public class Audit implements ApplyState { @Override public void changeHandle() { System.out.println("[审核中]"); } } public class AuditPass implements ApplyState { @Override public void changeHandle() { System.out.println("[审核通过]"); } } public class AuditReject implements ApplyState{ @Override public void changeHandle() { System.out.println("[审核未通过]"); } } 4.测试 public class SpTest { public static void main(String[] args) { LeaveApply leaveApply = new LeaveApply(); leaveApply.getResult(); leaveApply.setState(new AuditPass()); leaveApply.getResult(); leaveApply.setState(new AuditReject()); leaveApply.getResult(); } } 5.输出 [审核中] [审核通过] [审核未通过] document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统优化小记：CPU长时间满负荷运行]]></title>
    <url>%2F2020%2F11%2F28%2Fsystem-optimize%2F</url>
    <content type="text"><![CDATA[CPU长时间满负荷运行,一次入门级降CPU系统优化实战 现象用户量增大,线上一个Java单应用服务长时间占用服务器CPU达到400%，使得接口响应速度非常慢，线程拥堵，出现各种响应超时问题，即便有时候没有用户操作，也会长时间占用大量CPU和内存。 解决思路找出哪些程序处理满，进行排查优化（业务流程调整、锁关闭、SQL优化、一些耗性能的程序不使用内存方案） 解决方案linux命令排查 + Arthas监控 + Druid sql 监控 解决方案：一、Linux命令排查，方法如下：1.显示进程列表，定位进程号在top命令下，按shift+H查看cpu占用最高进程(PID:21659) 2.显示线程列表，定位线程号，找到哪些线程占用高耗时长命令：ps -mp pid -o THREAD,tid,time | sort -rn | more ex：ps -mp 21659 -o THREAD,tid,time （shift+H） ps：截图中pid写成24275原因是由于中途重启过一次程序，原PID：21659 变更成 PID：24275，实则都是同一个Java程序 其中TID：24737、24742、24745，耗时较长占用CPU率较高 3.将线程号转为系统可识别的16进制命令：printf "%x\n" tid 4.打印线程的堆栈信息，分析原因命令： jstack PID | grep [16进制TID] -A 30 ex：查看线程24737的堆栈信息， jstack 24275 | grep 60a1 -A 30 5.如果嫌以上操作麻烦，也可直接使用 jstack PID，打印出所有堆栈，进行查看。二、辅助神器Arthas程序监控本次不在说明，后出专题讲解，附上官方文档： Arthas传送门 三、辅助Druid SQL监控本次也不在说明，后出专题讲解，附一张图 最终问题定位在堆内存占满，新创建对象时无法分配足够的内存，引起频繁GC 1.程序频繁请求RPC接口得到的响应慢，耗时过大； 解决方案：由于获取的数据实时性要求不高，改为缓存处理，避免实时请求。 2.客户端频繁请求某个接口，且接口中的sql效率非常低,导致了sql连接长时间被占用。 解决方案：由于该接口历史遗留，且和对应的调用客户端同事确认该接口现今已用处不大，因此注释掉了该接口。 3.频繁收到回调，随开启了多线程处理但由于有线程锁，使得其他线程被block，实则依然是个单线程处理，消费速度赶不上生产速度，线程积压。 解决方案：确保安全的情况下，关闭了线程锁。 4.代码逻辑不合理; 解决方案：重新调整代码逻辑 5.对数据库操作过于频繁; 解决方案：调整逻辑，优化sql（调整sql，加索引，避免全表扫描），尽量少操作数据库，多使用缓存对数据进行操作 总结经过此次排查，虽最终问题得以缓解，但深知系统内依然存在很多其他性能问题，暴露出对JVM知识的欠缺，以及Java代码、SQL功底需要持续加强。保证程序系统的稳定，健壮，高效。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>后端</tag>
        <tag>系统优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Installs]]></title>
    <url>%2F2020%2F10%2F23%2Fdocker-installs%2F</url>
    <content type="text"><![CDATA[docker 安装软件工具 准备工作docker准备工作传送门 命令快捷 查看镜像# docker images | grep ? 启动容器# docker run -id --name=matrix_mysql -p 13306:3306 -e MYSQL_ROOT_PASSWORD=abc123 mysql 进入容器# docker exec -it 容器名/容器Id /bin/bash 安装Nexus3查询镜像# docker search nexus 拉取镜像# docker pull sonatype/nexus3 配置本地保存数据的路径 路径可自定义,我放在/docker/nexus/nexus-data下。 注意：在生成目录的时候，因为nexus的读写默认是200,docker run的时候会报找不到路径的错误 可能遇到的问题:找不到路径错误 修改目录权限# chmod 777 docker # chmod 777 nexus # chmod 777 nexus-data 运行镜像# docker run -d -p 8081:8081 -p 8082:8082 -p 8083:8083 --name matrix_nexus3 -v /usr/etc/docker/nexus/nexus-data:/nexus-data sonatype/nexus3 8082 客户端页面的对外端口; 8082 准备建立docker hosted 私有库使用。hosted可以上传下载我建立的images; 8083 准备建立docker proxy 代理库使用。 proxy可以镜像远程公共仓库，比如：docke官方仓库、aliyun等等; daemon.json 在/etc/docker/daemon.json这个文件夹中配置; daemon.json文件中的配置说明： { "registry-mirrors": ["https://1v50e4uy.mirror.aliyuncs.com"], ----文件加速地址，下载国外的镜像，通过它进行加速 "insecure-registries":["192.168.111.112:8083"] ---配置本地的镜像库地址,每次拖取镜像,如果8083上没有，先从远程库下载，下载到8083，再下载到本地库，下次再下载的时候，就从8083上下载了。 } 登录 Nexus31.登录链接：http://192.168.111.112:8081/ 2.默认用户名:admin 默认密码不再是admin123,所以需要去容器内查看 3.查看默认密码：进入容器内查看 # docker exec -it matrix_nexus3 /bin/bash # cd nexus-data/ # vi admin.password ---复制出密码,去网页登录 4.登录完成后,默认提示修改新密码,新密码改完后,admin.password将会消失,所以要保管好密码 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>运维</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo操作手册]]></title>
    <url>%2F2020%2F10%2F23%2Fhexo-manual%2F</url>
    <content type="text"><![CDATA[A fast, simple &amp; powerful blog framework 官方网站：https://hexo.io/zh-cn/docs/configuration 常用命令清除缓存文件 (db.json) 和已生成的静态文件 (public) $ hexo clean 生成静态文件 $ hexo generate -d, --deploy 文件生成后立即部署网站 -w, --watch 监视文件变动 部署 hexo d 启动服务器。默认情况下,访问网址为: http://localhost:4000/ $ hexo server -p, --port 重设端口 -s, --static 只使用静态文件 -l, --log 启动日记记录，使用覆盖记录格式 发表草稿 $ hexo publish [layout] &lt;filename&gt; 显示草稿 $ hexo --draft 自定义 CWD（Current working directory） $ hexo --cwd /path/to/cwd 创建文档 hexo new [layout] &lt;title&gt; ex: hexo new inner demo01 hexo new outer demo01 hexo new feeling demo01 draft--&gt;public hexo publish [layout] &lt;title&gt; ex: hexo new draft demo01 hexo publish inner &lt;title&gt; 页眉说明title: Hexo操作手册 //标题 author: 571 //作者 series: INNER //所属系列 categories: INNER //所属类别 comments: true //是否开启评论： true 开启 img: /cover/abc.jpg //封面图 top: false //是否置顶 true 是 cover: false //是否轮播 true 是 tags: //标签 - inner - 手册 date: 2020-05-14 21:58:38 //创建时间 updated: 2020-05-14 21:58:38 //修改时间 创建文章文件创建文件命名格式：小写、中杠隔开单词 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>手册</category>
      </categories>
      <tags>
        <tag>手册</tag>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker,轻量级的虚拟化技术]]></title>
    <url>%2F2020%2F10%2F23%2Fdocker%2F</url>
    <content type="text"><![CDATA[Docker 一个利用了lxc的技术的一个虚拟化引擎。 Docker简介什么是虚拟化​ 在计算机中，虚拟化（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。这些资源的新虚拟部份是不受现有资源的架设方式，地域或物理组态所限制。一般所指的虚拟化资源包括计算能力和资料存储。 ​ 在实际的生产环境中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件 对资源充分利用 ​ 虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机等等。 什么是Docker​ Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。 ​ ​ Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。 ​ Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。 ​ 在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。 为什么选择Docker? （1）上手快。 ​ 用户只需要几分钟，就可以把自己的程序“Docker化”。Docker依赖于“写时复制”（copy-on-write）模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改”的境界。 随后，就可以创建容器来运行应用程序了。大多数Docker容器只需要不到1秒中即可启动。由于去除了管理程序的开销，Docker容器拥有很高的性能，同时同一台宿主机中也可以运行更多的容器，使用户尽可能的充分利用系统资源。 （2）职责的逻辑分类 ​ 使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。Docker设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题（测试环境都是正常的，上线后出了问题就归结为肯定是运维的问题）” （3）快速高效的开发生命周期 ​ Docker的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。（通俗一点说，Docker就像一个盒子，里面可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件件的取。） （4）鼓励使用面向服务的架构 ​ Docker还鼓励面向服务的体系结构和微服务架构。Docker推荐单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单，同时也提高了程序的内省性。（当然，可以在一个容器中运行多个应用程序） 1.3 容器与虚拟机比较​ 下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。 与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。 Docker 组件Docker服务器与客户端​ Docker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。 Docker镜像与容器​ 镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。例如： 添加一个文件； 执行一个命令； 打开一个窗口。 也可以将镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新。 ​ Docker可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容器即可。容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。 容器基于镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务。 所以Docker容器就是： ​ 一个镜像格式； ​ 一些列标准操作； ​ 一个执行环境。 ​ Docker借鉴了标准集装箱的概念。标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。 和集装箱一样，Docker在执行上述操作时，并不关心容器中到底装了什么，它不管是web服务器，还是数据库，或者是应用程序服务器什么的。所有的容器都按照相同的方式将内容“装载”进去。 Docker也不关心你要把容器运到何方：我们可以在自己的笔记本中构建容器，上传到Registry，然后下载到一个物理的或者虚拟的服务器来测试，在把容器部署到具体的主机中。像标准集装箱一样，Docker容器方便替换，可以叠加，易于分发，并且尽量通用。 Registry（注册中心）​ Docker用Registry来保存用户构建的镜像。Registry分为公共和私有两种。Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像（说明：在Docker Hub下载镜像巨慢，可以自己构建私有的Registry）。 ​ https://hub.docker.com/ Docker安装与启动安装Docker​ Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。 ​ 由于我们学习的环境都使用的是CentOS，因此这里我们将Docker安装到CentOS上。注意：这里建议安装在CentOS7.x以上的版本，在CentOS6.x的版本中，安装前需要安装其他很多的环境而且Docker很多补丁不支持更新。 ​ 请直接挂载课程配套的Centos7.x镜像 （1）yum 包更新到最新 sudo yum update （2）安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 sudo yum install -y yum-utils device-mapper-persistent-data lvm2 （3）设置yum源为阿里云 sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo （4）安装docker sudo yum install docker-ce （5）安装后查看docker版本 docker -v 设置ustc的镜像ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。 https://lug.ustc.edu.cn/wiki/mirrors/help/docker 编辑该文件： vi /etc/docker/daemon.json 在该文件中输入如下内容： { "registry-mirrors": ["https://docker.mirrors.ustc.edu.cn"] } Docker的启动与停止systemctl命令是系统服务管理器指令 启动docker： systemctl start docker 停止docker： systemctl stop docker 重启docker： systemctl restart docker 查看docker状态： systemctl status docker 开机启动： systemctl enable docker 查看docker概要信息 docker info 查看docker帮助文档 docker --help 常用命令镜像相关命令查看镜像docker images REPOSITORY：镜像名称 TAG：镜像标签 IMAGE ID：镜像ID CREATED：镜像的创建日期（不是获取该镜像的日期） SIZE：镜像大小 这些镜像都是存储在Docker宿主机的/var/lib/docker目录下 搜索镜像如果你需要从网络中查找需要的镜像，可以通过以下命令搜索 docker search 镜像名称 NAME：仓库名称 DESCRIPTION：镜像描述 STARS：用户评价，反应一个镜像的受欢迎程度 OFFICIAL：是否官方 AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的 拉取镜像拉取镜像就是从中央仓库中下载镜像到本地 docker pull 镜像名称 例如，我要下载centos7镜像 docker pull centos:7 删除镜像按镜像ID删除镜像 docker rmi 镜像ID 删除所有镜像 docker rmi `docker images -q` 容器相关命令查看容器查看正在运行的容器 docker ps 查看所有容器 docker ps –a 查看最后一次运行的容器 docker ps –l 查看停止的容器 docker ps -f status=exited 创建与启动容器创建容器常用的参数说明： 创建容器命令：docker run -i：表示运行容器 -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。 –name :为创建的容器命名。 -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。 -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。 -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射 （1）交互式方式创建容器 docker run -it --name=容器名称 镜像名称:标签 /bin/bash 这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态 退出当前容器 exit （2）守护式方式创建容器： docker run -di --name=容器名称 镜像名称:标签 登录守护式容器方式： docker exec -it 容器名称 (或者容器ID) /bin/bash 停止与启动容器停止容器： docker stop 容器名称（或者容器ID） 启动容器： docker start 容器名称（或者容器ID） 文件拷贝如果我们需要将文件拷贝到容器内可以使用cp命令 docker cp 需要拷贝的文件或目录 容器名称:容器目录 也可以将文件从容器内拷贝出来 docker cp 容器名称:容器目录 需要拷贝的文件或目录 目录挂载我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。创建容器 添加-v参数 后边为 宿主机目录:容器目录，例如： docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos3 centos:7 如果你共享的是多级的目录，可能会出现权限不足的提示。 这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数 –privileged=true 来解决挂载的目录没有权限的问题 查看容器IP地址我们可以通过以下命令查看容器运行的各种数据 docker inspect 容器名称（容器ID） 也可以直接执行下面的命令直接输出IP地址 docker inspect --format='{{.NetworkSettings.IPAddress}}' 容器名称（容器ID） 删除容器删除指定的容器： docker rm 容器名称（容器ID） 应用部署MySQL部署（1）拉取mysql镜像 docker pull centos/mysql-57-centos7 （2）创建容器 docker run -di --name=tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql -p 代表端口映射，格式为 宿主机映射端口:容器运行端口 -e 代表添加环境变量 MYSQL_ROOT_PASSWORD 是root用户的登陆密码 （3）远程登录mysql 连接宿主机的IP ,指定端口为33306 tomcat部署（1）拉取镜像 docker pull tomcat:7-jre7 （2）创建容器 创建容器 -p表示地址映射 docker run -di --name=mytomcat -p 9000:8080 -v /usr/local/webapps:/usr/local/tomcat/webapps tomcat:7-jre7 Nginx部署（1）拉取镜像 docker pull nginx （2）创建Nginx容器 docker run -di --name=mynginx -p 80:80 nginx Redis部署（1）拉取镜像 docker pull redis （2）创建容器 docker run -di --name=myredis -p 6379:6379 redis 迁移与备份容器保存为镜像我们可以通过以下命令将容器保存为镜像 docker commit mynginx mynginx_i 镜像备份我们可以通过以下命令将镜像保存为tar 文件 docker save -o mynginx.tar mynginx_i 镜像恢复与迁移首先我们先删除掉mynginx_img镜像 然后执行此命令进行恢复 docker load -i mynginx.tar -i 输入的文件 执行后再次查看镜像，可以看到镜像已经恢复 Dockerfile Dockerfile文件详解 什么是DockerfileDockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。 对于开发人员：可以为开发团队提供一个完全一致的开发环境； 对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了； 对于运维人员：在部署时，可以实现应用的无缝移植。 常用命令 命令 作用 FROM image_name:tag 定义了使用哪个基础镜像启动构建流程 MAINTAINER user_name 声明镜像的创建者 ENV key value 设置环境变量 (可以写多条) RUN command 是Dockerfile的核心部分(可以写多条) ADD source_dir/file dest_dir/file 将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压 COPY source_dir/file dest_dir/file 和ADD相似，但是如果有压缩文件并不能解压 WORKDIR path_dir 设置工作目录 使用脚本创建镜像步骤： （1）创建目录 mkdir –p /usr/local/dockerjdk8 （2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/dockerjdk8目录 （3）创建文件Dockerfile vi Dockerfile #依赖镜像名称和ID FROM centos:7 #指定镜像创建者信息 MAINTAINER ITCAST #切换工作目录 WORKDIR /usr RUN mkdir /usr/local/java #ADD 是相对路径jar,把java添加到容器中 ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/ #配置java环境变量 ENV JAVA_HOME /usr/local/java/jdk1.8.0_171 ENV JRE_HOME $JAVA_HOME/jre ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH ENV PATH $JAVA_HOME/bin:$PATH （4）执行命令构建镜像 docker build -t='jdk1.8' . 注意后边的空格和点，不要省略 （5）查看镜像是否建立完成 docker images Docker私有仓库私有仓库搭建与配置（1）拉取私有仓库镜像（此步省略） docker pull registry （2）启动私有仓库容器 docker run -di --name=registry -p 5000:5000 registry （3）打开浏览器 输入地址http://192.168.184.141:5000/v2/_catalog看到`{"repositories":[]}` 表示私有仓库搭建成功并且内容为空 （4）修改daemon.json vi /etc/docker/daemon.json 添加以下内容，保存退出。 {"insecure-registries":["192.168.184.141:5000"]} 此步用于让 docker信任私有仓库地址 （5）重启docker 服务 systemctl restart docker 镜像上传至私有仓库（1）标记此镜像为私有仓库的镜像 docker tag jdk1.8 192.168.184.141:5000/jdk1.8 （2）再次启动私服容器 docker start registry （3）上传标记的镜像 docker push 192.168.184.141:5000/jdk1.8 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>运维</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux Installs]]></title>
    <url>%2F2020%2F10%2F23%2Flinux-installs%2F</url>
    <content type="text"><![CDATA[Linux 软件工具安装 安装Java通过yum方式安装Java查看JDK是否已安装# yum list installed | grep java 若已经安装了JDK，如何卸载Java环境？ 卸载JDK相关文件：# yum -y remove java-1.7.0-openjdk* 卸载tzdata-java：# yum -y remove tzdata-java.noarch 注：“*”表示卸载掉java 1.7.0的所有openjdk相关文件查看yum库中的Java安装包# yum -y list java* 安装Java安装包 以yum库中java-1.8.0为例： # yum -y install java-1.8.0-openjdk* 注：“*”表示将java-1.8.0的所有相关Java程序都安装上 查看刚刚安装版本# java -version 环境变量配置1.修改配置文件 # vim /etc/profile # export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk # export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar # export PATH=$PATH:$JAVA_HOME/bin 2.生效修改 # source /etc/profile 通过压缩包安装Java####准备工作： jdk-8u11-linux-x64.tar.gz下载地址：https://pan.baidu.com/s/1smNHABN (ps：也可在官网下载最新jdk:http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) shell在windows下载完成jdk后，通过shell发送到Linux上 登录Linux，切换到root用户# su root ---获取root用户权限，当前工作目录不变(需要root密码) 或者 # sudo -i ---不需要root密码直接切换成root（需要当前用户密码） 在usr目录下建立Java安装目录# cd /usr/local/src/ # mkdir java 解压jdk到当前目录,得到文件夹 jdk1.8.0_11# tar -zxvf jdk-8u11-linux-x64.tar.gz 解压完建立一个链接以节省目录长度# ln -s /usr/local/src/java/jdk1.8.0_11/ /usr/local/src/jdk 编辑配置文件，配置环境变量# vim /etc/profile 在文末添加如下内容： # JAVA_HOME=/usr/local/src/jdk # CLASSPATH=$JAVA_HOME/lib/ # PATH=$PATH:$JAVA_HOME/bin # export PATH JAVA_HOME CLASSPATH 重启机器或执行命令# sudo shutdown -r now 查看刚刚安装版本# java -version 安装Maven在线下载安装安装wget命令# yum -y install wget 下载maven安装包# cd /usr/local/src/ # wget http://mirrors.cnnic.cn/apache/maven/maven-3/3.5.4/binaries/apache-maven-3.5.4-bin.tar.gz 解压maven安装包# tar -zxvf apache-maven-3.5.4-bin.tar.gz 配置maven# vi /etc/profile 在配置文件配置 # export MAVEN_HOME=/usr/local/src/apache-maven-3.5.4 # export PATH=$MAVEN_HOME/bin:$PATH 配置文件生效 # source /etc/profile 查看maven# mvn -version 安装包安装 Maven下载地址 安装Nexus3准备工作 安装Java 安装Maven 在线下载安装在线下载安装传送门 安装包安装 Nexus下载地址1Nexus下载地址2 docker安装源码下载不动,无耐想到此法,推荐 Docker安装传送门 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>后端</tag>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
