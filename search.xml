<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>系统优化小记：CPU长时间满负荷运行</title>
      <link href="/2020/11/28/system-optimize/"/>
      <url>/2020/11/28/system-optimize/</url>
      
        <content type="html"><![CDATA[<blockquote><p>CPU长时间满负荷运行,一次入门级降CPU系统优化实战</p></blockquote><a id="more"></a><h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>用户量增大,线上一个Java单应用服务长时间占用服务器CPU达到400%，使得接口响应速度非常慢，线程拥堵，出现各种响应超时问题，即便有时候没有用户操作，也会长时间占用大量CPU和内存。</p><p><img src="/2020/11/28/system-optimize/1-1-1.png" alt=""></p><h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>找出哪些程序处理满，进行排查优化（业务流程调整、锁关闭、SQL优化、一些耗性能的程序不使用内存方案）</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>linux命令排查 + Arthas监控 + Druid sql 监控</p><h1 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h1><h2 id="一、Linux命令排查，方法如下："><a href="#一、Linux命令排查，方法如下：" class="headerlink" title="一、Linux命令排查，方法如下："></a>一、Linux命令排查，方法如下：</h2><h3 id="1-显示进程列表，定位进程号"><a href="#1-显示进程列表，定位进程号" class="headerlink" title="1.显示进程列表，定位进程号"></a>1.显示进程列表，定位进程号</h3><p>在<strong>top</strong>命令下，按<strong>shift+H</strong>查看cpu占用最高进程(<strong>PID</strong>:21659)</p><p><img src="/2020/11/28/system-optimize/1-1-2.png" alt=""></p><h3 id="2-显示线程列表，定位线程号，找到哪些线程占用高耗时长"><a href="#2-显示线程列表，定位线程号，找到哪些线程占用高耗时长" class="headerlink" title="2.显示线程列表，定位线程号，找到哪些线程占用高耗时长"></a>2.显示线程列表，定位线程号，找到哪些线程占用高耗时长</h3><p>命令：<code>ps -mp **pid** -o THREAD,tid,time | sort -rn | more</code></p><p>ex：ps -mp 21659 -o THREAD,tid,time （shift+H）</p><p>ps：截图中pid写成24275原因是由于中途重启过一次程序，原PID：21659 变更成 PID：24275，实则都是同一个Java程序</p><p>其中TID：24737、24742、24745，耗时较长占用CPU率较高</p><p><img src="/2020/11/28/system-optimize/1-1-3.png" alt=""></p><h3 id="3-将线程号转为系统可识别的16进制"><a href="#3-将线程号转为系统可识别的16进制" class="headerlink" title="3.将线程号转为系统可识别的16进制"></a>3.将线程号转为系统可识别的16进制</h3><p>命令：<code>printf "%x\n" tid</code></p><p><img src="/2020/11/28/system-optimize/1-1-4.png" alt=""></p><h3 id="4-打印线程的堆栈信息，分析原因"><a href="#4-打印线程的堆栈信息，分析原因" class="headerlink" title="4.打印线程的堆栈信息，分析原因"></a>4.打印线程的堆栈信息，分析原因</h3><p>命令： <code>jstack PID | grep [16进制TID] -A 30</code></p><p>ex：查看线程24737的堆栈信息， jstack 24275 | grep 60a1 -A 30</p><h3 id="5-如果嫌以上操作麻烦，也可直接使用-jstack-PID，打印出所有堆栈，进行查看。"><a href="#5-如果嫌以上操作麻烦，也可直接使用-jstack-PID，打印出所有堆栈，进行查看。" class="headerlink" title="5.如果嫌以上操作麻烦，也可直接使用  jstack PID，打印出所有堆栈，进行查看。"></a>5.如果嫌以上操作麻烦，也可直接使用  jstack PID，打印出所有堆栈，进行查看。</h3><h2 id="二、辅助神器Arthas程序监控"><a href="#二、辅助神器Arthas程序监控" class="headerlink" title="二、辅助神器Arthas程序监控"></a>二、辅助神器Arthas程序监控</h2><p>本次不在说明，后出专题讲解，附上官方文档：</p><p><a href="https://arthas.aliyun.com/doc/" target="_blank" rel="noopener">Arthas传送门</a></p><h2 id="三、辅助Druid-SQL监控"><a href="#三、辅助Druid-SQL监控" class="headerlink" title="三、辅助Druid SQL监控"></a>三、辅助Druid SQL监控</h2><p>本次也不在说明，后出专题讲解，附一张图</p><p><img src="/2020/11/28/system-optimize/1-1-5.png" alt=""></p><h1 id="最终问题定位在"><a href="#最终问题定位在" class="headerlink" title="最终问题定位在"></a>最终问题定位在</h1><p><strong>堆内存占满，新创建对象时无法分配足够的内存，引起频繁GC</strong></p><p>1.程序频繁请求RPC接口得到的响应慢，耗时过大；<br>    解决方案：由于获取的数据实时性要求不高，改为缓存处理，避免实时请求。</p><p>2.客户端频繁请求某个接口，且接口中的sql效率非常低,导致了sql连接长时间被占用。<br>    解决方案：由于该接口历史遗留，且和对应的调用客户端同事确认该接口现今已用处不大，因此注释掉了该接口。</p><p>3.频繁收到回调，随开启了多线程处理但由于有线程锁，使得其他线程被block，实则依然是个单线程处理，消费速度赶不上生产速度，线程积压。<br>    解决方案：确保安全的情况下，关闭了线程锁。</p><p>4.代码逻辑不合理;<br>    解决方案：重新调整代码逻辑</p><p>5.对数据库操作过于频繁;<br>    解决方案：调整逻辑，优化sql（调整sql，加索引，避免全表扫描），尽量少操作数据库，多使用缓存对数据进行操作</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过此次排查，虽最终问题得以缓解，但深知系统内依然存在很多其他性能问题，暴露出对JVM知识的欠缺，以及Java代码、SQL功底需要持续加强。保证程序系统的稳定，健壮，高效。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> 后端 </tag>
            
            <tag> 系统优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Installs</title>
      <link href="/2020/10/23/docker-installs/"/>
      <url>/2020/10/23/docker-installs/</url>
      
        <content type="html"><![CDATA[<blockquote><p>docker 安装软件工具<br><a id="more"></a></p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><a href="http://tryto.top/2019/10/11/docker/" target="_blank" rel="noopener">docker准备工作传送门</a></p><h2 id="命令快捷"><a href="#命令快捷" class="headerlink" title="命令快捷"></a>命令快捷</h2><ul><li>查看镜像<pre><code># docker images | grep ?</code></pre></li><li>启动容器<pre><code># docker run -id --name=matrix_mysql -p 13306:3306 -e MYSQL_ROOT_PASSWORD=abc123 mysql</code></pre></li><li>进入容器<pre><code># docker exec -it 容器名/容器Id  /bin/bash</code></pre></li></ul><h2 id="安装Nexus3"><a href="#安装Nexus3" class="headerlink" title="安装Nexus3"></a>安装Nexus3</h2><h3 id="查询镜像"><a href="#查询镜像" class="headerlink" title="查询镜像"></a>查询镜像</h3><pre><code># docker search nexus</code></pre><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><pre><code># docker pull sonatype/nexus3</code></pre><h3 id="配置本地保存数据的路径"><a href="#配置本地保存数据的路径" class="headerlink" title="配置本地保存数据的路径"></a>配置本地保存数据的路径</h3><p>  路径可自定义,我放在/docker/nexus/nexus-data下。</p><p>  注意：在生成目录的时候，因为nexus的读写默认是200,docker run的时候会报找不到路径的错误</p><p><a href="https://www.cnblogs.com/badaoliumangqizhi/p/11565113.html" target="_blank" rel="noopener">可能遇到的问题:找不到路径错误</a></p><h3 id="修改目录权限"><a href="#修改目录权限" class="headerlink" title="修改目录权限"></a>修改目录权限</h3><pre><code># chmod 777 docker# chmod 777 nexus# chmod 777 nexus-data</code></pre><h3 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h3><pre><code># docker run -d -p 8081:8081 -p 8082:8082 -p 8083:8083 --name matrix_nexus3 -v /usr/etc/docker/nexus/nexus-data:/nexus-data sonatype/nexus3</code></pre><ul><li>8082<br>  客户端页面的对外端口;</li><li>8082<br>  准备建立docker hosted 私有库使用。hosted可以上传下载我建立的images;</li><li>8083<br>  准备建立docker proxy 代理库使用。 proxy可以镜像远程公共仓库，比如：docke官方仓库、aliyun等等;</li><li>daemon.json<br>  在/etc/docker/daemon.json这个文件夹中配置;</li></ul><p>daemon.json文件中的配置说明：</p><pre><code>{    "registry-mirrors": ["https://1v50e4uy.mirror.aliyuncs.com"],    ----文件加速地址，下载国外的镜像，通过它进行加速    "insecure-registries":["192.168.111.112:8083"]      ---配置本地的镜像库地址,每次拖取镜像,如果8083上没有，先从远程库下载，下载到8083，再下载到本地库，下次再下载的时候，就从8083上下载了。 }</code></pre><h3 id="登录-Nexus3"><a href="#登录-Nexus3" class="headerlink" title="登录 Nexus3"></a>登录 Nexus3</h3><p>1.登录链接：<a href="http://192.168.111.112:8081/" target="_blank" rel="noopener">http://192.168.111.112:8081/</a></p><p>2.默认用户名:admin  默认密码不再是admin123,所以需要去容器内查看</p><p>3.查看默认密码：进入容器内查看</p><pre><code># docker exec -it matrix_nexus3 /bin/bash# cd nexus-data/# vi admin.password  ---复制出密码,去网页登录</code></pre><p>4.登录完成后,默认提示修改新密码,新密码改完后,admin.password将会消失,所以要保管好密码</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 运维 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo操作手册</title>
      <link href="/2020/10/23/hexo-manual/"/>
      <url>/2020/10/23/hexo-manual/</url>
      
        <content type="html"><![CDATA[<blockquote><p>A fast, simple &amp; powerful blog framework</p></blockquote><a id="more"></a><h3 id="官方网站："><a href="#官方网站：" class="headerlink" title="官方网站："></a>官方网站：</h3><p><a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/configuration</a></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)</p><pre><code>$ hexo clean</code></pre><p>生成静态文件</p><pre><code>$ hexo generate    -d, --deploy    文件生成后立即部署网站    -w, --watch    监视文件变动</code></pre><p>部署</p><pre><code>hexo d</code></pre><p>启动服务器。默认情况下,访问网址为: <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p><pre><code>$ hexo server    -p, --port    重设端口    -s, --static    只使用静态文件    -l, --log    启动日记记录，使用覆盖记录格式</code></pre><p>发表草稿</p><pre><code>$ hexo publish [layout] &lt;filename&gt; </code></pre><p>显示草稿</p><pre><code>$ hexo --draft</code></pre><p>自定义 CWD（Current working directory）</p><pre><code>$ hexo --cwd /path/to/cwd</code></pre><p>创建文档</p><pre><code>hexo new [layout] &lt;title&gt;ex:    hexo new inner demo01    hexo new outer demo01    hexo new feeling demo01draft--&gt;publichexo publish [layout] &lt;title&gt;ex:    hexo new draft demo01    hexo publish inner &lt;title&gt;</code></pre><h3 id="页眉说明"><a href="#页眉说明" class="headerlink" title="页眉说明"></a>页眉说明</h3><pre><code>title: Hexo操作手册 //标题author: 571 //作者series: INNER //所属系列categories: INNER //所属类别comments: true //是否开启评论： true 开启img: /cover/abc.jpg  //封面图top: false //是否置顶 true 是cover: false //是否轮播 true 是tags:  //标签  - inner  - 手册date: 2020-05-14 21:58:38  //创建时间updated: 2020-05-14 21:58:38 //修改时间</code></pre><h3 id="创建文章文件"><a href="#创建文章文件" class="headerlink" title="创建文章文件"></a>创建文章文件</h3><pre><code>创建文件命名格式：小写、中杠隔开单词</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手册 </tag>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Installs</title>
      <link href="/2020/10/23/linux-installs/"/>
      <url>/2020/10/23/linux-installs/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Linux 软件工具安装<br><a id="more"></a></p></blockquote><h2 id="安装Java"><a href="#安装Java" class="headerlink" title="安装Java"></a>安装Java</h2><h3 id="通过yum方式安装Java"><a href="#通过yum方式安装Java" class="headerlink" title="通过yum方式安装Java"></a>通过yum方式安装Java</h3><h4 id="查看JDK是否已安装"><a href="#查看JDK是否已安装" class="headerlink" title="查看JDK是否已安装"></a>查看JDK是否已安装</h4><pre><code># yum list installed | grep java</code></pre><h4 id="若已经安装了JDK，如何卸载Java环境？"><a href="#若已经安装了JDK，如何卸载Java环境？" class="headerlink" title="若已经安装了JDK，如何卸载Java环境？"></a>若已经安装了JDK，如何卸载Java环境？</h4><ul><li>卸载JDK相关文件：<pre><code># yum -y remove java-1.7.0-openjdk*</code></pre>卸载tzdata-java：<pre><code># yum -y remove tzdata-java.noarch</code></pre>注：“*”表示卸载掉java 1.7.0的所有openjdk相关文件<h4 id="查看yum库中的Java安装包"><a href="#查看yum库中的Java安装包" class="headerlink" title="查看yum库中的Java安装包"></a>查看yum库中的Java安装包</h4><pre><code># yum -y list java*</code></pre><h4 id="安装Java安装包"><a href="#安装Java安装包" class="headerlink" title="安装Java安装包"></a>安装Java安装包</h4></li></ul><p>以yum库中java-1.8.0为例：</p><pre><code># yum -y install java-1.8.0-openjdk*</code></pre><p>注：“*”表示将java-1.8.0的所有相关Java程序都安装上</p><h4 id="查看刚刚安装版本"><a href="#查看刚刚安装版本" class="headerlink" title="查看刚刚安装版本"></a>查看刚刚安装版本</h4><pre><code># java -version</code></pre><h4 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h4><p>1.修改配置文件</p><pre><code># vim /etc/profile# export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk# export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar# export PATH=$PATH:$JAVA_HOME/bin</code></pre><p>2.生效修改</p><pre><code># source /etc/profile</code></pre><h3 id="通过压缩包安装Java"><a href="#通过压缩包安装Java" class="headerlink" title="通过压缩包安装Java"></a>通过压缩包安装Java</h3><p>####准备工作：</p><ul><li>jdk-8u11-linux-x64.tar.gz<br>下载地址：<a href="https://pan.baidu.com/s/1smNHABN" target="_blank" rel="noopener">https://pan.baidu.com/s/1smNHABN</a> (ps：也可在官网下载最新jdk:<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a>)</li><li>shell<br>在windows下载完成jdk后，通过shell发送到Linux上</li></ul><h4 id="登录Linux，切换到root用户"><a href="#登录Linux，切换到root用户" class="headerlink" title="登录Linux，切换到root用户"></a>登录Linux，切换到root用户</h4><pre><code># su root ---获取root用户权限，当前工作目录不变(需要root密码)</code></pre><p>或者</p><pre><code># sudo -i ---不需要root密码直接切换成root（需要当前用户密码）</code></pre><h4 id="在usr目录下建立Java安装目录"><a href="#在usr目录下建立Java安装目录" class="headerlink" title="在usr目录下建立Java安装目录"></a>在usr目录下建立Java安装目录</h4><pre><code># cd /usr/local/src/# mkdir java</code></pre><h4 id="解压jdk到当前目录-得到文件夹-jdk1-8-0-11"><a href="#解压jdk到当前目录-得到文件夹-jdk1-8-0-11" class="headerlink" title="解压jdk到当前目录,得到文件夹 jdk1.8.0_11"></a>解压jdk到当前目录,得到文件夹 jdk1.8.0_11</h4><pre><code># tar -zxvf jdk-8u11-linux-x64.tar.gz</code></pre><h4 id="解压完建立一个链接以节省目录长度"><a href="#解压完建立一个链接以节省目录长度" class="headerlink" title="解压完建立一个链接以节省目录长度"></a>解压完建立一个链接以节省目录长度</h4><pre><code># ln -s /usr/local/src/java/jdk1.8.0_11/ /usr/local/src/jdk</code></pre><h4 id="编辑配置文件，配置环境变量"><a href="#编辑配置文件，配置环境变量" class="headerlink" title="编辑配置文件，配置环境变量"></a>编辑配置文件，配置环境变量</h4><pre><code># vim /etc/profile</code></pre><p>在文末添加如下内容：</p><pre><code># JAVA_HOME=/usr/local/src/jdk# CLASSPATH=$JAVA_HOME/lib/# PATH=$PATH:$JAVA_HOME/bin# export PATH JAVA_HOME CLASSPATH</code></pre><h4 id="重启机器或执行命令"><a href="#重启机器或执行命令" class="headerlink" title="重启机器或执行命令"></a>重启机器或执行命令</h4><pre><code># sudo shutdown -r now</code></pre><h4 id="查看刚刚安装版本-1"><a href="#查看刚刚安装版本-1" class="headerlink" title="查看刚刚安装版本"></a>查看刚刚安装版本</h4><pre><code># java -version</code></pre><h2 id="安装Maven"><a href="#安装Maven" class="headerlink" title="安装Maven"></a>安装Maven</h2><h3 id="在线下载安装"><a href="#在线下载安装" class="headerlink" title="在线下载安装"></a>在线下载安装</h3><h4 id="安装wget命令"><a href="#安装wget命令" class="headerlink" title="安装wget命令"></a>安装wget命令</h4><pre><code># yum -y install wget</code></pre><h4 id="下载maven安装包"><a href="#下载maven安装包" class="headerlink" title="下载maven安装包"></a>下载maven安装包</h4><pre><code># cd /usr/local/src/# wget http://mirrors.cnnic.cn/apache/maven/maven-3/3.5.4/binaries/apache-maven-3.5.4-bin.tar.gz</code></pre><h4 id="解压maven安装包"><a href="#解压maven安装包" class="headerlink" title="解压maven安装包"></a>解压maven安装包</h4><pre><code># tar -zxvf apache-maven-3.5.4-bin.tar.gz</code></pre><h4 id="配置maven"><a href="#配置maven" class="headerlink" title="配置maven"></a>配置maven</h4><pre><code># vi /etc/profile</code></pre><p>在配置文件配置</p><pre><code># export MAVEN_HOME=/usr/local/src/apache-maven-3.5.4# export PATH=$MAVEN_HOME/bin:$PATH</code></pre><p>配置文件生效</p><pre><code># source /etc/profile</code></pre><h4 id="查看maven"><a href="#查看maven" class="headerlink" title="查看maven"></a>查看maven</h4><pre><code># mvn -version</code></pre><h3 id="安装包安装"><a href="#安装包安装" class="headerlink" title="安装包安装"></a>安装包安装</h3><p><img src="/2020/10/23/linux-installs/404.jpg" alt=""></p><p><a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">Maven下载地址</a></p><h2 id="安装Nexus3"><a href="#安装Nexus3" class="headerlink" title="安装Nexus3"></a>安装Nexus3</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>安装Java</li><li>安装Maven</li></ul><h3 id="在线下载安装-1"><a href="#在线下载安装-1" class="headerlink" title="在线下载安装"></a>在线下载安装</h3><p><a href="https://my.oschina.net/u/2963821/blog/1806035" target="_blank" rel="noopener">在线下载安装传送门</a></p><h3 id="安装包安装-1"><a href="#安装包安装-1" class="headerlink" title="安装包安装"></a>安装包安装</h3><p><img src="/2020/10/23/linux-installs/404.jpg" alt=""></p><p><a href="https://www.sonatype.com/download-oss-sonatype" target="_blank" rel="noopener">Nexus下载地址1</a><br><a href="https://help.sonatype.com/repomanager3/download/download-archives---repository-manager-3" target="_blank" rel="noopener">Nexus下载地址2</a></p><h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><p>源码下载不动,无耐想到此法,推荐 <a href="http://tryto.top/2019/10/29/docker-installs/" target="_blank" rel="noopener">Docker安装传送门</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> 后端 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker,轻量级的虚拟化技术</title>
      <link href="/2020/10/23/docker/"/>
      <url>/2020/10/23/docker/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><blockquote><p>一个利用了lxc的技术的一个虚拟化引擎。<br><a id="more"></a></p></blockquote><h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><h2 id="什么是虚拟化"><a href="#什么是虚拟化" class="headerlink" title="什么是虚拟化"></a>什么是虚拟化</h2><p>​    在计算机中，虚拟化（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。这些资源的新虚拟部份是不受现有资源的架设方式，地域或物理组态所限制。一般所指的虚拟化资源包括计算能力和资料存储。</p><p>​    在实际的生产环境中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件   对资源充分利用</p><p>​    虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机等等。</p><h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h2><p>​    Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 <a href="https://github.com/docker/docker" target="_blank" rel="noopener">GitHub</a> 上进行维护。</p><p>​    <img src="/2020/10/23/docker/1-3.png" alt=""></p><p>​    Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。</p><p>​    Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。</p><p>​    在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。</p><p>为什么选择Docker?</p><p>（1）上手快。</p><p>​    用户只需要几分钟，就可以把自己的程序“Docker化”。Docker依赖于“写时复制”（copy-on-write）模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改”的境界。    </p><pre><code>     随后，就可以创建容器来运行应用程序了。大多数Docker容器只需要不到1秒中即可启动。由于去除了管理程序的开销，Docker容器拥有很高的性能，同时同一台宿主机中也可以运行更多的容器，使用户尽可能的充分利用系统资源。</code></pre><p>（2）职责的逻辑分类</p><p>​    使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。Docker设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题（测试环境都是正常的，上线后出了问题就归结为肯定是运维的问题）”</p><p>（3）快速高效的开发生命周期</p><p>​    Docker的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。（通俗一点说，Docker就像一个盒子，里面可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件件的取。）</p><p>（4）鼓励使用面向服务的架构</p><p>​    Docker还鼓励面向服务的体系结构和微服务架构。Docker推荐单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单，同时也提高了程序的内省性。（当然，可以在一个容器中运行多个应用程序）</p><h2 id="1-3-容器与虚拟机比较"><a href="#1-3-容器与虚拟机比较" class="headerlink" title="1.3 容器与虚拟机比较"></a>1.3 容器与虚拟机比较</h2><p>​    下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。</p><p><img src="/2020/10/23/docker/1-1.png" alt=""></p><p>与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。</p><h2 id="Docker-组件"><a href="#Docker-组件" class="headerlink" title="Docker 组件"></a>Docker 组件</h2><h3 id="Docker服务器与客户端"><a href="#Docker服务器与客户端" class="headerlink" title="Docker服务器与客户端"></a>Docker服务器与客户端</h3><p>​    Docker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。</p><p><img src="/2020/10/23/docker/1-2.png" alt=""></p><h3 id="Docker镜像与容器"><a href="#Docker镜像与容器" class="headerlink" title="Docker镜像与容器"></a>Docker镜像与容器</h3><p>​    镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。例如：</p><p>添加一个文件；</p><p>执行一个命令；</p><p>打开一个窗口。</p><p>也可以将镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新。</p><p>​    Docker可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容器即可。容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。  容器基于镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务。</p><p>所以Docker容器就是：</p><p>​    一个镜像格式；</p><p>​    一些列标准操作；</p><p>​    一个执行环境。</p><p>​    Docker借鉴了标准集装箱的概念。标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。</p><pre><code>     和集装箱一样，Docker在执行上述操作时，并不关心容器中到底装了什么，它不管是web服务器，还是数据库，或者是应用程序服务器什么的。所有的容器都按照相同的方式将内容“装载”进去。     Docker也不关心你要把容器运到何方：我们可以在自己的笔记本中构建容器，上传到Registry，然后下载到一个物理的或者虚拟的服务器来测试，在把容器部署到具体的主机中。像标准集装箱一样，Docker容器方便替换，可以叠加，易于分发，并且尽量通用。</code></pre><h3 id="Registry（注册中心）"><a href="#Registry（注册中心）" class="headerlink" title="Registry（注册中心）"></a>Registry（注册中心）</h3><p>​    Docker用Registry来保存用户构建的镜像。Registry分为公共和私有两种。Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像（说明：在Docker Hub下载镜像巨慢，可以自己构建私有的Registry）。</p><p>​    <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p><h1 id="Docker安装与启动"><a href="#Docker安装与启动" class="headerlink" title="Docker安装与启动"></a>Docker安装与启动</h1><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>​    Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。</p><p>​    由于我们学习的环境都使用的是CentOS，因此这里我们将Docker安装到CentOS上。注意：这里建议安装在CentOS7.x以上的版本，在CentOS6.x的版本中，安装前需要安装其他很多的环境而且Docker很多补丁不支持更新。</p><p>​    请直接挂载课程配套的Centos7.x镜像    </p><p>（1）yum 包更新到最新</p><pre><code>sudo yum update</code></pre><p>（2）安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p><pre><code>sudo yum install -y yum-utils device-mapper-persistent-data lvm2</code></pre><p>（3）设置yum源为阿里云</p><pre><code>sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></pre><p>（4）安装docker</p><pre><code>sudo yum install docker-ce</code></pre><p>（5）安装后查看docker版本</p><pre><code>docker -v</code></pre><h2 id="设置ustc的镜像"><a href="#设置ustc的镜像" class="headerlink" title="设置ustc的镜像"></a>设置ustc的镜像</h2><p>ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。</p><p><a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker" target="_blank" rel="noopener">https://lug.ustc.edu.cn/wiki/mirrors/help/docker</a></p><p>编辑该文件：</p><pre><code>vi /etc/docker/daemon.json  </code></pre><p>在该文件中输入如下内容：</p><pre><code>{"registry-mirrors": ["https://docker.mirrors.ustc.edu.cn"]}</code></pre><h2 id="Docker的启动与停止"><a href="#Docker的启动与停止" class="headerlink" title="Docker的启动与停止"></a>Docker的启动与停止</h2><p><strong>systemctl</strong>命令是系统服务管理器指令</p><p>启动docker：</p><pre><code>systemctl start docker</code></pre><p>停止docker：</p><pre><code>systemctl stop docker</code></pre><p>重启docker：</p><pre><code>systemctl restart docker</code></pre><p>查看docker状态：</p><pre><code>systemctl status docker</code></pre><p>开机启动：</p><pre><code>systemctl enable docker</code></pre><p>查看docker概要信息</p><pre><code>docker info</code></pre><p>查看docker帮助文档</p><pre><code>docker --help</code></pre><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h2><h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><pre><code>docker images</code></pre><p>REPOSITORY：镜像名称</p><p>TAG：镜像标签</p><p>IMAGE ID：镜像ID</p><p>CREATED：镜像的创建日期（不是获取该镜像的日期）</p><p>SIZE：镜像大小</p><p>这些镜像都是存储在Docker宿主机的/var/lib/docker目录下</p><h3 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h3><p>如果你需要从网络中查找需要的镜像，可以通过以下命令搜索</p><pre><code>docker search 镜像名称</code></pre><p>NAME：仓库名称</p><p>DESCRIPTION：镜像描述</p><p>STARS：用户评价，反应一个镜像的受欢迎程度</p><p>OFFICIAL：是否官方</p><p>AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的</p><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p>拉取镜像就是从中央仓库中下载镜像到本地</p><pre><code>docker pull 镜像名称</code></pre><p>例如，我要下载centos7镜像</p><pre><code>docker pull centos:7</code></pre><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>按镜像ID删除镜像</p><pre><code>docker rmi 镜像ID</code></pre><p>删除所有镜像</p><pre><code>docker rmi `docker images -q`</code></pre><h2 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h2><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><p>查看正在运行的容器</p><pre><code>docker ps</code></pre><p>查看所有容器</p><pre><code>docker ps –a</code></pre><p>查看最后一次运行的容器</p><pre><code>docker ps –l</code></pre><p>查看停止的容器</p><pre><code>docker ps -f status=exited</code></pre><h3 id="创建与启动容器"><a href="#创建与启动容器" class="headerlink" title="创建与启动容器"></a>创建与启动容器</h3><p>创建容器常用的参数说明：</p><p>创建容器命令：docker run</p><p> -i：表示运行容器</p><p> -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。</p><p> –name :为创建的容器命名。</p><p> -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。</p><p> -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。</p><p> -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射</p><p>（1）交互式方式创建容器</p><pre><code>docker run -it --name=容器名称 镜像名称:标签 /bin/bash</code></pre><p>这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态  </p><p>退出当前容器</p><pre><code>exit</code></pre><p>（2）守护式方式创建容器：</p><pre><code>docker run -di --name=容器名称 镜像名称:标签</code></pre><p>登录守护式容器方式：</p><pre><code>docker exec -it 容器名称 (或者容器ID)  /bin/bash</code></pre><h3 id="停止与启动容器"><a href="#停止与启动容器" class="headerlink" title="停止与启动容器"></a>停止与启动容器</h3><p>停止容器：</p><pre><code>docker stop 容器名称（或者容器ID）</code></pre><p>启动容器：</p><pre><code>docker start 容器名称（或者容器ID）</code></pre><h3 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h3><p>如果我们需要将文件拷贝到容器内可以使用cp命令</p><pre><code>docker cp 需要拷贝的文件或目录 容器名称:容器目录</code></pre><p>也可以将文件从容器内拷贝出来</p><pre><code>docker cp 容器名称:容器目录 需要拷贝的文件或目录</code></pre><h3 id="目录挂载"><a href="#目录挂载" class="headerlink" title="目录挂载"></a>目录挂载</h3><p>我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。<br>创建容器 添加-v参数 后边为   宿主机目录:容器目录，例如：</p><pre><code>docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos3 centos:7</code></pre><p>如果你共享的是多级的目录，可能会出现权限不足的提示。</p><p>这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数  –privileged=true  来解决挂载的目录没有权限的问题</p><h3 id="查看容器IP地址"><a href="#查看容器IP地址" class="headerlink" title="查看容器IP地址"></a>查看容器IP地址</h3><p>我们可以通过以下命令查看容器运行的各种数据</p><pre><code>docker inspect 容器名称（容器ID） </code></pre><p>也可以直接执行下面的命令直接输出IP地址</p><pre><code>docker inspect --format='{{.NetworkSettings.IPAddress}}' 容器名称（容器ID）</code></pre><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>删除指定的容器：</p><pre><code>docker rm 容器名称（容器ID）</code></pre><h1 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h1><h2 id="MySQL部署"><a href="#MySQL部署" class="headerlink" title="MySQL部署"></a>MySQL部署</h2><p>（1）拉取mysql镜像</p><pre><code>docker pull centos/mysql-57-centos7</code></pre><p>（2）创建容器</p><pre><code>docker run -di --name=tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql</code></pre><p>-p 代表端口映射，格式为  宿主机映射端口:容器运行端口</p><p>-e 代表添加环境变量  MYSQL_ROOT_PASSWORD  是root用户的登陆密码</p><p>（3）远程登录mysql</p><p>连接宿主机的IP  ,指定端口为33306 </p><h2 id="tomcat部署"><a href="#tomcat部署" class="headerlink" title="tomcat部署"></a>tomcat部署</h2><p>（1）拉取镜像</p><pre><code>docker pull tomcat:7-jre7</code></pre><p>（2）创建容器</p><p>创建容器  -p表示地址映射</p><pre><code>docker run -di --name=mytomcat -p 9000:8080 -v /usr/local/webapps:/usr/local/tomcat/webapps tomcat:7-jre7</code></pre><h2 id="Nginx部署"><a href="#Nginx部署" class="headerlink" title="Nginx部署"></a>Nginx部署</h2><p>（1）拉取镜像    </p><pre><code>docker pull nginx</code></pre><p>（2）创建Nginx容器</p><pre><code>docker run -di --name=mynginx -p 80:80 nginx</code></pre><h2 id="Redis部署"><a href="#Redis部署" class="headerlink" title="Redis部署"></a>Redis部署</h2><p>（1）拉取镜像</p><pre><code>docker pull redis</code></pre><p>（2）创建容器</p><pre><code>docker run -di --name=myredis -p 6379:6379 redis</code></pre><h1 id="迁移与备份"><a href="#迁移与备份" class="headerlink" title="迁移与备份"></a>迁移与备份</h1><h2 id="容器保存为镜像"><a href="#容器保存为镜像" class="headerlink" title="容器保存为镜像"></a>容器保存为镜像</h2><p>我们可以通过以下命令将容器保存为镜像</p><pre><code>docker commit mynginx mynginx_i</code></pre><h2 id="镜像备份"><a href="#镜像备份" class="headerlink" title="镜像备份"></a>镜像备份</h2><p>我们可以通过以下命令将镜像保存为tar 文件</p><pre><code>docker  save -o mynginx.tar mynginx_i</code></pre><h2 id="镜像恢复与迁移"><a href="#镜像恢复与迁移" class="headerlink" title="镜像恢复与迁移"></a>镜像恢复与迁移</h2><p>首先我们先删除掉mynginx_img镜像  然后执行此命令进行恢复</p><pre><code>docker load -i mynginx.tar</code></pre><p>-i 输入的文件</p><p>执行后再次查看镜像，可以看到镜像已经恢复</p><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><blockquote><p><a href="https://www.cnblogs.com/panwenbin-logs/p/8007348.html" target="_blank" rel="noopener">Dockerfile文件详解</a></p></blockquote><h2 id="什么是Dockerfile"><a href="#什么是Dockerfile" class="headerlink" title="什么是Dockerfile"></a>什么是Dockerfile</h2><p>Dockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。</p><ul><li>对于开发人员：可以为开发团队提供一个完全一致的开发环境； </li><li>对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了； </li><li>对于运维人员：在部署时，可以实现应用的无缝移植。</li></ul><h2 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>FROM image_name:tag</td><td>定义了使用哪个基础镜像启动构建流程</td></tr><tr><td>MAINTAINER user_name</td><td>声明镜像的创建者</td></tr><tr><td>ENV key value</td><td>设置环境变量 (可以写多条)</td></tr><tr><td>RUN command</td><td>是Dockerfile的核心部分(可以写多条)</td></tr><tr><td>ADD source_dir/file dest_dir/file</td><td>将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压</td></tr><tr><td>COPY source_dir/file dest_dir/file</td><td>和ADD相似，但是如果有压缩文件并不能解压</td></tr><tr><td>WORKDIR path_dir</td><td>设置工作目录</td></tr></tbody></table><h2 id="使用脚本创建镜像"><a href="#使用脚本创建镜像" class="headerlink" title="使用脚本创建镜像"></a>使用脚本创建镜像</h2><p>步骤：</p><p>（1）创建目录</p><pre><code>mkdir –p /usr/local/dockerjdk8</code></pre><p>（2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/dockerjdk8目录</p><p>（3）创建文件Dockerfile  <code>vi Dockerfile</code></p><pre><code>#依赖镜像名称和IDFROM centos:7#指定镜像创建者信息MAINTAINER ITCAST#切换工作目录WORKDIR /usrRUN mkdir  /usr/local/java#ADD 是相对路径jar,把java添加到容器中ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/#配置java环境变量ENV JAVA_HOME /usr/local/java/jdk1.8.0_171ENV JRE_HOME $JAVA_HOME/jreENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATHENV PATH $JAVA_HOME/bin:$PATH</code></pre><p>（4）执行命令构建镜像</p><pre><code>docker build -t='jdk1.8' .</code></pre><p>注意后边的空格和点，不要省略</p><p>（5）查看镜像是否建立完成</p><pre><code>docker images</code></pre><h1 id="Docker私有仓库"><a href="#Docker私有仓库" class="headerlink" title="Docker私有仓库"></a>Docker私有仓库</h1><h2 id="私有仓库搭建与配置"><a href="#私有仓库搭建与配置" class="headerlink" title="私有仓库搭建与配置"></a>私有仓库搭建与配置</h2><p>（1）拉取私有仓库镜像（此步省略）</p><pre><code>docker pull registry</code></pre><p>（2）启动私有仓库容器</p><pre><code>docker run -di --name=registry -p 5000:5000 registry</code></pre><p>（3）打开浏览器 输入地址<a href="http://192.168.184.141:5000/v2/_catalog看到`{&quot;repositories&quot;:[]}`" target="_blank" rel="noopener">http://192.168.184.141:5000/v2/_catalog看到`{"repositories":[]}`</a> 表示私有仓库搭建成功并且内容为空</p><p>（4）修改daemon.json</p><pre><code>vi /etc/docker/daemon.json</code></pre><p>添加以下内容，保存退出。</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"insecure-registries"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"192.168.184.141:5000"</span><span class="token punctuation">]</span><span class="token punctuation">}</span> </code></pre><p>此步用于让 docker信任私有仓库地址</p><p>（5）重启docker 服务</p><pre><code>systemctl restart docker</code></pre><h2 id="镜像上传至私有仓库"><a href="#镜像上传至私有仓库" class="headerlink" title="镜像上传至私有仓库"></a>镜像上传至私有仓库</h2><p>（1）标记此镜像为私有仓库的镜像</p><pre><code>docker tag jdk1.8 192.168.184.141:5000/jdk1.8</code></pre><p>（2）再次启动私服容器</p><pre><code>docker start registry</code></pre><p>（3）上传标记的镜像</p><pre><code>docker push 192.168.184.141:5000/jdk1.8</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 运维 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
