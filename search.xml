<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Netty进阶之青铜篇</title>
      <link href="/2020/07/11/netty-jin-jie-zhi-qing-tong-pian/"/>
      <url>/2020/07/11/netty-jin-jie-zhi-qing-tong-pian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>走进Java NIO<br><a id="more"></a></p></blockquote><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><pre><code>Java的I/O演进之路    1.掌握相关概念    2.了解UNIX系统常用的I/O模型    3.了解Java的I/O历史演进</code></pre><h3 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h3><h4 id="Java的I-O演进之路-了解"><a href="#Java的I-O演进之路-了解" class="headerlink" title="Java的I/O演进之路(了解)"></a>Java的I/O演进之路(了解)</h4><h5 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h5><h5 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h5><h6 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h6><pre><code>在Linux中,外部设备都被看作是一个文件,即Linux操作一个外部设备就是操作一个文件,对文件的读写操作会调用内核提供的系统命令,返回一个file descriptor(fd,文件描述符)</code></pre><h5 id="干什么"><a href="#干什么" class="headerlink" title="干什么"></a>干什么</h5><pre><code>fd的作用是记录一个数组,这个数字指向内核中的一个结构体,这个结构体记录了文件的路径,数据区等一些属性</code></pre><h5 id="UNIX的5种I-O模型"><a href="#UNIX的5种I-O模型" class="headerlink" title="UNIX的5种I/O模型"></a>UNIX的5种I/O模型</h5><h6 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h6><p>操作系统是支持异步I/O（NIO）的</p><h6 id="阻塞I-O模型"><a href="#阻塞I-O模型" class="headerlink" title="阻塞I/O模型"></a>阻塞I/O模型</h6><pre><code>核心：等待一个流程完成1.最常用2.默认情况下,所有文件都是被阻塞的,从调用开始到被返回进程都是阻塞状态</code></pre><h6 id="非阻塞I-O模型"><a href="#非阻塞I-O模型" class="headerlink" title="非阻塞I/O模型"></a>非阻塞I/O模型</h6><pre><code>核心：不等待,轮询检测</code></pre><h6 id="I-O多路复用模型"><a href="#I-O多路复用模型" class="headerlink" title="I/O多路复用模型"></a>I/O多路复用模型</h6><pre><code>select/poll1.进程将一个或多个fd传递个select系统或poll系统调用2.阻塞在select3.顺序扫描fd,支持的fd数量有限epoll1.基于事件驱动方式代替顺序扫描,性能更高</code></pre><h6 id="信号驱动I-O模型"><a href="#信号驱动I-O模型" class="headerlink" title="信号驱动I/O模型"></a>信号驱动I/O模型</h6><pre><code>核心：信号通知,收到信号执行响应的步骤,非阻塞</code></pre><h6 id="异步I-O模型"><a href="#异步I-O模型" class="headerlink" title="异步I/O模型"></a>异步I/O模型</h6><pre><code>核心：告知内核启动某个操作,并在操作完这个操作,给个通知与信号驱动I/O的区别：信号I/O通知过去做，异步I/O通知已完成</code></pre><h5 id="Java的I-O演进"><a href="#Java的I-O演进" class="headerlink" title="Java的I/O演进"></a>Java的I/O演进</h5><p>1.Java1.4之前早期版本遇到的问题</p><ul><li>没有缓冲区,I/O性能存在问题</li><li>没有C系列的Channel概念,只有输入和输出流</li><li>同步阻塞式I/O通信(BIO),会导致通信线程被长时间阻塞</li><li>支持的字符集有限,硬件可移植性不好</li></ul><p>2.2002年JDK1.4发布,开始支持非阻塞I/O</p><h4 id="NIO入门"><a href="#NIO入门" class="headerlink" title="NIO入门"></a>NIO入门</h4><h5 id="BIO编程"><a href="#BIO编程" class="headerlink" title="BIO编程"></a>BIO编程</h5><h5 id="伪异步I-O编程"><a href="#伪异步I-O编程" class="headerlink" title="伪异步I/O编程"></a>伪异步I/O编程</h5><h5 id="NIO编程"><a href="#NIO编程" class="headerlink" title="NIO编程"></a>NIO编程</h5><h5 id="AIO编程"><a href="#AIO编程" class="headerlink" title="AIO编程"></a>AIO编程</h5><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> INNER </category>
          
      </categories>
      
      
        <tags>
            
            <tag> inner </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML手册</title>
      <link href="/2020/05/15/uml-shou-ce/"/>
      <url>/2020/05/15/uml-shou-ce/</url>
      
        <content type="html"><![CDATA[<h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><h6 id="一、明确和理解问题"><a href="#一、明确和理解问题" class="headerlink" title="一、明确和理解问题"></a>一、明确和理解问题</h6><p><strong>问题本质是什么</strong>：<br>不理解建模语言，看不懂建模图，知识盲区</p><p><strong>1.找出对方关心的问题点</strong><br>    看懂并会画建模图<br><strong>2.明确解决问题的目标</strong><br>    看懂、会画、长久记忆<br><strong>3.明确可以用来解决这个问题的资源</strong><br>百度搜索<br>    参考博文：<br><a href="https://blog.csdn.net/suxinpingtao51/article/details/8011335" target="_blank" rel="noopener">https://blog.csdn.net/suxinpingtao51/article/details/8011335</a></p><h6 id="二、拆分和定位问题"><a href="#二、拆分和定位问题" class="headerlink" title="二、拆分和定位问题"></a>二、拆分和定位问题</h6><p><strong>原问题</strong><br>什么是UML？<br>UML有几种类图？<br>类图分别是什么<br>有什么区别？<br>引用于哪些场景？</p><p><strong>公式思维</strong></p><p>UML（常见） = 泛化（继承） + 实现 + 组合 + 聚合 + 关联 + 依赖</p><p><strong>推理模式(假设驱动/构建问题树)</strong></p><p><strong>MECE法则</strong></p><p><strong>横纵对比看数据</strong><br><img src="/2020/05/15/uml-shou-ce/source/_posts/uml-shou-ce/zongtu.gif" alt=""></p><h6 id="三、提出解决方案"><a href="#三、提出解决方案" class="headerlink" title="三、提出解决方案"></a>三、提出解决方案</h6><ul><li>什么是UML？</li></ul><p>统一建模语言(Unified Modeling Language，UML)是一种为面向对象系统的产品进行说明、可视化和编制文档的一种标准语言，是非专利的第三代建模和规约语言。UML使用面向对象设计的的建模工具，但独立于任何具体程序设计语言。</p><ul><li>UML有几种类图？</li></ul><p>常见的有以下几种关系: 泛化（Generalization）,  实现（Realization）, 关联（Association), 聚合（Aggregation）, 组合(Composition), 依赖(Dependency)</p><ul><li>类图分别是什么，有什么区别？</li></ul><hr><p><strong>泛化（Generalization）</strong><br>【泛化关系】：是一种<strong>继承</strong>关系, 表示一般与特殊的关系, 它指定了子类如何特化父类的所有特征和行为. 例如：老虎是动物的一种, 即有老虎的特性也有动物的共性.<br>【箭头指向】：带<strong>三角箭头的实线</strong>，箭头<strong>指向父类</strong></p><p><img src="/2020/05/15/uml-shou-ce/source/_posts/uml-shou-ce/fanhua.gif" alt=""></p><hr><p><strong>实现（Realization）</strong><br>【实现关系】：是一种类与接口的<strong>实现</strong>关系, 表示类是接口所有特征和行为的实现<br>【箭头指向】：带<strong>三角箭头的虚线</strong>，箭头<strong>指向接口</strong><br><img src="/2020/05/15/uml-shou-ce/source/_posts/uml-shou-ce/shixian.gif" alt=""></p><hr><p><strong>关联（Association)</strong><br>【关联关系】：是一种<strong>拥有</strong>的关系, 它使一个类知道另一个类的属性和方法；如：老师与学生，学生与课程，关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。<br>【箭头及指向】：带<strong>普通箭头</strong>（或<strong>实心三角形箭头</strong>）<strong>的实心线</strong>，<strong>指向被拥有者</strong><br>【代码体现】：成员变量<br><img src="/2020/05/15/uml-shou-ce/source/_posts/uml-shou-ce/guanlian.gif" alt=""></p><p>老师与学生是双向关联，老师有多名学生，学生也可能有多名老师。但学生与某课程间的关系为单向关联，一名学生可能要上多门课程，课程是个抽象的东西他不拥有学生。</p><hr><p><strong>聚合（Aggregation）</strong><br> 【聚合关系】：是<strong>整体与部分</strong>的关系, 且<strong>部分</strong>可以离开整体而<strong>单独存在</strong>. 如车和轮胎是整体和部分的关系, 轮胎离开车仍然可以存在.聚合关系是<strong>关联关系的一种</strong>，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。<br> 【箭头及指向】：带<strong>空心菱形的实心线</strong>，菱形<strong>指向整体</strong><br> 【代码体现】：成员变量<br><img src="/2020/05/15/uml-shou-ce/source/_posts/uml-shou-ce/juhe.gif" alt=""></p><hr><p><strong>组合(Composition)</strong><br>【组合关系】：是<strong>整体与部分</strong>的关系, 但<strong>部分不能</strong>离开整体而<strong>单独存在</strong>. 如公司和部门是整体和部分的关系, 没有公司就不存在部门. 组合关系是<strong>关联关系的一种</strong>，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期<br>【箭头及指向】：带<strong>实心菱形的实线</strong>，菱形<strong>指向整体</strong><br>【代码体现】：成员变量</p><p><img src="/2020/05/15/uml-shou-ce/source/_posts/uml-shou-ce/zuhe.gif" alt=""></p><hr><p><strong>依赖(Dependency)</strong><br>【依赖关系】：是一种<strong>使用</strong>的关系,  即一个类的实现需要另一个类的协助, 所以要尽量不使用双向的互相依赖.<br>【箭头及指向】：带<strong>箭头的虚线</strong>，<strong>指向被使用者</strong><br>【代码表现】：局部变量、方法的参数或者对静态方法的调用<br><img src="/2020/05/15/uml-shou-ce/source/_posts/uml-shou-ce/yilai.gif" alt=""></p><hr><p>有什么区别？</p><p>各种关系的强弱顺序：<br>泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</p><h6 id="四、总结问题"><a href="#四、总结问题" class="headerlink" title="四、总结问题"></a>四、总结问题</h6><p>首先，我们要从结论不断地分拆，直到那个不可辩驳的事实；<br>其次，每一个层级都要控制要点的数目，要突出重点。</p><p>拓展：<br>序列图、用例图</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> INNER </category>
          
      </categories>
      
      
        <tags>
            
            <tag> inner </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客导图</title>
      <link href="/2020/05/14/bo-ke-dao-tu/"/>
      <url>/2020/05/14/bo-ke-dao-tu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>博客导图</p></blockquote> <a id="more"></a> <p><a href="https://www.edrawsoft.cn/viewer/public/s/0f348859563194" target="_blank" rel="noopener">BLOG MAP</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> FEELING </category>
          
      </categories>
      
      
        <tags>
            
            <tag> feeling </tag>
            
            <tag> MAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo操作手册</title>
      <link href="/2020/05/14/hexo-cao-zuo-shou-ce/"/>
      <url>/2020/05/14/hexo-cao-zuo-shou-ce/</url>
      
        <content type="html"><![CDATA[<blockquote><p>A fast, simple &amp; powerful blog framework</p></blockquote><a id="more"></a><h3 id="官方网站："><a href="#官方网站：" class="headerlink" title="官方网站："></a>官方网站：</h3><p><a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/configuration</a></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)</p><pre><code>$ hexo clean</code></pre><p>生成静态文件</p><pre><code>$ hexo generate    -d, --deploy    文件生成后立即部署网站    -w, --watch    监视文件变动</code></pre><p>部署</p><pre><code>hexo d</code></pre><p>启动服务器。默认情况下,访问网址为: <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p><pre><code>$ hexo server    -p, --port    重设端口    -s, --static    只使用静态文件    -l, --log    启动日记记录，使用覆盖记录格式</code></pre><p>发表草稿</p><pre><code>$ hexo publish [layout] &lt;filename&gt; </code></pre><p>显示草稿</p><pre><code>$ hexo --draft</code></pre><p>自定义 CWD（Current working directory）</p><pre><code>$ hexo --cwd /path/to/cwd</code></pre><p>创建文档</p><pre><code>hexo new [layout] &lt;title&gt;ex:    hexo new inner demo01    hexo new outer demo01    hexo new feeling demo01draft--&gt;publichexo publish [layout] &lt;title&gt;ex:    hexo new draft demo01    hexo publish inner &lt;title&gt;</code></pre><h3 id="页眉说明"><a href="#页眉说明" class="headerlink" title="页眉说明"></a>页眉说明</h3><pre><code>title: Hexo操作手册 //标题author: 571 //作者series: INNER //所属系列categories: INNER //所属类别comments: true //是否开启评论： true 开启img: /cover/abc.jpg  //封面图top: false //是否置顶 true 是cover: false //是否轮播 true 是tags:  //标签  - inner  - 手册date: 2020-05-14 21:58:38  //创建时间updated: 2020-05-14 21:58:38 //修改时间</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> INNER </category>
          
      </categories>
      
      
        <tags>
            
            <tag> inner </tag>
            
            <tag> 手册 </tag>
            
            <tag> 技术手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流年笑掷,未来可期</title>
      <link href="/2020/05/14/liu-nian-xiao-zhi-wei-lai-ke-qi/"/>
      <url>/2020/05/14/liu-nian-xiao-zhi-wei-lai-ke-qi/</url>
      
        <content type="html"><![CDATA[<h3 id="2020-写在前面"><a href="#2020-写在前面" class="headerlink" title="2020 写在前面"></a>2020 写在前面</h3><p>  毕业至今,已5年有余,一直想对自己的工作学习生活有个落地的总结,深知自己是一个思想的巨人,行动的矮子,大道理知道很多,却依然过不好这一生。回首毕业这几年,就拿编程来说,似乎没有什么技术上的沉淀和质的飞跃,每天重复着撸着相同却没有新意的代码,以最熟悉的方式撸着,有些时候深思一个原理,分析一段稍微花哨点的代码,却似懂非懂,知道有那么一回事,却说不清道不明,其实也就是所谓的不懂。虽说混迹于互联网金融圈内,每天和钱打交道,从彩票到区块链数字货币, 庆幸至今从自己手里写的代码还没有发生给客户造成损失的同时,却总是有些惴惴不安,似乎有一场最终的审判在哪天便如期而至,每每听到有同事因为误操作,代码不严谨或者一些莫名其妙的问题导致给公司和客户造成了损失,映射到自己身上却细思极恐。<br>  知道写总结的好处,也曾尝试着通过各种方式写过几次,写得少,拎不清重点的写,抄书式的写,最终浪费了大量的时间的同时,收效也少的可怜,最终从内心给自己的负面暗示是还不如自己去百度、google、或者收集一大堆书签以备不时之需,事实却永远用不上,或者用的时候找不到,脱离了它们更是一无所知,也就是我知道有那么回事,也曾经解决过,但是现在我说不清楚,给我几分钟,我去找找的被动状态。因为没有将这些信息内化成自己的知识,也只是解决了当时的问题,却没有熟练运用。这样的行为,生活随处可见,无限的死循环：打游戏、熬夜、不运动、懒惰、受刺激打一波鸡血…<br>  2020.1.5,我的小女儿Vicky降生了,也顺理成章的多个一个爸爸的角色,瞬间有种很强烈的责任压在自己的肩上,不想因为自己的人性弱点,而给她树立一个不合格的榜样,育人先正己,所以2020年开始,做个合格的技术人,丈夫,儿子和爸爸。<br>  流年笑掷，把握当下，未来可期。</p><h3 id="2020-年中跟近"><a href="#2020-年中跟近" class="headerlink" title="2020 年中跟近"></a>2020 年中跟近</h3><h3 id="2020-年末总结"><a href="#2020-年末总结" class="headerlink" title="2020 年末总结"></a>2020 年末总结</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> FEELING </category>
          
      </categories>
      
      
        <tags>
            
            <tag> feeling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Installs</title>
      <link href="/2019/10/29/docker-installs/"/>
      <url>/2019/10/29/docker-installs/</url>
      
        <content type="html"><![CDATA[<blockquote><p>docker 安装软件工具<br><a id="more"></a></p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><a href="http://tryto.top/2019/10/11/docker/">docker准备工作传送门</a></p><h2 id="命令快捷"><a href="#命令快捷" class="headerlink" title="命令快捷"></a>命令快捷</h2><ul><li>查看镜像<pre><code># docker images | grep ?</code></pre></li><li>启动容器<pre><code># docker run -id --name=matrix_mysql -p 13306:3306 -e MYSQL_ROOT_PASSWORD=abc123 mysql</code></pre></li><li>进入容器<pre><code># docker exec -it 容器名/容器Id  /bin/bash</code></pre></li></ul><h2 id="安装Nexus3"><a href="#安装Nexus3" class="headerlink" title="安装Nexus3"></a>安装Nexus3</h2><h3 id="查询镜像"><a href="#查询镜像" class="headerlink" title="查询镜像"></a>查询镜像</h3><pre><code># docker search nexus</code></pre><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><pre><code># docker pull sonatype/nexus3</code></pre><h3 id="配置本地保存数据的路径"><a href="#配置本地保存数据的路径" class="headerlink" title="配置本地保存数据的路径"></a>配置本地保存数据的路径</h3><p>  路径可自定义,我放在/docker/nexus/nexus-data下。</p><p>  注意：在生成目录的时候，因为nexus的读写默认是200,docker run的时候会报找不到路径的错误</p><p><a href="https://www.cnblogs.com/badaoliumangqizhi/p/11565113.html" target="_blank" rel="noopener">可能遇到的问题:找不到路径错误</a></p><h3 id="修改目录权限"><a href="#修改目录权限" class="headerlink" title="修改目录权限"></a>修改目录权限</h3><pre><code># chmod 777 docker# chmod 777 nexus# chmod 777 nexus-data</code></pre><h3 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h3><pre><code># docker run -d -p 8081:8081 -p 8082:8082 -p 8083:8083 --name matrix_nexus3 -v /usr/etc/docker/nexus/nexus-data:/nexus-data sonatype/nexus3</code></pre><ul><li>8082<br>  客户端页面的对外端口;</li><li>8082<br>  准备建立docker hosted 私有库使用。hosted可以上传下载我建立的images;</li><li>8083<br>  准备建立docker proxy 代理库使用。 proxy可以镜像远程公共仓库，比如：docke官方仓库、aliyun等等;</li><li>daemon.json<br>  在/etc/docker/daemon.json这个文件夹中配置;</li></ul><p>daemon.json文件中的配置说明：</p><pre><code>{    "registry-mirrors": ["https://1v50e4uy.mirror.aliyuncs.com"],    ----文件加速地址，下载国外的镜像，通过它进行加速    "insecure-registries":["192.168.111.112:8083"]      ---配置本地的镜像库地址,每次拖取镜像,如果8083上没有，先从远程库下载，下载到8083，再下载到本地库，下次再下载的时候，就从8083上下载了。 }</code></pre><h3 id="登录-Nexus3"><a href="#登录-Nexus3" class="headerlink" title="登录 Nexus3"></a>登录 Nexus3</h3><p>1.登录链接：<a href="http://192.168.111.112:8081/" target="_blank" rel="noopener">http://192.168.111.112:8081/</a></p><p>2.默认用户名:admin  默认密码不再是admin123,所以需要去容器内查看</p><p>3.查看默认密码：进入容器内查看</p><pre><code># docker exec -it matrix_nexus3 /bin/bash# cd nexus-data/# vi admin.password  ---复制出密码,去网页登录</code></pre><p>4.登录完成后,默认提示修改新密码,新密码改完后,admin.password将会消失,所以要保管好密码</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study </tag>
            
            <tag> Ops </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Installs</title>
      <link href="/2019/10/29/linux-installs/"/>
      <url>/2019/10/29/linux-installs/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Linux 软件工具安装<br><a id="more"></a></p></blockquote><h2 id="安装Java"><a href="#安装Java" class="headerlink" title="安装Java"></a>安装Java</h2><h3 id="通过yum方式安装Java"><a href="#通过yum方式安装Java" class="headerlink" title="通过yum方式安装Java"></a>通过yum方式安装Java</h3><h4 id="查看JDK是否已安装"><a href="#查看JDK是否已安装" class="headerlink" title="查看JDK是否已安装"></a>查看JDK是否已安装</h4><pre><code># yum list installed | grep java</code></pre><h4 id="若已经安装了JDK，如何卸载Java环境？"><a href="#若已经安装了JDK，如何卸载Java环境？" class="headerlink" title="若已经安装了JDK，如何卸载Java环境？"></a>若已经安装了JDK，如何卸载Java环境？</h4><ul><li>卸载JDK相关文件：<pre><code># yum -y remove java-1.7.0-openjdk*</code></pre>卸载tzdata-java：<pre><code># yum -y remove tzdata-java.noarch</code></pre>注：“*”表示卸载掉java 1.7.0的所有openjdk相关文件<h4 id="查看yum库中的Java安装包"><a href="#查看yum库中的Java安装包" class="headerlink" title="查看yum库中的Java安装包"></a>查看yum库中的Java安装包</h4><pre><code># yum -y list java*</code></pre><h4 id="安装Java安装包"><a href="#安装Java安装包" class="headerlink" title="安装Java安装包"></a>安装Java安装包</h4></li></ul><p>以yum库中java-1.8.0为例：</p><pre><code># yum -y install java-1.8.0-openjdk*</code></pre><p>注：“*”表示将java-1.8.0的所有相关Java程序都安装上</p><h4 id="查看刚刚安装版本"><a href="#查看刚刚安装版本" class="headerlink" title="查看刚刚安装版本"></a>查看刚刚安装版本</h4><pre><code># java -version</code></pre><h4 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h4><p>1.修改配置文件</p><pre><code># vim /etc/profile# export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk# export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar# export PATH=$PATH:$JAVA_HOME/bin</code></pre><p>2.生效修改</p><pre><code># source /etc/profile</code></pre><h3 id="通过压缩包安装Java"><a href="#通过压缩包安装Java" class="headerlink" title="通过压缩包安装Java"></a>通过压缩包安装Java</h3><p>####准备工作：</p><ul><li>jdk-8u11-linux-x64.tar.gz<br>下载地址：<a href="https://pan.baidu.com/s/1smNHABN" target="_blank" rel="noopener">https://pan.baidu.com/s/1smNHABN</a> (ps：也可在官网下载最新jdk:<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a>)</li><li>shell<br>在windows下载完成jdk后，通过shell发送到Linux上</li></ul><h4 id="登录Linux，切换到root用户"><a href="#登录Linux，切换到root用户" class="headerlink" title="登录Linux，切换到root用户"></a>登录Linux，切换到root用户</h4><pre><code># su root ---获取root用户权限，当前工作目录不变(需要root密码)</code></pre><p>或者</p><pre><code># sudo -i ---不需要root密码直接切换成root（需要当前用户密码）</code></pre><h4 id="在usr目录下建立Java安装目录"><a href="#在usr目录下建立Java安装目录" class="headerlink" title="在usr目录下建立Java安装目录"></a>在usr目录下建立Java安装目录</h4><pre><code># cd /usr/local/src/# mkdir java</code></pre><h4 id="解压jdk到当前目录-得到文件夹-jdk1-8-0-11"><a href="#解压jdk到当前目录-得到文件夹-jdk1-8-0-11" class="headerlink" title="解压jdk到当前目录,得到文件夹 jdk1.8.0_11"></a>解压jdk到当前目录,得到文件夹 jdk1.8.0_11</h4><pre><code># tar -zxvf jdk-8u11-linux-x64.tar.gz</code></pre><h4 id="解压完建立一个链接以节省目录长度"><a href="#解压完建立一个链接以节省目录长度" class="headerlink" title="解压完建立一个链接以节省目录长度"></a>解压完建立一个链接以节省目录长度</h4><pre><code># ln -s /usr/local/src/java/jdk1.8.0_11/ /usr/local/src/jdk</code></pre><h4 id="编辑配置文件，配置环境变量"><a href="#编辑配置文件，配置环境变量" class="headerlink" title="编辑配置文件，配置环境变量"></a>编辑配置文件，配置环境变量</h4><pre><code># vim /etc/profile</code></pre><p>在文末添加如下内容：</p><pre><code># JAVA_HOME=/usr/local/src/jdk# CLASSPATH=$JAVA_HOME/lib/# PATH=$PATH:$JAVA_HOME/bin# export PATH JAVA_HOME CLASSPATH</code></pre><h4 id="重启机器或执行命令"><a href="#重启机器或执行命令" class="headerlink" title="重启机器或执行命令"></a>重启机器或执行命令</h4><pre><code># sudo shutdown -r now</code></pre><h4 id="查看刚刚安装版本-1"><a href="#查看刚刚安装版本-1" class="headerlink" title="查看刚刚安装版本"></a>查看刚刚安装版本</h4><pre><code># java -version</code></pre><h2 id="安装Maven"><a href="#安装Maven" class="headerlink" title="安装Maven"></a>安装Maven</h2><h3 id="在线下载安装"><a href="#在线下载安装" class="headerlink" title="在线下载安装"></a>在线下载安装</h3><h4 id="安装wget命令"><a href="#安装wget命令" class="headerlink" title="安装wget命令"></a>安装wget命令</h4><pre><code># yum -y install wget</code></pre><h4 id="下载maven安装包"><a href="#下载maven安装包" class="headerlink" title="下载maven安装包"></a>下载maven安装包</h4><pre><code># cd /usr/local/src/# wget http://mirrors.cnnic.cn/apache/maven/maven-3/3.5.4/binaries/apache-maven-3.5.4-bin.tar.gz</code></pre><h4 id="解压maven安装包"><a href="#解压maven安装包" class="headerlink" title="解压maven安装包"></a>解压maven安装包</h4><pre><code># tar -zxvf apache-maven-3.5.4-bin.tar.gz</code></pre><h4 id="配置maven"><a href="#配置maven" class="headerlink" title="配置maven"></a>配置maven</h4><pre><code># vi /etc/profile</code></pre><p>在配置文件配置</p><pre><code># export MAVEN_HOME=/usr/local/src/apache-maven-3.5.4# export PATH=$MAVEN_HOME/bin:$PATH</code></pre><p>配置文件生效</p><pre><code># source /etc/profile</code></pre><h4 id="查看maven"><a href="#查看maven" class="headerlink" title="查看maven"></a>查看maven</h4><pre><code># mvn -version</code></pre><h3 id="安装包安装"><a href="#安装包安装" class="headerlink" title="安装包安装"></a>安装包安装</h3><p><img src="/2019/10/29/linux-installs/404.jpg" alt=""></p><p><a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">Maven下载地址</a></p><h2 id="安装Nexus3"><a href="#安装Nexus3" class="headerlink" title="安装Nexus3"></a>安装Nexus3</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>安装Java</li><li>安装Maven</li></ul><h3 id="在线下载安装-1"><a href="#在线下载安装-1" class="headerlink" title="在线下载安装"></a>在线下载安装</h3><p><a href="https://my.oschina.net/u/2963821/blog/1806035" target="_blank" rel="noopener">在线下载安装传送门</a></p><h3 id="安装包安装-1"><a href="#安装包安装-1" class="headerlink" title="安装包安装"></a>安装包安装</h3><p><img src="/2019/10/29/linux-installs/404.jpg" alt=""></p><p><a href="https://www.sonatype.com/download-oss-sonatype" target="_blank" rel="noopener">Nexus下载地址1</a><br><a href="https://help.sonatype.com/repomanager3/download/download-archives---repository-manager-3" target="_blank" rel="noopener">Nexus下载地址2</a></p><h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><p>源码下载不动,无耐想到此法,推荐 <a href="http://tryto.top/2019/10/29/docker-installs/">Docker安装传送门</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study </tag>
            
            <tag> Ops </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《如何阅读一本书》</title>
      <link href="/2019/10/22/how-to-read-a-book/"/>
      <url>/2019/10/22/how-to-read-a-book/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我是一个不会读书的人，所以需要一份读书指南，指明方向，少走弯路。<br><a id="more"></a></p></blockquote><h2 id="《如何阅读一本书》"><a href="#《如何阅读一本书》" class="headerlink" title="《如何阅读一本书》"></a>《如何阅读一本书》</h2><p><img src="/2019/10/22/how-to-read-a-book/1-3.jpg" alt=""></p><p>仅供参考,请支持正版! <a href="https://pan.baidu.com/s/1hhfMdEqa30hXdRU5o8BiKg" target="_blank" rel="noopener">传送门</a></p><h3 id="留白"><a href="#留白" class="headerlink" title="留白"></a>留白</h3><ul><li>整体来说，这本书到底在谈些什么？<br>  这本书谈了什么：1.阅读的好处 2.阅读的技巧</li><li>书中的细节，作者是怎么谈的？<br>  细节怎么样：</li><li>这本书说的有道理吗？是全部的都有道理还是部分有道理？<br>  是否有道理：暂无评论资格，实践出真知</li><li>这本书跟你自己有什么关系?<br>  跟我们有什么关系：指明方向，少走弯路</li></ul><h3 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h3><p> <img src="/2019/10/22/how-to-read-a-book/1-0.jpg" alt=""></p><h3 id="阅读的好处"><a href="#阅读的好处" class="headerlink" title="阅读的好处"></a>阅读的好处</h3><blockquote><p>人的心智，或者说思考能力，和肌肉一样，如果不经常运用就会萎缩，而读书，正是防止心智萎缩、延缓心智衰老的最有效手段。</p></blockquote><p>老生常谈，不做累述。</p><h3 id="阅读的技巧"><a href="#阅读的技巧" class="headerlink" title="阅读的技巧"></a>阅读的技巧</h3><blockquote><p>“读得太快或太慢，都一无所获。”  ———[法]帕斯卡尔</p></blockquote><h4 id="书的分类"><a href="#书的分类" class="headerlink" title="书的分类"></a>书的分类</h4><p>书或者说阅读品，可以分为两类：</p><ul><li>读得懂的东西，就是报纸、杂志等一些我们一下子就能消化的，属于资讯，却不能够增加我们的理解力，如果你够敏感的话呢，就会发现读多了这样的东西，并没什么营养。</li><li>必须读的东西，就是指一个人要试着去读他并不怎么了解的东西，也就是略高于他的读物。<br>“如何阅读一本书”，主要指的是必须读的东西。</li></ul><h4 id="一个好的读者"><a href="#一个好的读者" class="headerlink" title="一个好的读者"></a>一个好的读者</h4><ul><li>应该更多地去读那些锻炼他的心智的书</li><li>必须主动，主动的读者会从阅读中获得更大的收益</li></ul><h4 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h4><h5 id="牢记四个问题"><a href="#牢记四个问题" class="headerlink" title="牢记四个问题"></a>牢记四个问题</h5><ul><li>整体来说，这本书到底在谈些什么？</li><li>书中的细节，作者是怎么谈的？</li><li>这本书说的有道理吗？是全部的都有道理还是部分有道理？</li><li>这本书跟你自己有什么关系?</li></ul><h5 id="四个问题对应四种层次"><a href="#四个问题对应四种层次" class="headerlink" title="四个问题对应四种层次"></a>四个问题对应四种层次</h5><p>由低到高：基础阅读、检视阅读、分析阅读、主题阅读</p><h6 id="第一层-基础阅读"><a href="#第一层-基础阅读" class="headerlink" title="第一层 基础阅读"></a>第一层 基础阅读</h6><p>所谓基础阅读，也就是初级阅读，只要不是文盲，能看懂字面意思，就可以完成，这个不用多说。</p><h6 id="第二层-检视阅读"><a href="#第二层-检视阅读" class="headerlink" title="第二层 检视阅读"></a>第二层 检视阅读</h6><p>简单来说或就是阅读理解，快速浏览。它也分两个阶段：</p><ul><li>第一阶段，学会有系统地略读<pre><code>具体的建议顺序是：先看书名、序言和副标题，接着研究目录和索引，然后看看作者简介，再翻开看一下和书名主题相关的篇章，开始读。这个技巧的难点是，需要你有背景知识。不过你书读得越多，就越容易。</code></pre></li><li>第二阶段，叫做快速通读<pre><code>就是说一本书不管你能不能看懂，都从头到尾翻一遍。用这个方法读完一本书之后，无论你用了多短的时间，你都能够对这本书的类别、题材、内容，有一个初步的了解。</code></pre></li></ul><h6 id="第三层-分析阅读"><a href="#第三层-分析阅读" class="headerlink" title="第三层 分析阅读"></a>第三层 分析阅读</h6><p>比较复杂也是最系统化的层次，分析阅读，主要分为三个阶段：</p><ul><li>第一阶段，了解范围<pre><code>  这本书在谈什么？你需要确定主题和书的分类，比如是文学还是历史或者经济学？然后要用一小段内容叙述整本书的内容，把重点的章节列出来，找出作者要在书里讨论的问题是什么？其实，这个阶段也不复杂，你只需要做到一点，不要拿起一本书就闷头读，先搞清楚这本书的结构再下手。</code></pre></li><li>第二阶段，理解内容<pre><code>  这本书作者是怎么写出来的？你需要找出书里反复出现的关键词，需要在那些你认为重要的句子下画出标记，从这些话里找出作者的中心思想，用做笔记的方式重新搭建书里的前因后果，有时候，画一张表就能解决这个问题。看着这张你自己画的笔记图，你可以在脑子里迅速过一遍全书的论述是怎样展开的。</code></pre></li><li>第三阶段，评价<pre><code>  这本书写得怎么样？看任何书，都一定要有评论，要有自己的态度。当你完成了对一本书的评价，才算真正完成了对这本书的阅读。最有学习能力的读者，也就是最能批评的读者。但是记住，不要在读完之前就随便下结论，如果读完以后你不能同意作者的看法，你要学会总结原因，如果你还是没有理解作者的看法，也列举下你的原因。</code></pre></li></ul><h6 id="第四层-主题阅读"><a href="#第四层-主题阅读" class="headerlink" title="第四层 主题阅读"></a>第四层 主题阅读</h6><p>简单来说就是按图索骥。照着你自己感兴趣的主题找书去读。这个层次的阅读需要更强的主动性，还需要读者有一定的判断力。主题阅读，不是说你读完了一本书接着读第二本，而是说你带着你想解决的问题，去读不同的书里的不同的章节。主题阅读不是为了看书而看书，而是为了解决实用性的问题而看书。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>《如何阅读一本书》告诉我们阅读的好处和阅读的技巧，阅读，是防止心智萎缩、延缓心智衰老的最有效手段。而阅读的方法，一个总的原则是，我们应该尽量去读那些“略高于我们的”读物，而判断标准就是“这本书谈了什么、细节怎么样、是否有道理、跟我们有什么关系”这四点，这是在翻开一本书的时候应该着重注意的，而相对应的，阅读由低到高，也可以分为四个阶段，分别是：基础阅读、检视阅读、分析阅读和主题阅读，各有不同的技巧和注意事项，当你能够掌握对不同的书的不同阅读方法，你就会收获读书带给你的巨大回报。<br>这本畅销70多年的“阅读宝典”，我就给你说到这，希望它能带给你对于阅读的新启发。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><em>本文图文参考：《得到》每天听本书栏目</em></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STUDY </tag>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker,轻量级的虚拟化技术</title>
      <link href="/2019/10/11/docker/"/>
      <url>/2019/10/11/docker/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><blockquote><p>一个利用了lxc的技术的一个虚拟化引擎。<br><a id="more"></a></p></blockquote><h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><h2 id="什么是虚拟化"><a href="#什么是虚拟化" class="headerlink" title="什么是虚拟化"></a>什么是虚拟化</h2><p>​    在计算机中，虚拟化（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。这些资源的新虚拟部份是不受现有资源的架设方式，地域或物理组态所限制。一般所指的虚拟化资源包括计算能力和资料存储。</p><p>​    在实际的生产环境中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件   对资源充分利用</p><p>​    虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机等等。</p><h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h2><p>​    Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 <a href="https://github.com/docker/docker" target="_blank" rel="noopener">GitHub</a> 上进行维护。</p><p>​    <img src="/2019/10/11/docker/1-3.png" alt=""></p><p>​    Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。</p><p>​    Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。</p><p>​    在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。</p><p>为什么选择Docker?</p><p>（1）上手快。</p><p>​    用户只需要几分钟，就可以把自己的程序“Docker化”。Docker依赖于“写时复制”（copy-on-write）模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改”的境界。    </p><pre><code>     随后，就可以创建容器来运行应用程序了。大多数Docker容器只需要不到1秒中即可启动。由于去除了管理程序的开销，Docker容器拥有很高的性能，同时同一台宿主机中也可以运行更多的容器，使用户尽可能的充分利用系统资源。</code></pre><p>（2）职责的逻辑分类</p><p>​    使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。Docker设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题（测试环境都是正常的，上线后出了问题就归结为肯定是运维的问题）”</p><p>（3）快速高效的开发生命周期</p><p>​    Docker的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。（通俗一点说，Docker就像一个盒子，里面可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件件的取。）</p><p>（4）鼓励使用面向服务的架构</p><p>​    Docker还鼓励面向服务的体系结构和微服务架构。Docker推荐单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单，同时也提高了程序的内省性。（当然，可以在一个容器中运行多个应用程序）</p><h2 id="1-3-容器与虚拟机比较"><a href="#1-3-容器与虚拟机比较" class="headerlink" title="1.3 容器与虚拟机比较"></a>1.3 容器与虚拟机比较</h2><p>​    下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。</p><p><img src="/2019/10/11/docker/1-1.png" alt=""></p><p>与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。</p><h2 id="Docker-组件"><a href="#Docker-组件" class="headerlink" title="Docker 组件"></a>Docker 组件</h2><h3 id="Docker服务器与客户端"><a href="#Docker服务器与客户端" class="headerlink" title="Docker服务器与客户端"></a>Docker服务器与客户端</h3><p>​    Docker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。</p><p><img src="/2019/10/11/docker/1-2.png" alt=""></p><h3 id="Docker镜像与容器"><a href="#Docker镜像与容器" class="headerlink" title="Docker镜像与容器"></a>Docker镜像与容器</h3><p>​    镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。例如：</p><p>添加一个文件；</p><p>执行一个命令；</p><p>打开一个窗口。</p><p>也可以将镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新。</p><p>​    Docker可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容器即可。容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。  容器基于镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务。</p><p>所以Docker容器就是：</p><p>​    一个镜像格式；</p><p>​    一些列标准操作；</p><p>​    一个执行环境。</p><p>​    Docker借鉴了标准集装箱的概念。标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。</p><pre><code>     和集装箱一样，Docker在执行上述操作时，并不关心容器中到底装了什么，它不管是web服务器，还是数据库，或者是应用程序服务器什么的。所有的容器都按照相同的方式将内容“装载”进去。     Docker也不关心你要把容器运到何方：我们可以在自己的笔记本中构建容器，上传到Registry，然后下载到一个物理的或者虚拟的服务器来测试，在把容器部署到具体的主机中。像标准集装箱一样，Docker容器方便替换，可以叠加，易于分发，并且尽量通用。</code></pre><h3 id="Registry（注册中心）"><a href="#Registry（注册中心）" class="headerlink" title="Registry（注册中心）"></a>Registry（注册中心）</h3><p>​    Docker用Registry来保存用户构建的镜像。Registry分为公共和私有两种。Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像（说明：在Docker Hub下载镜像巨慢，可以自己构建私有的Registry）。</p><p>​    <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p><h1 id="Docker安装与启动"><a href="#Docker安装与启动" class="headerlink" title="Docker安装与启动"></a>Docker安装与启动</h1><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>​    Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。</p><p>​    由于我们学习的环境都使用的是CentOS，因此这里我们将Docker安装到CentOS上。注意：这里建议安装在CentOS7.x以上的版本，在CentOS6.x的版本中，安装前需要安装其他很多的环境而且Docker很多补丁不支持更新。</p><p>​    请直接挂载课程配套的Centos7.x镜像    </p><p>（1）yum 包更新到最新</p><pre><code>sudo yum update</code></pre><p>（2）安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p><pre><code>sudo yum install -y yum-utils device-mapper-persistent-data lvm2</code></pre><p>（3）设置yum源为阿里云</p><pre><code>sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></pre><p>（4）安装docker</p><pre><code>sudo yum install docker-ce</code></pre><p>（5）安装后查看docker版本</p><pre><code>docker -v</code></pre><h2 id="设置ustc的镜像"><a href="#设置ustc的镜像" class="headerlink" title="设置ustc的镜像"></a>设置ustc的镜像</h2><p>ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。</p><p><a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker" target="_blank" rel="noopener">https://lug.ustc.edu.cn/wiki/mirrors/help/docker</a></p><p>编辑该文件：</p><pre><code>vi /etc/docker/daemon.json  </code></pre><p>在该文件中输入如下内容：</p><pre><code>{"registry-mirrors": ["https://docker.mirrors.ustc.edu.cn"]}</code></pre><h2 id="Docker的启动与停止"><a href="#Docker的启动与停止" class="headerlink" title="Docker的启动与停止"></a>Docker的启动与停止</h2><p><strong>systemctl</strong>命令是系统服务管理器指令</p><p>启动docker：</p><pre><code>systemctl start docker</code></pre><p>停止docker：</p><pre><code>systemctl stop docker</code></pre><p>重启docker：</p><pre><code>systemctl restart docker</code></pre><p>查看docker状态：</p><pre><code>systemctl status docker</code></pre><p>开机启动：</p><pre><code>systemctl enable docker</code></pre><p>查看docker概要信息</p><pre><code>docker info</code></pre><p>查看docker帮助文档</p><pre><code>docker --help</code></pre><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h2><h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><pre><code>docker images</code></pre><p>REPOSITORY：镜像名称</p><p>TAG：镜像标签</p><p>IMAGE ID：镜像ID</p><p>CREATED：镜像的创建日期（不是获取该镜像的日期）</p><p>SIZE：镜像大小</p><p>这些镜像都是存储在Docker宿主机的/var/lib/docker目录下</p><h3 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h3><p>如果你需要从网络中查找需要的镜像，可以通过以下命令搜索</p><pre><code>docker search 镜像名称</code></pre><p>NAME：仓库名称</p><p>DESCRIPTION：镜像描述</p><p>STARS：用户评价，反应一个镜像的受欢迎程度</p><p>OFFICIAL：是否官方</p><p>AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的</p><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p>拉取镜像就是从中央仓库中下载镜像到本地</p><pre><code>docker pull 镜像名称</code></pre><p>例如，我要下载centos7镜像</p><pre><code>docker pull centos:7</code></pre><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>按镜像ID删除镜像</p><pre><code>docker rmi 镜像ID</code></pre><p>删除所有镜像</p><pre><code>docker rmi `docker images -q`</code></pre><h2 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h2><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><p>查看正在运行的容器</p><pre><code>docker ps</code></pre><p>查看所有容器</p><pre><code>docker ps –a</code></pre><p>查看最后一次运行的容器</p><pre><code>docker ps –l</code></pre><p>查看停止的容器</p><pre><code>docker ps -f status=exited</code></pre><h3 id="创建与启动容器"><a href="#创建与启动容器" class="headerlink" title="创建与启动容器"></a>创建与启动容器</h3><p>创建容器常用的参数说明：</p><p>创建容器命令：docker run</p><p> -i：表示运行容器</p><p> -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。</p><p> –name :为创建的容器命名。</p><p> -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。</p><p> -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。</p><p> -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射</p><p>（1）交互式方式创建容器</p><pre><code>docker run -it --name=容器名称 镜像名称:标签 /bin/bash</code></pre><p>这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态  </p><p>退出当前容器</p><pre><code>exit</code></pre><p>（2）守护式方式创建容器：</p><pre><code>docker run -di --name=容器名称 镜像名称:标签</code></pre><p>登录守护式容器方式：</p><pre><code>docker exec -it 容器名称 (或者容器ID)  /bin/bash</code></pre><h3 id="停止与启动容器"><a href="#停止与启动容器" class="headerlink" title="停止与启动容器"></a>停止与启动容器</h3><p>停止容器：</p><pre><code>docker stop 容器名称（或者容器ID）</code></pre><p>启动容器：</p><pre><code>docker start 容器名称（或者容器ID）</code></pre><h3 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h3><p>如果我们需要将文件拷贝到容器内可以使用cp命令</p><pre><code>docker cp 需要拷贝的文件或目录 容器名称:容器目录</code></pre><p>也可以将文件从容器内拷贝出来</p><pre><code>docker cp 容器名称:容器目录 需要拷贝的文件或目录</code></pre><h3 id="目录挂载"><a href="#目录挂载" class="headerlink" title="目录挂载"></a>目录挂载</h3><p>我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。<br>创建容器 添加-v参数 后边为   宿主机目录:容器目录，例如：</p><pre><code>docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos3 centos:7</code></pre><p>如果你共享的是多级的目录，可能会出现权限不足的提示。</p><p>这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数  –privileged=true  来解决挂载的目录没有权限的问题</p><h3 id="查看容器IP地址"><a href="#查看容器IP地址" class="headerlink" title="查看容器IP地址"></a>查看容器IP地址</h3><p>我们可以通过以下命令查看容器运行的各种数据</p><pre><code>docker inspect 容器名称（容器ID） </code></pre><p>也可以直接执行下面的命令直接输出IP地址</p><pre><code>docker inspect --format='{{.NetworkSettings.IPAddress}}' 容器名称（容器ID）</code></pre><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>删除指定的容器：</p><pre><code>docker rm 容器名称（容器ID）</code></pre><h1 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h1><h2 id="MySQL部署"><a href="#MySQL部署" class="headerlink" title="MySQL部署"></a>MySQL部署</h2><p>（1）拉取mysql镜像</p><pre><code>docker pull centos/mysql-57-centos7</code></pre><p>（2）创建容器</p><pre><code>docker run -di --name=tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql</code></pre><p>-p 代表端口映射，格式为  宿主机映射端口:容器运行端口</p><p>-e 代表添加环境变量  MYSQL_ROOT_PASSWORD  是root用户的登陆密码</p><p>（3）远程登录mysql</p><p>连接宿主机的IP  ,指定端口为33306 </p><h2 id="tomcat部署"><a href="#tomcat部署" class="headerlink" title="tomcat部署"></a>tomcat部署</h2><p>（1）拉取镜像</p><pre><code>docker pull tomcat:7-jre7</code></pre><p>（2）创建容器</p><p>创建容器  -p表示地址映射</p><pre><code>docker run -di --name=mytomcat -p 9000:8080 -v /usr/local/webapps:/usr/local/tomcat/webapps tomcat:7-jre7</code></pre><h2 id="Nginx部署"><a href="#Nginx部署" class="headerlink" title="Nginx部署"></a>Nginx部署</h2><p>（1）拉取镜像    </p><pre><code>docker pull nginx</code></pre><p>（2）创建Nginx容器</p><pre><code>docker run -di --name=mynginx -p 80:80 nginx</code></pre><h2 id="Redis部署"><a href="#Redis部署" class="headerlink" title="Redis部署"></a>Redis部署</h2><p>（1）拉取镜像</p><pre><code>docker pull redis</code></pre><p>（2）创建容器</p><pre><code>docker run -di --name=myredis -p 6379:6379 redis</code></pre><h1 id="迁移与备份"><a href="#迁移与备份" class="headerlink" title="迁移与备份"></a>迁移与备份</h1><h2 id="容器保存为镜像"><a href="#容器保存为镜像" class="headerlink" title="容器保存为镜像"></a>容器保存为镜像</h2><p>我们可以通过以下命令将容器保存为镜像</p><pre><code>docker commit mynginx mynginx_i</code></pre><h2 id="镜像备份"><a href="#镜像备份" class="headerlink" title="镜像备份"></a>镜像备份</h2><p>我们可以通过以下命令将镜像保存为tar 文件</p><pre><code>docker  save -o mynginx.tar mynginx_i</code></pre><h2 id="镜像恢复与迁移"><a href="#镜像恢复与迁移" class="headerlink" title="镜像恢复与迁移"></a>镜像恢复与迁移</h2><p>首先我们先删除掉mynginx_img镜像  然后执行此命令进行恢复</p><pre><code>docker load -i mynginx.tar</code></pre><p>-i 输入的文件</p><p>执行后再次查看镜像，可以看到镜像已经恢复</p><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><blockquote><p><a href="https://www.cnblogs.com/panwenbin-logs/p/8007348.html" target="_blank" rel="noopener">Dockerfile文件详解</a></p></blockquote><h2 id="什么是Dockerfile"><a href="#什么是Dockerfile" class="headerlink" title="什么是Dockerfile"></a>什么是Dockerfile</h2><p>Dockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。</p><ul><li>对于开发人员：可以为开发团队提供一个完全一致的开发环境； </li><li>对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了； </li><li>对于运维人员：在部署时，可以实现应用的无缝移植。</li></ul><h2 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>FROM image_name:tag</td><td>定义了使用哪个基础镜像启动构建流程</td></tr><tr><td>MAINTAINER user_name</td><td>声明镜像的创建者</td></tr><tr><td>ENV key value</td><td>设置环境变量 (可以写多条)</td></tr><tr><td>RUN command</td><td>是Dockerfile的核心部分(可以写多条)</td></tr><tr><td>ADD source_dir/file dest_dir/file</td><td>将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压</td></tr><tr><td>COPY source_dir/file dest_dir/file</td><td>和ADD相似，但是如果有压缩文件并不能解压</td></tr><tr><td>WORKDIR path_dir</td><td>设置工作目录</td></tr></tbody></table><h2 id="使用脚本创建镜像"><a href="#使用脚本创建镜像" class="headerlink" title="使用脚本创建镜像"></a>使用脚本创建镜像</h2><p>步骤：</p><p>（1）创建目录</p><pre><code>mkdir –p /usr/local/dockerjdk8</code></pre><p>（2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/dockerjdk8目录</p><p>（3）创建文件Dockerfile  <code>vi Dockerfile</code></p><pre><code>#依赖镜像名称和IDFROM centos:7#指定镜像创建者信息MAINTAINER ITCAST#切换工作目录WORKDIR /usrRUN mkdir  /usr/local/java#ADD 是相对路径jar,把java添加到容器中ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/#配置java环境变量ENV JAVA_HOME /usr/local/java/jdk1.8.0_171ENV JRE_HOME $JAVA_HOME/jreENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATHENV PATH $JAVA_HOME/bin:$PATH</code></pre><p>（4）执行命令构建镜像</p><pre><code>docker build -t='jdk1.8' .</code></pre><p>注意后边的空格和点，不要省略</p><p>（5）查看镜像是否建立完成</p><pre><code>docker images</code></pre><h1 id="Docker私有仓库"><a href="#Docker私有仓库" class="headerlink" title="Docker私有仓库"></a>Docker私有仓库</h1><h2 id="私有仓库搭建与配置"><a href="#私有仓库搭建与配置" class="headerlink" title="私有仓库搭建与配置"></a>私有仓库搭建与配置</h2><p>（1）拉取私有仓库镜像（此步省略）</p><pre><code>docker pull registry</code></pre><p>（2）启动私有仓库容器</p><pre><code>docker run -di --name=registry -p 5000:5000 registry</code></pre><p>（3）打开浏览器 输入地址<a href="http://192.168.184.141:5000/v2/_catalog看到`{&quot;repositories&quot;:[]}`" target="_blank" rel="noopener">http://192.168.184.141:5000/v2/_catalog看到`{"repositories":[]}`</a> 表示私有仓库搭建成功并且内容为空</p><p>（4）修改daemon.json</p><pre><code>vi /etc/docker/daemon.json</code></pre><p>添加以下内容，保存退出。</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"insecure-registries"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"192.168.184.141:5000"</span><span class="token punctuation">]</span><span class="token punctuation">}</span> </code></pre><p>此步用于让 docker信任私有仓库地址</p><p>（5）重启docker 服务</p><pre><code>systemctl restart docker</code></pre><h2 id="镜像上传至私有仓库"><a href="#镜像上传至私有仓库" class="headerlink" title="镜像上传至私有仓库"></a>镜像上传至私有仓库</h2><p>（1）标记此镜像为私有仓库的镜像</p><pre><code>docker tag jdk1.8 192.168.184.141:5000/jdk1.8</code></pre><p>（2）再次启动私服容器</p><pre><code>docker start registry</code></pre><p>（3）上传标记的镜像</p><pre><code>docker push 192.168.184.141:5000/jdk1.8</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STUDY </tag>
            
            <tag> 运维 </tag>
            
            <tag> 容器 </tag>
            
            <tag> 虚拟化 </tag>
            
            <tag> 轻量级 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
